/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../common/lib/GreycatError.js":
/*!*************************************!*\
  !*** ../common/lib/GreycatError.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass GreyCatError {\n    constructor(reason, stack) {\n        this.reason = reason;\n        this.stack = stack;\n    }\n}\nexports.GreyCatError = GreyCatError;\n\n\n//# sourceURL=webpack:///../common/lib/GreycatError.js?");

/***/ }),

/***/ "../common/lib/index.js":
/*!******************************!*\
  !*** ../common/lib/index.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar keys_1 = __webpack_require__(/*! ./keys */ \"../common/lib/keys.js\");\nexports.Keys = keys_1.default;\nvar std_lib_1 = __webpack_require__(/*! ./std-lib */ \"../common/lib/std-lib.js\");\nexports.stdLib = std_lib_1.default;\n__export(__webpack_require__(/*! ./GreycatError */ \"../common/lib/GreycatError.js\"));\n__export(__webpack_require__(/*! ./utils */ \"../common/lib/utils.js\"));\n\n\n//# sourceURL=webpack:///../common/lib/index.js?");

/***/ }),

/***/ "../common/lib/keys.js":
/*!*****************************!*\
  !*** ../common/lib/keys.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Keys;\n(function (Keys) {\n    Keys[Keys[\"g_null\"] = 3392903] = \"g_null\";\n    Keys[Keys[\"g_Any\"] = 65996] = \"g_Any\";\n    Keys[Keys[\"g_bool\"] = 2076426] = \"g_bool\";\n    Keys[Keys[\"g_i8\"] = 2099062] = \"g_i8\";\n    Keys[Keys[\"g_i32\"] = 73679] = \"g_i32\";\n    Keys[Keys[\"u32\"] = 2605914] = \"u32\";\n    Keys[Keys[\"g_i64\"] = 2374300] = \"g_i64\";\n    Keys[Keys[\"g_u64\"] = 80873585] = \"g_u64\";\n    Keys[Keys[\"g_f64\"] = 2052876273] = \"g_f64\";\n    Keys[Keys[\"g_f32\"] = 67973692] = \"g_f32\";\n    Keys[Keys[\"g_Number\"] = -1950496919] = \"g_Number\";\n    Keys[Keys[\"g_String\"] = -1808118735] = \"g_String\";\n    Keys[Keys[\"g_Object\"] = -1939501217] = \"g_Object\";\n    Keys[Keys[\"g_Function\"] = 1445582840] = \"g_Function\";\n    Keys[Keys[\"g_Array\"] = 63537721] = \"g_Array\";\n    Keys[Keys[\"g_Node\"] = 2433570] = \"g_Node\";\n    Keys[Keys[\"g_Ref\"] = 82035] = \"g_Ref\";\n    Keys[Keys[\"g_Benchmark\"] = -1622859555] = \"g_Benchmark\";\n    Keys[Keys[\"g_Date\"] = 2122702] = \"g_Date\";\n    Keys[Keys[\"g_Time\"] = 2606829] = \"g_Time\";\n    Keys[Keys[\"g_Duration\"] = -1927368268] = \"g_Duration\";\n    Keys[Keys[\"g_DurationUnit\"] = -1771109032] = \"g_DurationUnit\";\n    Keys[Keys[\"g_Ctx\"] = 68103] = \"g_Ctx\";\n    Keys[Keys[\"g_offset\"] = -1019779949] = \"g_offset\";\n    Keys[Keys[\"g_src\"] = 114148] = \"g_src\";\n    Keys[Keys[\"g_root\"] = 3506402] = \"g_root\";\n    Keys[Keys[\"g_name\"] = 3373707] = \"g_name\";\n    Keys[Keys[\"g_alpha\"] = 92909918] = \"g_alpha\";\n    Keys[Keys[\"g_threshold\"] = -1545477013] = \"g_threshold\";\n    Keys[Keys[\"g_this\"] = 3559070] = \"g_this\";\n    Keys[Keys[\"g_key\"] = 106079] = \"g_key\";\n    Keys[Keys[\"g_keys\"] = 3288564] = \"g_keys\";\n    Keys[Keys[\"g_pearson\"] = -694166804] = \"g_pearson\";\n    Keys[Keys[\"g_print\"] = 106934957] = \"g_print\";\n    Keys[Keys[\"g_println\"] = -314717969] = \"g_println\";\n    Keys[Keys[\"g_flush\"] = 97532676] = \"g_flush\";\n    Keys[Keys[\"g_value\"] = 111972721] = \"g_value\";\n    Keys[Keys[\"g_value2\"] = -823812895] = \"g_value2\";\n    Keys[Keys[\"g_values\"] = -823812830] = \"g_values\";\n    Keys[Keys[\"g_NeuralNetwork\"] = 1547909967] = \"g_NeuralNetwork\";\n    Keys[Keys[\"g_nextDouble\"] = -1697992540] = \"g_nextDouble\";\n    Keys[Keys[\"g_nextInt\"] = 1847053308] = \"g_nextInt\";\n    Keys[Keys[\"g_nextLong\"] = 1424167951] = \"g_nextLong\";\n    Keys[Keys[\"g_nextGaussianDouble\"] = 1195401087] = \"g_nextGaussianDouble\";\n    Keys[Keys[\"g_nextGaussianFloat\"] = -98234130] = \"g_nextGaussianFloat\";\n    Keys[Keys[\"g_nextFloat\"] = 1193903913] = \"g_nextFloat\";\n    Keys[Keys[\"g_set\"] = 113762] = \"g_set\";\n    Keys[Keys[\"g_init\"] = 3237136] = \"g_init\";\n    Keys[Keys[\"g_shuffle\"] = 2072332025] = \"g_shuffle\";\n    Keys[Keys[\"g_reset\"] = 108404047] = \"g_reset\";\n    Keys[Keys[\"g_offsets\"] = -1548407232] = \"g_offsets\";\n    Keys[Keys[\"g_Type\"] = 2622298] = \"g_Type\";\n    Keys[Keys[\"g_type_attribute\"] = -664210473] = \"g_type_attribute\";\n    Keys[Keys[\"g_foreach\"] = -677682614] = \"g_foreach\";\n    Keys[Keys[\"g_newTime\"] = 1845207181] = \"g_newTime\";\n    Keys[Keys[\"g_newNode\"] = 1845033922] = \"g_newNode\";\n    Keys[Keys[\"g_isNode\"] = -1180267956] = \"g_isNode\";\n    Keys[Keys[\"g_firstTime\"] = 133022109] = \"g_firstTime\";\n    Keys[Keys[\"g_nextTime\"] = 1424400480] = \"g_nextTime\";\n    Keys[Keys[\"g_getTime\"] = -75121853] = \"g_getTime\";\n    Keys[Keys[\"g_getType\"] = -75106384] = \"g_getType\";\n    Keys[Keys[\"g_foreachTime\"] = -78318537] = \"g_foreachTime\";\n    Keys[Keys[\"g_new_node_timepoint\"] = 1594333541] = \"g_new_node_timepoint\";\n    Keys[Keys[\"g_timeline\"] = -2076650431] = \"g_timeline\";\n    Keys[Keys[\"g_Tensor\"] = -1793451911] = \"g_Tensor\";\n    Keys[Keys[\"g_time\"] = 3560141] = \"g_time\";\n    Keys[Keys[\"g_load\"] = 3327206] = \"g_load\";\n    Keys[Keys[\"g_load_all\"] = 1845922504] = \"g_load_all\";\n    Keys[Keys[\"g_index\"] = 100346066] = \"g_index\";\n    Keys[Keys[\"g_lookup\"] = -1097094790] = \"g_lookup\";\n    Keys[Keys[\"g_lookup_all\"] = 1300432220] = \"g_lookup_all\";\n    Keys[Keys[\"g_default\"] = 1544803905] = \"g_default\";\n    Keys[Keys[\"g_resolved_values\"] = -2001143991] = \"g_resolved_values\";\n    Keys[Keys[\"g_global_index\"] = -326497994] = \"g_global_index\";\n    Keys[Keys[\"g_add\"] = 96417] = \"g_add\";\n    Keys[Keys[\"g_addBias\"] = -1149118726] = \"g_addBias\";\n    Keys[Keys[\"g_multiply\"] = 653829668] = \"g_multiply\";\n    Keys[Keys[\"g_addToElement\"] = 831013984] = \"g_addToElement\";\n    Keys[Keys[\"g_addInPlace\"] = -461724927] = \"g_addInPlace\";\n    Keys[Keys[\"g_transpose\"] = 1052964665] = \"g_transpose\";\n    Keys[Keys[\"g_transposeA\"] = -1717833688] = \"g_transposeA\";\n    Keys[Keys[\"g_transposeB\"] = -1717833687] = \"g_transposeB\";\n    Keys[Keys[\"g_dim\"] = 99464] = \"g_dim\";\n    Keys[Keys[\"g_remove\"] = -934610812] = \"g_remove\";\n    Keys[Keys[\"g_mremove\"] = 1314009905] = \"g_mremove\";\n    Keys[Keys[\"g_seed\"] = 3526257] = \"g_seed\";\n    Keys[Keys[\"g_Random\"] = -1854418717] = \"g_Random\";\n    Keys[Keys[\"g_mean\"] = 3347397] = \"g_mean\";\n    Keys[Keys[\"g_mult\"] = 3363120] = \"g_mult\";\n    Keys[Keys[\"g_mul\"] = 108484] = \"g_mul\";\n    Keys[Keys[\"g_div\"] = 99473] = \"g_div\";\n    Keys[Keys[\"g_and\"] = 96727] = \"g_and\";\n    Keys[Keys[\"g_iand\"] = 3224782] = \"g_iand\";\n    Keys[Keys[\"g_or\"] = 3555] = \"g_or\";\n    Keys[Keys[\"g_ior\"] = 104460] = \"g_ior\";\n    Keys[Keys[\"g_xor\"] = 118875] = \"g_xor\";\n    Keys[Keys[\"g_ixor\"] = 3246930] = \"g_ixor\";\n    Keys[Keys[\"g_iadd\"] = 3224472] = \"g_iadd\";\n    Keys[Keys[\"g_isub\"] = 3242295] = \"g_isub\";\n    Keys[Keys[\"g_imul\"] = 3236539] = \"g_imul\";\n    Keys[Keys[\"g_idiv\"] = 3227528] = \"g_idiv\";\n    Keys[Keys[\"g_mod\"] = 108290] = \"g_mod\";\n    Keys[Keys[\"g_imod\"] = 3236345] = \"g_imod\";\n    Keys[Keys[\"g_neg\"] = 108944] = \"g_neg\";\n    Keys[Keys[\"g_product\"] = -309474065] = \"g_product\";\n    Keys[Keys[\"g_hadamardProduct\"] = 202643027] = \"g_hadamardProduct\";\n    Keys[Keys[\"g_scale\"] = 109250890] = \"g_scale\";\n    Keys[Keys[\"g_setAllElements\"] = 2048468982] = \"g_setAllElements\";\n    Keys[Keys[\"g_divide\"] = -1331463047] = \"g_divide\";\n    Keys[Keys[\"g_modulo\"] = -1068784010] = \"g_modulo\";\n    Keys[Keys[\"g_to\"] = 3707] = \"g_to\";\n    Keys[Keys[\"g_nb\"] = 3508] = \"g_nb\";\n    Keys[Keys[\"g_sub\"] = 114240] = \"g_sub\";\n    Keys[Keys[\"g_subInPlace\"] = 443391106] = \"g_subInPlace\";\n    Keys[Keys[\"g_inPlace\"] = 1925008098] = \"g_inPlace\";\n    Keys[Keys[\"g_target\"] = -880905839] = \"g_target\";\n    Keys[Keys[\"g_i\"] = 105] = \"g_i\";\n    Keys[Keys[\"g_j\"] = 106] = \"g_j\";\n    Keys[Keys[\"g_k\"] = 107] = \"g_k\";\n    Keys[Keys[\"g_callee_origin\"] = -426083577] = \"g_callee_origin\";\n    Keys[Keys[\"g_callee_session\"] = -1431227691] = \"g_callee_session\";\n    Keys[Keys[\"g_noop\"] = 3387234] = \"g_noop\";\n    Keys[Keys[\"g_std\"] = 114211] = \"g_std\";\n    Keys[Keys[\"g_path\"] = 3433509] = \"g_path\";\n    Keys[Keys[\"g_port\"] = 3446913] = \"g_port\";\n    Keys[Keys[\"g_lmdb\"] = 3325375] = \"g_lmdb\";\n    Keys[Keys[\"g_websocket_server\"] = -339307845] = \"g_websocket_server\";\n    Keys[Keys[\"g_websocket_client\"] = -791193789] = \"g_websocket_client\";\n    Keys[Keys[\"g_url\"] = 116079] = \"g_url\";\n    Keys[Keys[\"g_openblas\"] = -504225978] = \"g_openblas\";\n    Keys[Keys[\"g_cuda\"] = 3064943] = \"g_cuda\";\n    Keys[Keys[\"g_Cuda\"] = 2111631] = \"g_Cuda\";\n    Keys[Keys[\"g_eigen\"] = 96505900] = \"g_eigen\";\n    Keys[Keys[\"g_hybridblas\"] = 1573138936] = \"g_hybridblas\";\n    Keys[Keys[\"g_mqtt\"] = 3359524] = \"g_mqtt\";\n    Keys[Keys[\"g_mqtt_topic\"] = 680036436] = \"g_mqtt_topic\";\n    Keys[Keys[\"g_mqtt_topics_list\"] = 389591614] = \"g_mqtt_topics_list\";\n    Keys[Keys[\"g_mqtt_custom_parser\"] = 1265754834] = \"g_mqtt_custom_parser\";\n    Keys[Keys[\"g_opcua_server\"] = 2105970676] = \"g_opcua_server\";\n    Keys[Keys[\"g_opcua_client\"] = 1654084732] = \"g_opcua_client\";\n    Keys[Keys[\"g_opcua_node_identifier_list\"] = 661706024] = \"g_opcua_node_identifier_list\";\n    Keys[Keys[\"g_node_identifier\"] = -1608655098] = \"g_node_identifier\";\n    Keys[Keys[\"g_gateway\"] = -189118908] = \"g_gateway\";\n    Keys[Keys[\"g_remotes\"] = 1091834093] = \"g_remotes\";\n    Keys[Keys[\"g_subscriptions\"] = 1987365622] = \"g_subscriptions\";\n    Keys[Keys[\"g_cursor\"] = -1349119146] = \"g_cursor\";\n    Keys[Keys[\"g_grafana\"] = 280038788] = \"g_grafana\";\n    Keys[Keys[\"g_use_wss\"] = -147675553] = \"g_use_wss\";\n    Keys[Keys[\"g_cert\"] = 3050020] = \"g_cert\";\n    Keys[Keys[\"g_size\"] = 3530753] = \"g_size\";\n    Keys[Keys[\"g_ident\"] = 100049392] = \"g_ident\";\n    Keys[Keys[\"g_ident_ref\"] = 86053316] = \"g_ident_ref\";\n    Keys[Keys[\"g_x\"] = 120] = \"g_x\";\n    Keys[Keys[\"g_y\"] = 121] = \"g_y\";\n    Keys[Keys[\"g_cos\"] = 98695] = \"g_cos\";\n    Keys[Keys[\"g_sin\"] = 113880] = \"g_sin\";\n    Keys[Keys[\"g_tan\"] = 114593] = \"g_tan\";\n    Keys[Keys[\"g_sqrt\"] = 3538208] = \"g_sqrt\";\n    Keys[Keys[\"g_floor\"] = 97526796] = \"g_floor\";\n    Keys[Keys[\"g_ceil\"] = 3049733] = \"g_ceil\";\n    Keys[Keys[\"g_exp\"] = 100893] = \"g_exp\";\n    Keys[Keys[\"g_cosh\"] = 3059649] = \"g_cosh\";\n    Keys[Keys[\"g_sinh\"] = 3530384] = \"g_sinh\";\n    Keys[Keys[\"g_tanh\"] = 3552487] = \"g_tanh\";\n    Keys[Keys[\"g_acos\"] = 2988422] = \"g_acos\";\n    Keys[Keys[\"g_asin\"] = 3003607] = \"g_asin\";\n    Keys[Keys[\"g_atan\"] = 3004320] = \"g_atan\";\n    Keys[Keys[\"g_log\"] = 107332] = \"g_log\";\n    Keys[Keys[\"g_log2\"] = 3327342] = \"g_log2\";\n    Keys[Keys[\"g_log10\"] = 103147619] = \"g_log10\";\n    Keys[Keys[\"g_pow\"] = 111192] = \"g_pow\";\n    Keys[Keys[\"g_ipow\"] = 3239247] = \"g_ipow\";\n    Keys[Keys[\"g_ndim\"] = 3376474] = \"g_ndim\";\n    Keys[Keys[\"g_flatten\"] = -778804732] = \"g_flatten\";\n    Keys[Keys[\"g_trunc\"] = 110640556] = \"g_trunc\";\n    Keys[Keys[\"g_round\"] = 108704142] = \"g_round\";\n    Keys[Keys[\"g_min\"] = 108114] = \"g_min\";\n    Keys[Keys[\"g_max\"] = 107876] = \"g_max\";\n    Keys[Keys[\"g_row\"] = 113114] = \"g_row\";\n    Keys[Keys[\"g_col\"] = 98688] = \"g_col\";\n    Keys[Keys[\"g_column\"] = -1354837162] = \"g_column\";\n    Keys[Keys[\"g_abs\"] = 96370] = \"g_abs\";\n    Keys[Keys[\"g_get\"] = 102230] = \"g_get\";\n    Keys[Keys[\"g_mget\"] = 3349449] = \"g_mget\";\n    Keys[Keys[\"g_get_or_create\"] = -76050129] = \"g_get_or_create\";\n    Keys[Keys[\"g_now\"] = 109270] = \"g_now\";\n    Keys[Keys[\"g_square\"] = -894674659] = \"g_square\";\n    Keys[Keys[\"g_abstract_value\"] = -1821195500] = \"g_abstract_value\";\n    Keys[Keys[\"g_softmax_log\"] = 641076863] = \"g_softmax_log\";\n    Keys[Keys[\"g_linear\"] = -1102672091] = \"g_linear\";\n    Keys[Keys[\"g_sigmoid\"] = 2088248974] = \"g_sigmoid\";\n    Keys[Keys[\"g_sine\"] = 3530381] = \"g_sine\";\n    Keys[Keys[\"g_lecun_tanh\"] = -1469123197] = \"g_lecun_tanh\";\n    Keys[Keys[\"g_leaky_relu\"] = -630013915] = \"g_leaky_relu\";\n    Keys[Keys[\"g_relu\"] = 3496700] = \"g_relu\";\n    Keys[Keys[\"g_elu\"] = 100526] = \"g_elu\";\n    Keys[Keys[\"g_selu\"] = 3526491] = \"g_selu\";\n    Keys[Keys[\"g_softplus\"] = 1319132356] = \"g_softplus\";\n    Keys[Keys[\"g_softsign\"] = 1319218407] = \"g_softsign\";\n    Keys[Keys[\"g_hard_sigmoid\"] = 1196061498] = \"g_hard_sigmoid\";\n    Keys[Keys[\"g_gaussian\"] = -1526272517] = \"g_gaussian\";\n    Keys[Keys[\"g_zero\"] = 3735208] = \"g_zero\";\n    Keys[Keys[\"g_one\"] = 110182] = \"g_one\";\n    Keys[Keys[\"g_sigmoid_uniform\"] = 1717385475] = \"g_sigmoid_uniform\";\n    Keys[Keys[\"g_normal\"] = -1039745817] = \"g_normal\";\n    Keys[Keys[\"g_uniform\"] = -286926412] = \"g_uniform\";\n    Keys[Keys[\"g_lecun_uniform\"] = 322700184] = \"g_lecun_uniform\";\n    Keys[Keys[\"g_xavier\"] = -766268151] = \"g_xavier\";\n    Keys[Keys[\"g_xavier_uniform\"] = -1070328706] = \"g_xavier_uniform\";\n    Keys[Keys[\"g_relu_uniform\"] = 2030968689] = \"g_relu_uniform\";\n    Keys[Keys[\"g_identity\"] = -135761730] = \"g_identity\";\n    Keys[Keys[\"g_normal_in\"] = 236599165] = \"g_normal_in\";\n    Keys[Keys[\"g_normal_out\"] = -1255354378] = \"g_normal_out\";\n    Keys[Keys[\"g_normal_avg\"] = -1255367814] = \"g_normal_avg\";\n    Keys[Keys[\"g_uniform_in\"] = -839726192] = \"g_uniform_in\";\n    Keys[Keys[\"g_uniform_out\"] = -261702077] = \"g_uniform_out\";\n    Keys[Keys[\"g_uniform_avg\"] = -261715513] = \"g_uniform_avg\";\n    Keys[Keys[\"g_typeof\"] = -858802543] = \"g_typeof\";\n    Keys[Keys[\"g_nid\"] = 109065] = \"g_nid\";\n    Keys[Keys[\"g_toObject\"] = -1908304486] = \"g_toObject\";\n    Keys[Keys[\"g_toString\"] = -1776922004] = \"g_toString\";\n    Keys[Keys[\"g_clone\"] = 94756189] = \"g_clone\";\n    Keys[Keys[\"g_Map\"] = 77116] = \"g_Map\";\n    Keys[Keys[\"g_content\"] = 951530617] = \"g_content\";\n    Keys[Keys[\"g_beginOfTime\"] = -353660083] = \"g_beginOfTime\";\n    Keys[Keys[\"g_endOfTime\"] = 1480865279] = \"g_endOfTime\";\n    Keys[Keys[\"g_TimeWindow\"] = -1403983555] = \"g_TimeWindow\";\n    Keys[Keys[\"g_setWidth\"] = 1407839876] = \"g_setWidth\";\n    Keys[Keys[\"g_sum\"] = 114251] = \"g_sum\";\n    Keys[Keys[\"g_sumA\"] = 3541846] = \"g_sumA\";\n    Keys[Keys[\"g_sumB\"] = 3541847] = \"g_sumB\";\n    Keys[Keys[\"g_sumsq\"] = 109798889] = \"g_sumsq\";\n    Keys[Keys[\"g_sumsqA\"] = -891201672] = \"g_sumsqA\";\n    Keys[Keys[\"g_sumsqB\"] = -891201671] = \"g_sumsqB\";\n    Keys[Keys[\"g_random\"] = -938285885] = \"g_random\";\n    Keys[Keys[\"g_AB\"] = 2081] = \"g_AB\";\n    Keys[Keys[\"g_clear\"] = 94746189] = \"g_clear\";\n    Keys[Keys[\"g_avg\"] = 96978] = \"g_avg\";\n    Keys[Keys[\"g_File\"] = 2189724] = \"g_File\";\n    Keys[Keys[\"g_sep\"] = 113758] = \"g_sep\";\n    Keys[Keys[\"g_readAll\"] = 1080375339] = \"g_readAll\";\n    Keys[Keys[\"g_write\"] = 113399775] = \"g_write\";\n    Keys[Keys[\"g_writeln\"] = 1603004833] = \"g_writeln\";\n    Keys[Keys[\"g_removeKey\"] = 1282355003] = \"g_removeKey\";\n    Keys[Keys[\"g_delete\"] = -1335458389] = \"g_delete\";\n    Keys[Keys[\"g_startsWith\"] = -1555538761] = \"g_startsWith\";\n    Keys[Keys[\"g_endsWith\"] = 1743158238] = \"g_endsWith\";\n    Keys[Keys[\"g_start\"] = 109757538] = \"g_start\";\n    Keys[Keys[\"g_stop\"] = 3540994] = \"g_stop\";\n    Keys[Keys[\"g_strides\"] = -1881768774] = \"g_strides\";\n    Keys[Keys[\"g_shape\"] = 109399969] = \"g_shape\";\n    Keys[Keys[\"g_startTime\"] = -2129294769] = \"g_startTime\";\n    Keys[Keys[\"g_stopTime\"] = 1714814447] = \"g_stopTime\";\n    Keys[Keys[\"g_iteration\"] = -1996165411] = \"g_iteration\";\n    Keys[Keys[\"g_maxIterations\"] = 1371013562] = \"g_maxIterations\";\n    Keys[Keys[\"g_reportProgress\"] = 1530726273] = \"g_reportProgress\";\n    Keys[Keys[\"g_step\"] = 3540684] = \"g_step\";\n    Keys[Keys[\"g_operation\"] = 1662702951] = \"g_operation\";\n    Keys[Keys[\"g_speed\"] = 109641799] = \"g_speed\";\n    Keys[Keys[\"g_cycleTime\"] = -1561297709] = \"g_cycleTime\";\n    Keys[Keys[\"g_toPosition\"] = 727736516] = \"g_toPosition\";\n    Keys[Keys[\"g_lat\"] = 106911] = \"g_lat\";\n    Keys[Keys[\"g_lng\"] = 107301] = \"g_lng\";\n    Keys[Keys[\"g_epsilon\"] = -1535503510] = \"g_epsilon\";\n    Keys[Keys[\"g_RTree\"] = 78343952] = \"g_RTree\";\n    Keys[Keys[\"g_WordIndex\"] = -1421383736] = \"g_WordIndex\";\n    Keys[Keys[\"g_GeoCodeIndex\"] = -10238284] = \"g_GeoCodeIndex\";\n    Keys[Keys[\"g_north\"] = 105007365] = \"g_north\";\n    Keys[Keys[\"g_south\"] = 109627853] = \"g_south\";\n    Keys[Keys[\"g_east\"] = 3105789] = \"g_east\";\n    Keys[Keys[\"g_west\"] = 3645871] = \"g_west\";\n    Keys[Keys[\"g_workspace\"] = 1108864149] = \"g_workspace\";\n    Keys[Keys[\"g_getWorkspace\"] = 1099259359] = \"g_getWorkspace\";\n    Keys[Keys[\"g_Geocode\"] = 1585366174] = \"g_Geocode\";\n    Keys[Keys[\"g_from\"] = 3151786] = \"g_from\";\n    Keys[Keys[\"g_distance\"] = 288459765] = \"g_distance\";\n    Keys[Keys[\"g_Math\"] = 2390824] = \"g_Math\";\n    Keys[Keys[\"g_open\"] = 3417674] = \"g_open\";\n    Keys[Keys[\"g_GeoShape\"] = 1886723824] = \"g_GeoShape\";\n    Keys[Keys[\"g_on\"] = 3551] = \"g_on\";\n    Keys[Keys[\"g_in\"] = 3365] = \"g_in\";\n    Keys[Keys[\"g_invert\"] = -1183703082] = \"g_invert\";\n    Keys[Keys[\"g_matmul\"] = -1081244060] = \"g_matmul\";\n    Keys[Keys[\"g_fill\"] = 3143043] = \"g_fill\";\n    Keys[Keys[\"g_push\"] = 3452698] = \"g_push\";\n    Keys[Keys[\"g_contains\"] = -567445985] = \"g_contains\";\n    Keys[Keys[\"g_equal\"] = 96757556] = \"g_equal\";\n    Keys[Keys[\"g_overlap\"] = -1091287993] = \"g_overlap\";\n    Keys[Keys[\"g_containedBy\"] = 207619114] = \"g_containedBy\";\n    Keys[Keys[\"g_GeoShapeIndex\"] = 1607528386] = \"g_GeoShapeIndex\";\n    Keys[Keys[\"g_configure\"] = -804429082] = \"g_configure\";\n    Keys[Keys[\"g_new\"] = 108960] = \"g_new\";\n    Keys[Keys[\"g_store\"] = 109770977] = \"g_store\";\n    Keys[Keys[\"g_resolve\"] = 1097368044] = \"g_resolve\";\n    Keys[Keys[\"g_resolvedTime\"] = 421578469] = \"g_resolvedTime\";\n    Keys[Keys[\"g_Log\"] = 76580] = \"g_Log\";\n    Keys[Keys[\"g_Console\"] = -1678803657] = \"g_Console\";\n    Keys[Keys[\"g_info\"] = 3237038] = \"g_info\";\n    Keys[Keys[\"g_debug\"] = 95458899] = \"g_debug\";\n    Keys[Keys[\"g_warn\"] = 3641990] = \"g_warn\";\n    Keys[Keys[\"g_error\"] = 96784904] = \"g_error\";\n    Keys[Keys[\"g_Assert\"] = 1970626406] = \"g_Assert\";\n    Keys[Keys[\"g_equals\"] = -1295482945] = \"g_equals\";\n    Keys[Keys[\"g_equalsd\"] = -1505265531] = \"g_equalsd\";\n    Keys[Keys[\"g_isTrue\"] = -1180085800] = \"g_isTrue\";\n    Keys[Keys[\"g_isFalse\"] = 2058602009] = \"g_isFalse\";\n    Keys[Keys[\"g_isNull\"] = -1180261935] = \"g_isNull\";\n    Keys[Keys[\"g_isNotNull\"] = 1548782192] = \"g_isNotNull\";\n    Keys[Keys[\"g_Graph\"] = 69062958] = \"g_Graph\";\n    Keys[Keys[\"g_tref\"] = 3568543] = \"g_tref\";\n    Keys[Keys[\"g_parse\"] = 106437299] = \"g_parse\";\n    Keys[Keys[\"g_format\"] = -1268779017] = \"g_format\";\n    Keys[Keys[\"g_types\"] = 110844025] = \"g_types\";\n    Keys[Keys[\"g_rain\"] = 3492756] = \"g_rain\";\n    Keys[Keys[\"g_timespan\"] = -2076435561] = \"g_timespan\";\n    Keys[Keys[\"g_functions\"] = -140572773] = \"g_functions\";\n    Keys[Keys[\"g_incrementIndex\"] = 1792703139] = \"g_incrementIndex\";\n    Keys[Keys[\"g_type\"] = 3575610] = \"g_type\";\n    Keys[Keys[\"g_validity\"] = -1421265102] = \"g_validity\";\n    Keys[Keys[\"g_parentPage\"] = -244811175] = \"g_parentPage\";\n    Keys[Keys[\"g_parentOffset\"] = 935637469] = \"g_parentOffset\";\n    Keys[Keys[\"g_currentPage\"] = 601108392] = \"g_currentPage\";\n    Keys[Keys[\"g_nodeKey\"] = 2114429181] = \"g_nodeKey\";\n    Keys[Keys[\"g_milliseconds\"] = 85195282] = \"g_milliseconds\";\n    Keys[Keys[\"g_seconds\"] = 1970096767] = \"g_seconds\";\n    Keys[Keys[\"g_minutes\"] = 1064901855] = \"g_minutes\";\n    Keys[Keys[\"g_hours\"] = 99469071] = \"g_hours\";\n    Keys[Keys[\"g_days\"] = 3076183] = \"g_days\";\n    Keys[Keys[\"g_weeks\"] = 113008383] = \"g_weeks\";\n    Keys[Keys[\"g_months\"] = -1068487181] = \"g_months\";\n    Keys[Keys[\"g_years\"] = 114851798] = \"g_years\";\n    Keys[Keys[\"g_of\"] = 3543] = \"g_of\";\n    Keys[Keys[\"g_timepoint\"] = 52214499] = \"g_timepoint\";\n    Keys[Keys[\"g_allocate\"] = 1812533053] = \"g_allocate\";\n    Keys[Keys[\"g_put\"] = 111375] = \"g_put\";\n    Keys[Keys[\"g_save\"] = 3522941] = \"g_save\";\n    Keys[Keys[\"g_configureStore\"] = -129858149] = \"g_configureStore\";\n    Keys[Keys[\"g_options\"] = -1249474914] = \"g_options\";\n    Keys[Keys[\"g_deviceQuery\"] = -1555787758] = \"g_deviceQuery\";\n    Keys[Keys[\"g_exists\"] = -1289358244] = \"g_exists\";\n    Keys[Keys[\"g_toLocale\"] = -1982398283] = \"g_toLocale\";\n    Keys[Keys[\"g_toTimestamp\"] = -566995749] = \"g_toTimestamp\";\n    Keys[Keys[\"g_FileMode\"] = -671094433] = \"g_FileMode\";\n    Keys[Keys[\"g_read\"] = 3496342] = \"g_read\";\n    Keys[Keys[\"g_readLine\"] = -867777878] = \"g_readLine\";\n    Keys[Keys[\"g_copyData\"] = -506441537] = \"g_copyData\";\n    Keys[Keys[\"g_position\"] = 747804969] = \"g_position\";\n    Keys[Keys[\"g_append\"] = -1411068134] = \"g_append\";\n    Keys[Keys[\"g_mode\"] = 3357091] = \"g_mode\";\n    Keys[Keys[\"g_decSep\"] = -1335744260] = \"g_decSep\";\n    Keys[Keys[\"g_thSep\"] = 110309706] = \"g_thSep\";\n    Keys[Keys[\"g_fromValue\"] = 71812071] = \"g_fromValue\";\n    Keys[Keys[\"g_toGPU\"] = 110506033] = \"g_toGPU\";\n    Keys[Keys[\"g_fromGPU\"] = -594352990] = \"g_fromGPU\";\n    Keys[Keys[\"g_getValue\"] = 1967798203] = \"g_getValue\";\n    Keys[Keys[\"g_Json\"] = 2318600] = \"g_Json\";\n    Keys[Keys[\"g_withMeta\"] = -940939285] = \"g_withMeta\";\n    Keys[Keys[\"g_isDirectory\"] = 215834723] = \"g_isDirectory\";\n    Keys[Keys[\"g_version\"] = 351608024] = \"g_version\";\n    Keys[Keys[\"g_fullVersion\"] = -793025719] = \"g_fullVersion\";\n    Keys[Keys[\"g_slice\"] = 109526418] = \"g_slice\";\n    Keys[Keys[\"g_indexOf\"] = 1943291465] = \"g_indexOf\";\n    Keys[Keys[\"g_maxLevel\"] = 390120576] = \"g_maxLevel\";\n    Keys[Keys[\"g_swap\"] = 3543443] = \"g_swap\";\n    Keys[Keys[\"g_sort\"] = 3536286] = \"g_sort\";\n    Keys[Keys[\"g_time2\"] = 110364421] = \"g_time2\";\n    Keys[Keys[\"g_Enum\"] = 2165025] = \"g_Enum\";\n    Keys[Keys[\"g_Blob\"] = 2073533] = \"g_Blob\";\n    Keys[Keys[\"g_searchWithin\"] = 224729139] = \"g_searchWithin\";\n    Keys[Keys[\"g_compression\"] = 1431984486] = \"g_compression\";\n    Keys[Keys[\"g_resize\"] = -934437708] = \"g_resize\";\n    Keys[Keys[\"g_E\"] = 69] = \"g_E\";\n    Keys[Keys[\"g_LOG2E\"] = 72610935] = \"g_LOG2E\";\n    Keys[Keys[\"g_LOG10E\"] = -2044029854] = \"g_LOG10E\";\n    Keys[Keys[\"g_LN2\"] = 75504] = \"g_LN2\";\n    Keys[Keys[\"g_LN10\"] = 2340641] = \"g_LN10\";\n    Keys[Keys[\"g_PI\"] = 2553] = \"g_PI\";\n    Keys[Keys[\"g_PI_2\"] = 2456428] = \"g_PI_2\";\n    Keys[Keys[\"g_PI_4\"] = 2456430] = \"g_PI_4\";\n    Keys[Keys[\"g_1_PI\"] = 1553607] = \"g_1_PI\";\n    Keys[Keys[\"g_2_PI\"] = 1583398] = \"g_2_PI\";\n    Keys[Keys[\"g_2_SQRTPI\"] = 2108225478] = \"g_2_SQRTPI\";\n    Keys[Keys[\"g_SQRT2\"] = 79146770] = \"g_SQRT2\";\n    Keys[Keys[\"g_SQRT1_2\"] = -1249363324] = \"g_SQRT1_2\";\n    Keys[Keys[\"g_CalcGraph\"] = 678011865] = \"g_CalcGraph\";\n    Keys[Keys[\"g_CGOperator\"] = -197660376] = \"g_CGOperator\";\n    Keys[Keys[\"g_CGHeap\"] = 1985968240] = \"g_CGHeap\";\n    Keys[Keys[\"g_CGTarget\"] = 1890355989] = \"g_CGTarget\";\n    Keys[Keys[\"g_CGOptimizer\"] = -1651748559] = \"g_CGOptimizer\";\n    Keys[Keys[\"g_CGInitializer\"] = 998694878] = \"g_CGInitializer\";\n    Keys[Keys[\"g_CGActivation\"] = 1063794842] = \"g_CGActivation\";\n    Keys[Keys[\"g_initializerCode\"] = -354711569] = \"g_initializerCode\";\n    Keys[Keys[\"g_activationCode\"] = -1344788445] = \"g_activationCode\";\n    Keys[Keys[\"g_optimizerCode\"] = 390039746] = \"g_optimizerCode\";\n    Keys[Keys[\"g_setOptimizer\"] = -912114957] = \"g_setOptimizer\";\n    Keys[Keys[\"g_optimizer\"] = 1843464501] = \"g_optimizer\";\n    Keys[Keys[\"g_code\"] = 3059181] = \"g_code\";\n    Keys[Keys[\"g_input\"] = 100358090] = \"g_input\";\n    Keys[Keys[\"g_input2\"] = -1183866456] = \"g_input2\";\n    Keys[Keys[\"g_output\"] = -1005512447] = \"g_output\";\n    Keys[Keys[\"g_newVar\"] = -1048854169] = \"g_newVar\";\n    Keys[Keys[\"g_newVaro\"] = 1845259240] = \"g_newVaro\";\n    Keys[Keys[\"g_newOp\"] = 104713121] = \"g_newOp\";\n    Keys[Keys[\"g_newPath\"] = 1845080549] = \"g_newPath\";\n    Keys[Keys[\"g_nbVars\"] = -1052596736] = \"g_nbVars\";\n    Keys[Keys[\"g_forward\"] = -677145915] = \"g_forward\";\n    Keys[Keys[\"g_backward\"] = 2121976803] = \"g_backward\";\n    Keys[Keys[\"g_optimize\"] = -79080739] = \"g_optimize\";\n    Keys[Keys[\"g_memSize\"] = 948438902] = \"g_memSize\";\n    Keys[Keys[\"g_blas\"] = 3026428] = \"g_blas\";\n    Keys[Keys[\"g_cpu\"] = 98728] = \"g_cpu\";\n    Keys[Keys[\"g_cast\"] = 3046207] = \"g_cast\";\n    Keys[Keys[\"g_rmse\"] = 3504589] = \"g_rmse\";\n    Keys[Keys[\"g_loss\"] = 3327779] = \"g_loss\";\n    Keys[Keys[\"g_derive\"] = -1335275737] = \"g_derive\";\n    Keys[Keys[\"g_getGradient\"] = -2127416154] = \"g_getGradient\";\n    Keys[Keys[\"g_cwd\"] = 98928] = \"g_cwd\";\n    Keys[Keys[\"g_adadelta\"] = -1317538342] = \"g_adadelta\";\n    Keys[Keys[\"g_adagrad\"] = -1150778388] = \"g_adagrad\";\n    Keys[Keys[\"g_adam\"] = 2988943] = \"g_adam\";\n    Keys[Keys[\"g_adamax\"] = -1422589946] = \"g_adamax\";\n    Keys[Keys[\"g_ftrl\"] = 3153800] = \"g_ftrl\";\n    Keys[Keys[\"g_nadam\"] = 104576253] = \"g_nadam\";\n    Keys[Keys[\"g_rmsprop\"] = 1326436603] = \"g_rmsprop\";\n    Keys[Keys[\"g_sgd\"] = 113808] = \"g_sgd\";\n    Keys[Keys[\"g_momentum\"] = -361295720] = \"g_momentum\";\n    Keys[Keys[\"g_nesterov\"] = 1281769900] = \"g_nesterov\";\n    Keys[Keys[\"g_learningRate\"] = -1439664866] = \"g_learningRate\";\n    Keys[Keys[\"g_decayRate\"] = 133229498] = \"g_decayRate\";\n    Keys[Keys[\"g_rho\"] = 112889] = \"g_rho\";\n    Keys[Keys[\"g_beta\"] = 3020272] = \"g_beta\";\n    Keys[Keys[\"g_lambda1\"] = -53140150] = \"g_lambda1\";\n    Keys[Keys[\"g_beta1\"] = 93628481] = \"g_beta1\";\n    Keys[Keys[\"g_beta2\"] = 93628482] = \"g_beta2\";\n    Keys[Keys[\"g_initialAccumulator\"] = 843630242] = \"g_initialAccumulator\";\n    Keys[Keys[\"g_smoothEpsilon\"] = 1353717212] = \"g_smoothEpsilon\";\n    Keys[Keys[\"g_none\"] = 3387192] = \"g_none\";\n    Keys[Keys[\"g_configureVar\"] = 1170815585] = \"g_configureVar\";\n    Keys[Keys[\"g_prepare\"] = -318370553] = \"g_prepare\";\n    Keys[Keys[\"g_forwardOnly\"] = 1653095441] = \"g_forwardOnly\";\n    Keys[Keys[\"g_l1\"] = 3397] = \"g_l1\";\n    Keys[Keys[\"g_l2\"] = 3398] = \"g_l2\";\n    Keys[Keys[\"g_ip1\"] = 104426] = \"g_ip1\";\n    Keys[Keys[\"g_ip2\"] = 104427] = \"g_ip2\";\n    Keys[Keys[\"g_initialize\"] = 871091088] = \"g_initialize\";\n    Keys[Keys[\"g_setSeed\"] = 1984953843] = \"g_setSeed\";\n    Keys[Keys[\"g_maxValue\"] = 399227501] = \"g_maxValue\";\n    Keys[Keys[\"g_trim\"] = 3568674] = \"g_trim\";\n    Keys[Keys[\"g_prefetch\"] = -1288666633] = \"g_prefetch\";\n    Keys[Keys[\"g_setAutoSync\"] = -866935956] = \"g_setAutoSync\";\n    Keys[Keys[\"g_lowercase\"] = -514507343] = \"g_lowercase\";\n    Keys[Keys[\"g_uppercase\"] = 223523538] = \"g_uppercase\";\n    Keys[Keys[\"g_compare\"] = 950484197] = \"g_compare\";\n    Keys[Keys[\"g_endRound\"] = 1713408371] = \"g_endRound\";\n    Keys[Keys[\"g_readOnly\"] = -867683742] = \"g_readOnly\";\n    Keys[Keys[\"g_Process\"] = 1355134543] = \"g_Process\";\n    Keys[Keys[\"g_getEnv\"] = -1249363529] = \"g_getEnv\";\n    Keys[Keys[\"g_dense\"] = 95470367] = \"g_dense\";\n    Keys[Keys[\"g_activation\"] = 2041217302] = \"g_activation\";\n    Keys[Keys[\"g_dropout\"] = 1925735935] = \"g_dropout\";\n})(Keys || (Keys = {}));\nexports.default = Keys;\n\n\n//# sourceURL=webpack:///../common/lib/keys.js?");

/***/ }),

/***/ "../common/lib/std-lib.js":
/*!********************************!*\
  !*** ../common/lib/std-lib.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! @greycat/types */ \"../types/std.types.json\"));\nconst stdLib = __webpack_require__(/*! @greycat/types */ \"../types/std.types.json\");\nexports.default = stdLib;\n\n\n//# sourceURL=webpack:///../common/lib/std-lib.js?");

/***/ }),

/***/ "../common/lib/utils.js":
/*!******************************!*\
  !*** ../common/lib/utils.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction hash(str) {\n    let h = 0;\n    let i = 0;\n    const len = str.length;\n    while (i < len) {\n        h = ((h << 5) - h + str.charCodeAt(i++)) << 0;\n    }\n    return h;\n}\nexports.hash = hash;\n\n\n//# sourceURL=webpack:///../common/lib/utils.js?");

/***/ }),

/***/ "../node_modules/assertion-error/index.js":
/*!************************************************!*\
  !*** ../node_modules/assertion-error/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * assertion-error\n * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>\n * MIT Licensed\n */\n\n/*!\n * Return a function that will copy properties from\n * one object to another excluding any originally\n * listed. Returned function will create a new `{}`.\n *\n * @param {String} excluded properties ...\n * @return {Function}\n */\n\nfunction exclude () {\n  var excludes = [].slice.call(arguments);\n\n  function excludeProps (res, obj) {\n    Object.keys(obj).forEach(function (key) {\n      if (!~excludes.indexOf(key)) res[key] = obj[key];\n    });\n  }\n\n  return function extendExclude () {\n    var args = [].slice.call(arguments)\n      , i = 0\n      , res = {};\n\n    for (; i < args.length; i++) {\n      excludeProps(res, args[i]);\n    }\n\n    return res;\n  };\n};\n\n/*!\n * Primary Exports\n */\n\nmodule.exports = AssertionError;\n\n/**\n * ### AssertionError\n *\n * An extension of the JavaScript `Error` constructor for\n * assertion and validation scenarios.\n *\n * @param {String} message\n * @param {Object} properties to include (optional)\n * @param {callee} start stack function (optional)\n */\n\nfunction AssertionError (message, _props, ssf) {\n  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')\n    , props = extend(_props || {});\n\n  // default values\n  this.message = message || 'Unspecified AssertionError';\n  this.showDiff = false;\n\n  // copy from properties\n  for (var key in props) {\n    this[key] = props[key];\n  }\n\n  // capture stack trace\n  ssf = ssf || AssertionError;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, ssf);\n  } else {\n    try {\n      throw new Error();\n    } catch(e) {\n      this.stack = e.stack;\n    }\n  }\n}\n\n/*!\n * Inherit from Error.prototype\n */\n\nAssertionError.prototype = Object.create(Error.prototype);\n\n/*!\n * Statically set name\n */\n\nAssertionError.prototype.name = 'AssertionError';\n\n/*!\n * Ensure correct constructor\n */\n\nAssertionError.prototype.constructor = AssertionError;\n\n/**\n * Allow errors to be converted to JSON for static transfer.\n *\n * @param {Boolean} include stack (default: `true`)\n * @return {Object} object that can be `JSON.stringify`\n */\n\nAssertionError.prototype.toJSON = function (stack) {\n  var extend = exclude('constructor', 'toJSON', 'stack')\n    , props = extend({ name: this.name }, this);\n\n  // include stack if exists and not turned off\n  if (false !== stack && this.stack) {\n    props.stack = this.stack;\n  }\n\n  return props;\n};\n\n\n//# sourceURL=webpack:///../node_modules/assertion-error/index.js?");

/***/ }),

/***/ "../node_modules/chai/index.js":
/*!*************************************!*\
  !*** ../node_modules/chai/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/chai */ \"../node_modules/chai/lib/chai.js\");\n\n\n//# sourceURL=webpack:///../node_modules/chai/index.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai.js":
/*!****************************************!*\
  !*** ../node_modules/chai/lib/chai.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar used = [];\n\n/*!\n * Chai version\n */\n\nexports.version = '4.2.0';\n\n/*!\n * Assertion Error\n */\n\nexports.AssertionError = __webpack_require__(/*! assertion-error */ \"../node_modules/assertion-error/index.js\");\n\n/*!\n * Utils for plugins (not exported)\n */\n\nvar util = __webpack_require__(/*! ./chai/utils */ \"../node_modules/chai/lib/chai/utils/index.js\");\n\n/**\n * # .use(function)\n *\n * Provides a way to extend the internals of Chai.\n *\n * @param {Function}\n * @returns {this} for chaining\n * @api public\n */\n\nexports.use = function (fn) {\n  if (!~used.indexOf(fn)) {\n    fn(exports, util);\n    used.push(fn);\n  }\n\n  return exports;\n};\n\n/*!\n * Utility Functions\n */\n\nexports.util = util;\n\n/*!\n * Configuration\n */\n\nvar config = __webpack_require__(/*! ./chai/config */ \"../node_modules/chai/lib/chai/config.js\");\nexports.config = config;\n\n/*!\n * Primary `Assertion` prototype\n */\n\nvar assertion = __webpack_require__(/*! ./chai/assertion */ \"../node_modules/chai/lib/chai/assertion.js\");\nexports.use(assertion);\n\n/*!\n * Core Assertions\n */\n\nvar core = __webpack_require__(/*! ./chai/core/assertions */ \"../node_modules/chai/lib/chai/core/assertions.js\");\nexports.use(core);\n\n/*!\n * Expect interface\n */\n\nvar expect = __webpack_require__(/*! ./chai/interface/expect */ \"../node_modules/chai/lib/chai/interface/expect.js\");\nexports.use(expect);\n\n/*!\n * Should interface\n */\n\nvar should = __webpack_require__(/*! ./chai/interface/should */ \"../node_modules/chai/lib/chai/interface/should.js\");\nexports.use(should);\n\n/*!\n * Assert interface\n */\n\nvar assert = __webpack_require__(/*! ./chai/interface/assert */ \"../node_modules/chai/lib/chai/interface/assert.js\");\nexports.use(assert);\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/assertion.js":
/*!**************************************************!*\
  !*** ../node_modules/chai/lib/chai/assertion.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * chai\n * http://chaijs.com\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar config = __webpack_require__(/*! ./config */ \"../node_modules/chai/lib/chai/config.js\");\n\nmodule.exports = function (_chai, util) {\n  /*!\n   * Module dependencies.\n   */\n\n  var AssertionError = _chai.AssertionError\n    , flag = util.flag;\n\n  /*!\n   * Module export.\n   */\n\n  _chai.Assertion = Assertion;\n\n  /*!\n   * Assertion Constructor\n   *\n   * Creates object for chaining.\n   *\n   * `Assertion` objects contain metadata in the form of flags. Three flags can\n   * be assigned during instantiation by passing arguments to this constructor:\n   *\n   * - `object`: This flag contains the target of the assertion. For example, in\n   *   the assertion `expect(numKittens).to.equal(7);`, the `object` flag will\n   *   contain `numKittens` so that the `equal` assertion can reference it when\n   *   needed.\n   *\n   * - `message`: This flag contains an optional custom error message to be\n   *   prepended to the error message that's generated by the assertion when it\n   *   fails.\n   *\n   * - `ssfi`: This flag stands for \"start stack function indicator\". It\n   *   contains a function reference that serves as the starting point for\n   *   removing frames from the stack trace of the error that's created by the\n   *   assertion when it fails. The goal is to provide a cleaner stack trace to\n   *   end users by removing Chai's internal functions. Note that it only works\n   *   in environments that support `Error.captureStackTrace`, and only when\n   *   `Chai.config.includeStack` hasn't been set to `false`.\n   *\n   * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag\n   *   should retain its current value, even as assertions are chained off of\n   *   this object. This is usually set to `true` when creating a new assertion\n   *   from within another assertion. It's also temporarily set to `true` before\n   *   an overwritten assertion gets called by the overwriting assertion.\n   *\n   * @param {Mixed} obj target of the assertion\n   * @param {String} msg (optional) custom error message\n   * @param {Function} ssfi (optional) starting point for removing stack frames\n   * @param {Boolean} lockSsfi (optional) whether or not the ssfi flag is locked\n   * @api private\n   */\n\n  function Assertion (obj, msg, ssfi, lockSsfi) {\n    flag(this, 'ssfi', ssfi || Assertion);\n    flag(this, 'lockSsfi', lockSsfi);\n    flag(this, 'object', obj);\n    flag(this, 'message', msg);\n\n    return util.proxify(this);\n  }\n\n  Object.defineProperty(Assertion, 'includeStack', {\n    get: function() {\n      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\n      return config.includeStack;\n    },\n    set: function(value) {\n      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\n      config.includeStack = value;\n    }\n  });\n\n  Object.defineProperty(Assertion, 'showDiff', {\n    get: function() {\n      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\n      return config.showDiff;\n    },\n    set: function(value) {\n      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\n      config.showDiff = value;\n    }\n  });\n\n  Assertion.addProperty = function (name, fn) {\n    util.addProperty(this.prototype, name, fn);\n  };\n\n  Assertion.addMethod = function (name, fn) {\n    util.addMethod(this.prototype, name, fn);\n  };\n\n  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {\n    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);\n  };\n\n  Assertion.overwriteProperty = function (name, fn) {\n    util.overwriteProperty(this.prototype, name, fn);\n  };\n\n  Assertion.overwriteMethod = function (name, fn) {\n    util.overwriteMethod(this.prototype, name, fn);\n  };\n\n  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {\n    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);\n  };\n\n  /**\n   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)\n   *\n   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.\n   *\n   * @name assert\n   * @param {Philosophical} expression to be tested\n   * @param {String|Function} message or function that returns message to display if expression fails\n   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails\n   * @param {Mixed} expected value (remember to check for negation)\n   * @param {Mixed} actual (optional) will default to `this.obj`\n   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails\n   * @api private\n   */\n\n  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {\n    var ok = util.test(this, arguments);\n    if (false !== showDiff) showDiff = true;\n    if (undefined === expected && undefined === _actual) showDiff = false;\n    if (true !== config.showDiff) showDiff = false;\n\n    if (!ok) {\n      msg = util.getMessage(this, arguments);\n      var actual = util.getActual(this, arguments);\n      throw new AssertionError(msg, {\n          actual: actual\n        , expected: expected\n        , showDiff: showDiff\n      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));\n    }\n  };\n\n  /*!\n   * ### ._obj\n   *\n   * Quick reference to stored `actual` value for plugin developers.\n   *\n   * @api private\n   */\n\n  Object.defineProperty(Assertion.prototype, '_obj',\n    { get: function () {\n        return flag(this, 'object');\n      }\n    , set: function (val) {\n        flag(this, 'object', val);\n      }\n  });\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/assertion.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/config.js":
/*!***********************************************!*\
  !*** ../node_modules/chai/lib/chai/config.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\n\n  /**\n   * ### config.includeStack\n   *\n   * User configurable property, influences whether stack trace\n   * is included in Assertion error message. Default of false\n   * suppresses stack trace in the error message.\n   *\n   *     chai.config.includeStack = true;  // enable stack on error\n   *\n   * @param {Boolean}\n   * @api public\n   */\n\n  includeStack: false,\n\n  /**\n   * ### config.showDiff\n   *\n   * User configurable property, influences whether or not\n   * the `showDiff` flag should be included in the thrown\n   * AssertionErrors. `false` will always be `false`; `true`\n   * will be true when the assertion has requested a diff\n   * be shown.\n   *\n   * @param {Boolean}\n   * @api public\n   */\n\n  showDiff: true,\n\n  /**\n   * ### config.truncateThreshold\n   *\n   * User configurable property, sets length threshold for actual and\n   * expected values in assertion errors. If this threshold is exceeded, for\n   * example for large data structures, the value is replaced with something\n   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.\n   *\n   * Set it to zero if you want to disable truncating altogether.\n   *\n   * This is especially userful when doing assertions on arrays: having this\n   * set to a reasonable large value makes the failure messages readily\n   * inspectable.\n   *\n   *     chai.config.truncateThreshold = 0;  // disable truncating\n   *\n   * @param {Number}\n   * @api public\n   */\n\n  truncateThreshold: 40,\n\n  /**\n   * ### config.useProxy\n   *\n   * User configurable property, defines if chai will use a Proxy to throw\n   * an error when a non-existent property is read, which protects users\n   * from typos when using property-based assertions.\n   *\n   * Set it to false if you want to disable this feature.\n   *\n   *     chai.config.useProxy = false;  // disable use of Proxy\n   *\n   * This feature is automatically disabled regardless of this config value\n   * in environments that don't support proxies.\n   *\n   * @param {Boolean}\n   * @api public\n   */\n\n  useProxy: true,\n\n  /**\n   * ### config.proxyExcludedKeys\n   *\n   * User configurable property, defines which properties should be ignored\n   * instead of throwing an error if they do not exist on the assertion.\n   * This is only applied if the environment Chai is running in supports proxies and\n   * if the `useProxy` configuration setting is enabled.\n   * By default, `then` and `inspect` will not throw an error if they do not exist on the\n   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when\n   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.\n   *\n   *     // By default these keys will not throw an error if they do not exist on the assertion object\n   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];\n   *\n   * @param {Array}\n   * @api public\n   */\n\n  proxyExcludedKeys: ['then', 'catch', 'inspect', 'toJSON']\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/config.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/core/assertions.js":
/*!********************************************************!*\
  !*** ../node_modules/chai/lib/chai/core/assertions.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * chai\n * http://chaijs.com\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, _) {\n  var Assertion = chai.Assertion\n    , AssertionError = chai.AssertionError\n    , flag = _.flag;\n\n  /**\n   * ### Language Chains\n   *\n   * The following are provided as chainable getters to improve the readability\n   * of your assertions.\n   *\n   * **Chains**\n   *\n   * - to\n   * - be\n   * - been\n   * - is\n   * - that\n   * - which\n   * - and\n   * - has\n   * - have\n   * - with\n   * - at\n   * - of\n   * - same\n   * - but\n   * - does\n   * - still\n   *\n   * @name language chains\n   * @namespace BDD\n   * @api public\n   */\n\n  [ 'to', 'be', 'been', 'is'\n  , 'and', 'has', 'have', 'with'\n  , 'that', 'which', 'at', 'of'\n  , 'same', 'but', 'does', 'still' ].forEach(function (chain) {\n    Assertion.addProperty(chain);\n  });\n\n  /**\n   * ### .not\n   *\n   * Negates all assertions that follow in the chain.\n   *\n   *     expect(function () {}).to.not.throw();\n   *     expect({a: 1}).to.not.have.property('b');\n   *     expect([1, 2]).to.be.an('array').that.does.not.include(3);\n   *\n   * Just because you can negate any assertion with `.not` doesn't mean you\n   * should. With great power comes great responsibility. It's often best to\n   * assert that the one expected output was produced, rather than asserting\n   * that one of countless unexpected outputs wasn't produced. See individual\n   * assertions for specific guidance.\n   *\n   *     expect(2).to.equal(2); // Recommended\n   *     expect(2).to.not.equal(1); // Not recommended\n   *\n   * @name not\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('not', function () {\n    flag(this, 'negate', true);\n  });\n\n  /**\n   * ### .deep\n   *\n   * Causes all `.equal`, `.include`, `.members`, `.keys`, and `.property`\n   * assertions that follow in the chain to use deep equality instead of strict\n   * (`===`) equality. See the `deep-eql` project page for info on the deep\n   * equality algorithm: https://github.com/chaijs/deep-eql.\n   *\n   *     // Target object deeply (but not strictly) equals `{a: 1}`\n   *     expect({a: 1}).to.deep.equal({a: 1});\n   *     expect({a: 1}).to.not.equal({a: 1});\n   *\n   *     // Target array deeply (but not strictly) includes `{a: 1}`\n   *     expect([{a: 1}]).to.deep.include({a: 1});\n   *     expect([{a: 1}]).to.not.include({a: 1});\n   *\n   *     // Target object deeply (but not strictly) includes `x: {a: 1}`\n   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});\n   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});\n   *\n   *     // Target array deeply (but not strictly) has member `{a: 1}`\n   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);\n   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);\n   *\n   *     // Target set deeply (but not strictly) has key `{a: 1}`\n   *     expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);\n   *     expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);\n   *\n   *     // Target object deeply (but not strictly) has property `x: {a: 1}`\n   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});\n   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});\n   *\n   * @name deep\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('deep', function () {\n    flag(this, 'deep', true);\n  });\n\n  /**\n   * ### .nested\n   *\n   * Enables dot- and bracket-notation in all `.property` and `.include`\n   * assertions that follow in the chain.\n   *\n   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');\n   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});\n   *\n   * If `.` or `[]` are part of an actual property name, they can be escaped by\n   * adding two backslashes before them.\n   *\n   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\\\.a.\\\\[b\\\\]');\n   *     expect({'.a': {'[b]': 'x'}}).to.nested.include({'\\\\.a.\\\\[b\\\\]': 'x'});\n   *\n   * `.nested` cannot be combined with `.own`.\n   *\n   * @name nested\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('nested', function () {\n    flag(this, 'nested', true);\n  });\n\n  /**\n   * ### .own\n   *\n   * Causes all `.property` and `.include` assertions that follow in the chain\n   * to ignore inherited properties.\n   *\n   *     Object.prototype.b = 2;\n   *\n   *     expect({a: 1}).to.have.own.property('a');\n   *     expect({a: 1}).to.have.property('b');\n   *     expect({a: 1}).to.not.have.own.property('b');\n   *\n   *     expect({a: 1}).to.own.include({a: 1});\n   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});\n   *\n   * `.own` cannot be combined with `.nested`.\n   *\n   * @name own\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('own', function () {\n    flag(this, 'own', true);\n  });\n\n  /**\n   * ### .ordered\n   *\n   * Causes all `.members` assertions that follow in the chain to require that\n   * members be in the same order.\n   *\n   *     expect([1, 2]).to.have.ordered.members([1, 2])\n   *       .but.not.have.ordered.members([2, 1]);\n   *\n   * When `.include` and `.ordered` are combined, the ordering begins at the\n   * start of both arrays.\n   *\n   *     expect([1, 2, 3]).to.include.ordered.members([1, 2])\n   *       .but.not.include.ordered.members([2, 3]);\n   *\n   * @name ordered\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('ordered', function () {\n    flag(this, 'ordered', true);\n  });\n\n  /**\n   * ### .any\n   *\n   * Causes all `.keys` assertions that follow in the chain to only require that\n   * the target have at least one of the given keys. This is the opposite of\n   * `.all`, which requires that the target have all of the given keys.\n   *\n   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');\n   *\n   * See the `.keys` doc for guidance on when to use `.any` or `.all`.\n   *\n   * @name any\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('any', function () {\n    flag(this, 'any', true);\n    flag(this, 'all', false);\n  });\n\n  /**\n   * ### .all\n   *\n   * Causes all `.keys` assertions that follow in the chain to require that the\n   * target have all of the given keys. This is the opposite of `.any`, which\n   * only requires that the target have at least one of the given keys.\n   *\n   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');\n   *\n   * Note that `.all` is used by default when neither `.all` nor `.any` are\n   * added earlier in the chain. However, it's often best to add `.all` anyway\n   * because it improves readability.\n   *\n   * See the `.keys` doc for guidance on when to use `.any` or `.all`.\n   *\n   * @name all\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('all', function () {\n    flag(this, 'all', true);\n    flag(this, 'any', false);\n  });\n\n  /**\n   * ### .a(type[, msg])\n   *\n   * Asserts that the target's type is equal to the given string `type`. Types\n   * are case insensitive. See the `type-detect` project page for info on the\n   * type detection algorithm: https://github.com/chaijs/type-detect.\n   *\n   *     expect('foo').to.be.a('string');\n   *     expect({a: 1}).to.be.an('object');\n   *     expect(null).to.be.a('null');\n   *     expect(undefined).to.be.an('undefined');\n   *     expect(new Error).to.be.an('error');\n   *     expect(Promise.resolve()).to.be.a('promise');\n   *     expect(new Float32Array).to.be.a('float32array');\n   *     expect(Symbol()).to.be.a('symbol');\n   *\n   * `.a` supports objects that have a custom type set via `Symbol.toStringTag`.\n   *\n   *     var myObj = {\n   *       [Symbol.toStringTag]: 'myCustomType'\n   *     };\n   *\n   *     expect(myObj).to.be.a('myCustomType').but.not.an('object');\n   *\n   * It's often best to use `.a` to check a target's type before making more\n   * assertions on the same target. That way, you avoid unexpected behavior from\n   * any assertion that does different things based on the target's type.\n   *\n   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);\n   *     expect([]).to.be.an('array').that.is.empty;\n   *\n   * Add `.not` earlier in the chain to negate `.a`. However, it's often best to\n   * assert that the target is the expected type, rather than asserting that it\n   * isn't one of many unexpected types.\n   *\n   *     expect('foo').to.be.a('string'); // Recommended\n   *     expect('foo').to.not.be.an('array'); // Not recommended\n   *\n   * `.a` accepts an optional `msg` argument which is a custom error message to\n   * show when the assertion fails. The message can also be given as the second\n   * argument to `expect`.\n   *\n   *     expect(1).to.be.a('string', 'nooo why fail??');\n   *     expect(1, 'nooo why fail??').to.be.a('string');\n   *\n   * `.a` can also be used as a language chain to improve the readability of\n   * your assertions.\n   *\n   *     expect({b: 2}).to.have.a.property('b');\n   *\n   * The alias `.an` can be used interchangeably with `.a`.\n   *\n   * @name a\n   * @alias an\n   * @param {String} type\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function an (type, msg) {\n    if (msg) flag(this, 'message', msg);\n    type = type.toLowerCase();\n    var obj = flag(this, 'object')\n      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';\n\n    this.assert(\n        type === _.type(obj).toLowerCase()\n      , 'expected #{this} to be ' + article + type\n      , 'expected #{this} not to be ' + article + type\n    );\n  }\n\n  Assertion.addChainableMethod('an', an);\n  Assertion.addChainableMethod('a', an);\n\n  /**\n   * ### .include(val[, msg])\n   *\n   * When the target is a string, `.include` asserts that the given string `val`\n   * is a substring of the target.\n   *\n   *     expect('foobar').to.include('foo');\n   *\n   * When the target is an array, `.include` asserts that the given `val` is a\n   * member of the target.\n   *\n   *     expect([1, 2, 3]).to.include(2);\n   *\n   * When the target is an object, `.include` asserts that the given object\n   * `val`'s properties are a subset of the target's properties.\n   *\n   *     expect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});\n   *\n   * When the target is a Set or WeakSet, `.include` asserts that the given `val` is a\n   * member of the target. SameValueZero equality algorithm is used.\n   *\n   *     expect(new Set([1, 2])).to.include(2);\n   *\n   * When the target is a Map, `.include` asserts that the given `val` is one of\n   * the values of the target. SameValueZero equality algorithm is used.\n   *\n   *     expect(new Map([['a', 1], ['b', 2]])).to.include(2);\n   *\n   * Because `.include` does different things based on the target's type, it's\n   * important to check the target's type before using `.include`. See the `.a`\n   * doc for info on testing a target's type.\n   *\n   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);\n   *\n   * By default, strict (`===`) equality is used to compare array members and\n   * object properties. Add `.deep` earlier in the chain to use deep equality\n   * instead (WeakSet targets are not supported). See the `deep-eql` project\n   * page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.\n   *\n   *     // Target array deeply (but not strictly) includes `{a: 1}`\n   *     expect([{a: 1}]).to.deep.include({a: 1});\n   *     expect([{a: 1}]).to.not.include({a: 1});\n   *\n   *     // Target object deeply (but not strictly) includes `x: {a: 1}`\n   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});\n   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});\n   *\n   * By default, all of the target's properties are searched when working with\n   * objects. This includes properties that are inherited and/or non-enumerable.\n   * Add `.own` earlier in the chain to exclude the target's inherited\n   * properties from the search.\n   *\n   *     Object.prototype.b = 2;\n   *\n   *     expect({a: 1}).to.own.include({a: 1});\n   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});\n   *\n   * Note that a target object is always only searched for `val`'s own\n   * enumerable properties.\n   *\n   * `.deep` and `.own` can be combined.\n   *\n   *     expect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});\n   *\n   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when\n   * referencing nested properties.\n   *\n   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});\n   *\n   * If `.` or `[]` are part of an actual property name, they can be escaped by\n   * adding two backslashes before them.\n   *\n   *     expect({'.a': {'[b]': 2}}).to.nested.include({'\\\\.a.\\\\[b\\\\]': 2});\n   *\n   * `.deep` and `.nested` can be combined.\n   *\n   *     expect({a: {b: [{c: 3}]}}).to.deep.nested.include({'a.b[0]': {c: 3}});\n   *\n   * `.own` and `.nested` cannot be combined.\n   *\n   * Add `.not` earlier in the chain to negate `.include`.\n   *\n   *     expect('foobar').to.not.include('taco');\n   *     expect([1, 2, 3]).to.not.include(4);\n   *\n   * However, it's dangerous to negate `.include` when the target is an object.\n   * The problem is that it creates uncertain expectations by asserting that the\n   * target object doesn't have all of `val`'s key/value pairs but may or may\n   * not have some of them. It's often best to identify the exact output that's\n   * expected, and then write an assertion that only accepts that exact output.\n   *\n   * When the target object isn't even expected to have `val`'s keys, it's\n   * often best to assert exactly that.\n   *\n   *     expect({c: 3}).to.not.have.any.keys('a', 'b'); // Recommended\n   *     expect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended\n   *\n   * When the target object is expected to have `val`'s keys, it's often best to\n   * assert that each of the properties has its expected value, rather than\n   * asserting that each property doesn't have one of many unexpected values.\n   *\n   *     expect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended\n   *     expect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended\n   *\n   * `.include` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect([1, 2, 3]).to.include(4, 'nooo why fail??');\n   *     expect([1, 2, 3], 'nooo why fail??').to.include(4);\n   *\n   * `.include` can also be used as a language chain, causing all `.members` and\n   * `.keys` assertions that follow in the chain to require the target to be a\n   * superset of the expected set, rather than an identical set. Note that\n   * `.members` ignores duplicates in the subset when `.include` is added.\n   *\n   *     // Target object's keys are a superset of ['a', 'b'] but not identical\n   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');\n   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');\n   *\n   *     // Target array is a superset of [1, 2] but not identical\n   *     expect([1, 2, 3]).to.include.members([1, 2]);\n   *     expect([1, 2, 3]).to.not.have.members([1, 2]);\n   *\n   *     // Duplicates in the subset are ignored\n   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);\n   *\n   * Note that adding `.any` earlier in the chain causes the `.keys` assertion\n   * to ignore `.include`.\n   *\n   *     // Both assertions are identical\n   *     expect({a: 1}).to.include.any.keys('a', 'b');\n   *     expect({a: 1}).to.have.any.keys('a', 'b');\n   *\n   * The aliases `.includes`, `.contain`, and `.contains` can be used\n   * interchangeably with `.include`.\n   *\n   * @name include\n   * @alias contain\n   * @alias includes\n   * @alias contains\n   * @param {Mixed} val\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function SameValueZero(a, b) {\n    return (_.isNaN(a) && _.isNaN(b)) || a === b;\n  }\n\n  function includeChainingBehavior () {\n    flag(this, 'contains', true);\n  }\n\n  function include (val, msg) {\n    if (msg) flag(this, 'message', msg);\n\n    var obj = flag(this, 'object')\n      , objType = _.type(obj).toLowerCase()\n      , flagMsg = flag(this, 'message')\n      , negate = flag(this, 'negate')\n      , ssfi = flag(this, 'ssfi')\n      , isDeep = flag(this, 'deep')\n      , descriptor = isDeep ? 'deep ' : '';\n\n    flagMsg = flagMsg ? flagMsg + ': ' : '';\n\n    var included = false;\n\n    switch (objType) {\n      case 'string':\n        included = obj.indexOf(val) !== -1;\n        break;\n\n      case 'weakset':\n        if (isDeep) {\n          throw new AssertionError(\n            flagMsg + 'unable to use .deep.include with WeakSet',\n            undefined,\n            ssfi\n          );\n        }\n\n        included = obj.has(val);\n        break;\n\n      case 'map':\n        var isEql = isDeep ? _.eql : SameValueZero;\n        obj.forEach(function (item) {\n          included = included || isEql(item, val);\n        });\n        break;\n\n      case 'set':\n        if (isDeep) {\n          obj.forEach(function (item) {\n            included = included || _.eql(item, val);\n          });\n        } else {\n          included = obj.has(val);\n        }\n        break;\n\n      case 'array':\n        if (isDeep) {\n          included = obj.some(function (item) {\n            return _.eql(item, val);\n          })\n        } else {\n          included = obj.indexOf(val) !== -1;\n        }\n        break;\n\n      default:\n        // This block is for asserting a subset of properties in an object.\n        // `_.expectTypes` isn't used here because `.include` should work with\n        // objects with a custom `@@toStringTag`.\n        if (val !== Object(val)) {\n          throw new AssertionError(\n            flagMsg + 'object tested must be an array, a map, an object,'\n              + ' a set, a string, or a weakset, but ' + objType + ' given',\n            undefined,\n            ssfi\n          );\n        }\n\n        var props = Object.keys(val)\n          , firstErr = null\n          , numErrs = 0;\n\n        props.forEach(function (prop) {\n          var propAssertion = new Assertion(obj);\n          _.transferFlags(this, propAssertion, true);\n          flag(propAssertion, 'lockSsfi', true);\n\n          if (!negate || props.length === 1) {\n            propAssertion.property(prop, val[prop]);\n            return;\n          }\n\n          try {\n            propAssertion.property(prop, val[prop]);\n          } catch (err) {\n            if (!_.checkError.compatibleConstructor(err, AssertionError)) {\n              throw err;\n            }\n            if (firstErr === null) firstErr = err;\n            numErrs++;\n          }\n        }, this);\n\n        // When validating .not.include with multiple properties, we only want\n        // to throw an assertion error if all of the properties are included,\n        // in which case we throw the first property assertion error that we\n        // encountered.\n        if (negate && props.length > 1 && numErrs === props.length) {\n          throw firstErr;\n        }\n        return;\n    }\n\n    // Assert inclusion in collection or substring in a string.\n    this.assert(\n      included\n      , 'expected #{this} to ' + descriptor + 'include ' + _.inspect(val)\n      , 'expected #{this} to not ' + descriptor + 'include ' + _.inspect(val));\n  }\n\n  Assertion.addChainableMethod('include', include, includeChainingBehavior);\n  Assertion.addChainableMethod('contain', include, includeChainingBehavior);\n  Assertion.addChainableMethod('contains', include, includeChainingBehavior);\n  Assertion.addChainableMethod('includes', include, includeChainingBehavior);\n\n  /**\n   * ### .ok\n   *\n   * Asserts that the target is a truthy value (considered `true` in boolean context).\n   * However, it's often best to assert that the target is strictly (`===`) or\n   * deeply equal to its expected value.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.be.ok; // Not recommended\n   *\n   *     expect(true).to.be.true; // Recommended\n   *     expect(true).to.be.ok; // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.ok`.\n   *\n   *     expect(0).to.equal(0); // Recommended\n   *     expect(0).to.not.be.ok; // Not recommended\n   *\n   *     expect(false).to.be.false; // Recommended\n   *     expect(false).to.not.be.ok; // Not recommended\n   *\n   *     expect(null).to.be.null; // Recommended\n   *     expect(null).to.not.be.ok; // Not recommended\n   *\n   *     expect(undefined).to.be.undefined; // Recommended\n   *     expect(undefined).to.not.be.ok; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect(false, 'nooo why fail??').to.be.ok;\n   *\n   * @name ok\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('ok', function () {\n    this.assert(\n        flag(this, 'object')\n      , 'expected #{this} to be truthy'\n      , 'expected #{this} to be falsy');\n  });\n\n  /**\n   * ### .true\n   *\n   * Asserts that the target is strictly (`===`) equal to `true`.\n   *\n   *     expect(true).to.be.true;\n   *\n   * Add `.not` earlier in the chain to negate `.true`. However, it's often best\n   * to assert that the target is equal to its expected value, rather than not\n   * equal to `true`.\n   *\n   *     expect(false).to.be.false; // Recommended\n   *     expect(false).to.not.be.true; // Not recommended\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.not.be.true; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect(false, 'nooo why fail??').to.be.true;\n   *\n   * @name true\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('true', function () {\n    this.assert(\n        true === flag(this, 'object')\n      , 'expected #{this} to be true'\n      , 'expected #{this} to be false'\n      , flag(this, 'negate') ? false : true\n    );\n  });\n\n  /**\n   * ### .false\n   *\n   * Asserts that the target is strictly (`===`) equal to `false`.\n   *\n   *     expect(false).to.be.false;\n   *\n   * Add `.not` earlier in the chain to negate `.false`. However, it's often\n   * best to assert that the target is equal to its expected value, rather than\n   * not equal to `false`.\n   *\n   *     expect(true).to.be.true; // Recommended\n   *     expect(true).to.not.be.false; // Not recommended\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.not.be.false; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect(true, 'nooo why fail??').to.be.false;\n   *\n   * @name false\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('false', function () {\n    this.assert(\n        false === flag(this, 'object')\n      , 'expected #{this} to be false'\n      , 'expected #{this} to be true'\n      , flag(this, 'negate') ? true : false\n    );\n  });\n\n  /**\n   * ### .null\n   *\n   * Asserts that the target is strictly (`===`) equal to `null`.\n   *\n   *     expect(null).to.be.null;\n   *\n   * Add `.not` earlier in the chain to negate `.null`. However, it's often best\n   * to assert that the target is equal to its expected value, rather than not\n   * equal to `null`.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.not.be.null; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect(42, 'nooo why fail??').to.be.null;\n   *\n   * @name null\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('null', function () {\n    this.assert(\n        null === flag(this, 'object')\n      , 'expected #{this} to be null'\n      , 'expected #{this} not to be null'\n    );\n  });\n\n  /**\n   * ### .undefined\n   *\n   * Asserts that the target is strictly (`===`) equal to `undefined`.\n   *\n   *     expect(undefined).to.be.undefined;\n   *\n   * Add `.not` earlier in the chain to negate `.undefined`. However, it's often\n   * best to assert that the target is equal to its expected value, rather than\n   * not equal to `undefined`.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.not.be.undefined; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect(42, 'nooo why fail??').to.be.undefined;\n   *\n   * @name undefined\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('undefined', function () {\n    this.assert(\n        undefined === flag(this, 'object')\n      , 'expected #{this} to be undefined'\n      , 'expected #{this} not to be undefined'\n    );\n  });\n\n  /**\n   * ### .NaN\n   *\n   * Asserts that the target is exactly `NaN`.\n   *\n   *     expect(NaN).to.be.NaN;\n   *\n   * Add `.not` earlier in the chain to negate `.NaN`. However, it's often best\n   * to assert that the target is equal to its expected value, rather than not\n   * equal to `NaN`.\n   *\n   *     expect('foo').to.equal('foo'); // Recommended\n   *     expect('foo').to.not.be.NaN; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect(42, 'nooo why fail??').to.be.NaN;\n   *\n   * @name NaN\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('NaN', function () {\n    this.assert(\n        _.isNaN(flag(this, 'object'))\n        , 'expected #{this} to be NaN'\n        , 'expected #{this} not to be NaN'\n    );\n  });\n\n  /**\n   * ### .exist\n   *\n   * Asserts that the target is not strictly (`===`) equal to either `null` or\n   * `undefined`. However, it's often best to assert that the target is equal to\n   * its expected value.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.exist; // Not recommended\n   *\n   *     expect(0).to.equal(0); // Recommended\n   *     expect(0).to.exist; // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.exist`.\n   *\n   *     expect(null).to.be.null; // Recommended\n   *     expect(null).to.not.exist; // Not recommended\n   *\n   *     expect(undefined).to.be.undefined; // Recommended\n   *     expect(undefined).to.not.exist; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect(null, 'nooo why fail??').to.exist;\n   *\n   * @name exist\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('exist', function () {\n    var val = flag(this, 'object');\n    this.assert(\n        val !== null && val !== undefined\n      , 'expected #{this} to exist'\n      , 'expected #{this} to not exist'\n    );\n  });\n\n  /**\n   * ### .empty\n   *\n   * When the target is a string or array, `.empty` asserts that the target's\n   * `length` property is strictly (`===`) equal to `0`.\n   *\n   *     expect([]).to.be.empty;\n   *     expect('').to.be.empty;\n   *\n   * When the target is a map or set, `.empty` asserts that the target's `size`\n   * property is strictly equal to `0`.\n   *\n   *     expect(new Set()).to.be.empty;\n   *     expect(new Map()).to.be.empty;\n   *\n   * When the target is a non-function object, `.empty` asserts that the target\n   * doesn't have any own enumerable properties. Properties with Symbol-based\n   * keys are excluded from the count.\n   *\n   *     expect({}).to.be.empty;\n   *\n   * Because `.empty` does different things based on the target's type, it's\n   * important to check the target's type before using `.empty`. See the `.a`\n   * doc for info on testing a target's type.\n   *\n   *     expect([]).to.be.an('array').that.is.empty;\n   *\n   * Add `.not` earlier in the chain to negate `.empty`. However, it's often\n   * best to assert that the target contains its expected number of values,\n   * rather than asserting that it's not empty.\n   *\n   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n   *     expect([1, 2, 3]).to.not.be.empty; // Not recommended\n   *\n   *     expect(new Set([1, 2, 3])).to.have.property('size', 3); // Recommended\n   *     expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended\n   *\n   *     expect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended\n   *     expect({a: 1}).to.not.be.empty; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect([1, 2, 3], 'nooo why fail??').to.be.empty;\n   *\n   * @name empty\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('empty', function () {\n    var val = flag(this, 'object')\n      , ssfi = flag(this, 'ssfi')\n      , flagMsg = flag(this, 'message')\n      , itemsCount;\n\n    flagMsg = flagMsg ? flagMsg + ': ' : '';\n\n    switch (_.type(val).toLowerCase()) {\n      case 'array':\n      case 'string':\n        itemsCount = val.length;\n        break;\n      case 'map':\n      case 'set':\n        itemsCount = val.size;\n        break;\n      case 'weakmap':\n      case 'weakset':\n        throw new AssertionError(\n          flagMsg + '.empty was passed a weak collection',\n          undefined,\n          ssfi\n        );\n      case 'function':\n        var msg = flagMsg + '.empty was passed a function ' + _.getName(val);\n        throw new AssertionError(msg.trim(), undefined, ssfi);\n      default:\n        if (val !== Object(val)) {\n          throw new AssertionError(\n            flagMsg + '.empty was passed non-string primitive ' + _.inspect(val),\n            undefined,\n            ssfi\n          );\n        }\n        itemsCount = Object.keys(val).length;\n    }\n\n    this.assert(\n        0 === itemsCount\n      , 'expected #{this} to be empty'\n      , 'expected #{this} not to be empty'\n    );\n  });\n\n  /**\n   * ### .arguments\n   *\n   * Asserts that the target is an `arguments` object.\n   *\n   *     function test () {\n   *       expect(arguments).to.be.arguments;\n   *     }\n   *\n   *     test();\n   *\n   * Add `.not` earlier in the chain to negate `.arguments`. However, it's often\n   * best to assert which type the target is expected to be, rather than\n   * asserting that its not an `arguments` object.\n   *\n   *     expect('foo').to.be.a('string'); // Recommended\n   *     expect('foo').to.not.be.arguments; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect({}, 'nooo why fail??').to.be.arguments;\n   *\n   * The alias `.Arguments` can be used interchangeably with `.arguments`.\n   *\n   * @name arguments\n   * @alias Arguments\n   * @namespace BDD\n   * @api public\n   */\n\n  function checkArguments () {\n    var obj = flag(this, 'object')\n      , type = _.type(obj);\n    this.assert(\n        'Arguments' === type\n      , 'expected #{this} to be arguments but got ' + type\n      , 'expected #{this} to not be arguments'\n    );\n  }\n\n  Assertion.addProperty('arguments', checkArguments);\n  Assertion.addProperty('Arguments', checkArguments);\n\n  /**\n   * ### .equal(val[, msg])\n   *\n   * Asserts that the target is strictly (`===`) equal to the given `val`.\n   *\n   *     expect(1).to.equal(1);\n   *     expect('foo').to.equal('foo');\n   *\n   * Add `.deep` earlier in the chain to use deep equality instead. See the\n   * `deep-eql` project page for info on the deep equality algorithm:\n   * https://github.com/chaijs/deep-eql.\n   *\n   *     // Target object deeply (but not strictly) equals `{a: 1}`\n   *     expect({a: 1}).to.deep.equal({a: 1});\n   *     expect({a: 1}).to.not.equal({a: 1});\n   *\n   *     // Target array deeply (but not strictly) equals `[1, 2]`\n   *     expect([1, 2]).to.deep.equal([1, 2]);\n   *     expect([1, 2]).to.not.equal([1, 2]);\n   *\n   * Add `.not` earlier in the chain to negate `.equal`. However, it's often\n   * best to assert that the target is equal to its expected value, rather than\n   * not equal to one of countless unexpected values.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.not.equal(2); // Not recommended\n   *\n   * `.equal` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`.\n   *\n   *     expect(1).to.equal(2, 'nooo why fail??');\n   *     expect(1, 'nooo why fail??').to.equal(2);\n   *\n   * The aliases `.equals` and `eq` can be used interchangeably with `.equal`.\n   *\n   * @name equal\n   * @alias equals\n   * @alias eq\n   * @param {Mixed} val\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertEqual (val, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'deep')) {\n      var prevLockSsfi = flag(this, 'lockSsfi');\n      flag(this, 'lockSsfi', true);\n      this.eql(val);\n      flag(this, 'lockSsfi', prevLockSsfi);\n    } else {\n      this.assert(\n          val === obj\n        , 'expected #{this} to equal #{exp}'\n        , 'expected #{this} to not equal #{exp}'\n        , val\n        , this._obj\n        , true\n      );\n    }\n  }\n\n  Assertion.addMethod('equal', assertEqual);\n  Assertion.addMethod('equals', assertEqual);\n  Assertion.addMethod('eq', assertEqual);\n\n  /**\n   * ### .eql(obj[, msg])\n   *\n   * Asserts that the target is deeply equal to the given `obj`. See the\n   * `deep-eql` project page for info on the deep equality algorithm:\n   * https://github.com/chaijs/deep-eql.\n   *\n   *     // Target object is deeply (but not strictly) equal to {a: 1}\n   *     expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});\n   *\n   *     // Target array is deeply (but not strictly) equal to [1, 2]\n   *     expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);\n   *\n   * Add `.not` earlier in the chain to negate `.eql`. However, it's often best\n   * to assert that the target is deeply equal to its expected value, rather\n   * than not deeply equal to one of countless unexpected values.\n   *\n   *     expect({a: 1}).to.eql({a: 1}); // Recommended\n   *     expect({a: 1}).to.not.eql({b: 2}); // Not recommended\n   *\n   * `.eql` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`.\n   *\n   *     expect({a: 1}).to.eql({b: 2}, 'nooo why fail??');\n   *     expect({a: 1}, 'nooo why fail??').to.eql({b: 2});\n   *\n   * The alias `.eqls` can be used interchangeably with `.eql`.\n   *\n   * The `.deep.equal` assertion is almost identical to `.eql` but with one\n   * difference: `.deep.equal` causes deep equality comparisons to also be used\n   * for any other assertions that follow in the chain.\n   *\n   * @name eql\n   * @alias eqls\n   * @param {Mixed} obj\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertEql(obj, msg) {\n    if (msg) flag(this, 'message', msg);\n    this.assert(\n        _.eql(obj, flag(this, 'object'))\n      , 'expected #{this} to deeply equal #{exp}'\n      , 'expected #{this} to not deeply equal #{exp}'\n      , obj\n      , this._obj\n      , true\n    );\n  }\n\n  Assertion.addMethod('eql', assertEql);\n  Assertion.addMethod('eqls', assertEql);\n\n  /**\n   * ### .above(n[, msg])\n   *\n   * Asserts that the target is a number or a date greater than the given number or date `n` respectively.\n   * However, it's often best to assert that the target is equal to its expected\n   * value.\n   *\n   *     expect(2).to.equal(2); // Recommended\n   *     expect(2).to.be.above(1); // Not recommended\n   *\n   * Add `.lengthOf` earlier in the chain to assert that the target's `length`\n   * or `size` is greater than the given number `n`.\n   *\n   *     expect('foo').to.have.lengthOf(3); // Recommended\n   *     expect('foo').to.have.lengthOf.above(2); // Not recommended\n   *\n   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n   *     expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.above`.\n   *\n   *     expect(2).to.equal(2); // Recommended\n   *     expect(1).to.not.be.above(2); // Not recommended\n   *\n   * `.above` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`.\n   *\n   *     expect(1).to.be.above(2, 'nooo why fail??');\n   *     expect(1, 'nooo why fail??').to.be.above(2);\n   *\n   * The aliases `.gt` and `.greaterThan` can be used interchangeably with\n   * `.above`.\n   *\n   * @name above\n   * @alias gt\n   * @alias greaterThan\n   * @param {Number} n\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertAbove (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , doLength = flag(this, 'doLength')\n      , flagMsg = flag(this, 'message')\n      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\n      , ssfi = flag(this, 'ssfi')\n      , objType = _.type(obj).toLowerCase()\n      , nType = _.type(n).toLowerCase()\n      , errorMessage\n      , shouldThrow = true;\n\n    if (doLength && objType !== 'map' && objType !== 'set') {\n      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\n    }\n\n    if (!doLength && (objType === 'date' && nType !== 'date')) {\n      errorMessage = msgPrefix + 'the argument to above must be a date';\n    } else if (nType !== 'number' && (doLength || objType === 'number')) {\n      errorMessage = msgPrefix + 'the argument to above must be a number';\n    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\n      var printObj = (objType === 'string') ? \"'\" + obj + \"'\" : obj;\n      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\n    } else {\n      shouldThrow = false;\n    }\n\n    if (shouldThrow) {\n      throw new AssertionError(errorMessage, undefined, ssfi);\n    }\n\n    if (doLength) {\n      var descriptor = 'length'\n        , itemsCount;\n      if (objType === 'map' || objType === 'set') {\n        descriptor = 'size';\n        itemsCount = obj.size;\n      } else {\n        itemsCount = obj.length;\n      }\n      this.assert(\n          itemsCount > n\n        , 'expected #{this} to have a ' + descriptor + ' above #{exp} but got #{act}'\n        , 'expected #{this} to not have a ' + descriptor + ' above #{exp}'\n        , n\n        , itemsCount\n      );\n    } else {\n      this.assert(\n          obj > n\n        , 'expected #{this} to be above #{exp}'\n        , 'expected #{this} to be at most #{exp}'\n        , n\n      );\n    }\n  }\n\n  Assertion.addMethod('above', assertAbove);\n  Assertion.addMethod('gt', assertAbove);\n  Assertion.addMethod('greaterThan', assertAbove);\n\n  /**\n   * ### .least(n[, msg])\n   *\n   * Asserts that the target is a number or a date greater than or equal to the given\n   * number or date `n` respectively. However, it's often best to assert that the target is equal to\n   * its expected value.\n   *\n   *     expect(2).to.equal(2); // Recommended\n   *     expect(2).to.be.at.least(1); // Not recommended\n   *     expect(2).to.be.at.least(2); // Not recommended\n   *\n   * Add `.lengthOf` earlier in the chain to assert that the target's `length`\n   * or `size` is greater than or equal to the given number `n`.\n   *\n   *     expect('foo').to.have.lengthOf(3); // Recommended\n   *     expect('foo').to.have.lengthOf.at.least(2); // Not recommended\n   *\n   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n   *     expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.least`.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.not.be.at.least(2); // Not recommended\n   *\n   * `.least` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`.\n   *\n   *     expect(1).to.be.at.least(2, 'nooo why fail??');\n   *     expect(1, 'nooo why fail??').to.be.at.least(2);\n   *\n   * The alias `.gte` can be used interchangeably with `.least`.\n   *\n   * @name least\n   * @alias gte\n   * @param {Number} n\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertLeast (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , doLength = flag(this, 'doLength')\n      , flagMsg = flag(this, 'message')\n      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\n      , ssfi = flag(this, 'ssfi')\n      , objType = _.type(obj).toLowerCase()\n      , nType = _.type(n).toLowerCase()\n      , errorMessage\n      , shouldThrow = true;\n\n    if (doLength && objType !== 'map' && objType !== 'set') {\n      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\n    }\n\n    if (!doLength && (objType === 'date' && nType !== 'date')) {\n      errorMessage = msgPrefix + 'the argument to least must be a date';\n    } else if (nType !== 'number' && (doLength || objType === 'number')) {\n      errorMessage = msgPrefix + 'the argument to least must be a number';\n    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\n      var printObj = (objType === 'string') ? \"'\" + obj + \"'\" : obj;\n      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\n    } else {\n      shouldThrow = false;\n    }\n\n    if (shouldThrow) {\n      throw new AssertionError(errorMessage, undefined, ssfi);\n    }\n\n    if (doLength) {\n      var descriptor = 'length'\n        , itemsCount;\n      if (objType === 'map' || objType === 'set') {\n        descriptor = 'size';\n        itemsCount = obj.size;\n      } else {\n        itemsCount = obj.length;\n      }\n      this.assert(\n          itemsCount >= n\n        , 'expected #{this} to have a ' + descriptor + ' at least #{exp} but got #{act}'\n        , 'expected #{this} to have a ' + descriptor + ' below #{exp}'\n        , n\n        , itemsCount\n      );\n    } else {\n      this.assert(\n          obj >= n\n        , 'expected #{this} to be at least #{exp}'\n        , 'expected #{this} to be below #{exp}'\n        , n\n      );\n    }\n  }\n\n  Assertion.addMethod('least', assertLeast);\n  Assertion.addMethod('gte', assertLeast);\n\n  /**\n   * ### .below(n[, msg])\n   *\n   * Asserts that the target is a number or a date less than the given number or date `n` respectively.\n   * However, it's often best to assert that the target is equal to its expected\n   * value.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.be.below(2); // Not recommended\n   *\n   * Add `.lengthOf` earlier in the chain to assert that the target's `length`\n   * or `size` is less than the given number `n`.\n   *\n   *     expect('foo').to.have.lengthOf(3); // Recommended\n   *     expect('foo').to.have.lengthOf.below(4); // Not recommended\n   *\n   *     expect([1, 2, 3]).to.have.length(3); // Recommended\n   *     expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.below`.\n   *\n   *     expect(2).to.equal(2); // Recommended\n   *     expect(2).to.not.be.below(1); // Not recommended\n   *\n   * `.below` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`.\n   *\n   *     expect(2).to.be.below(1, 'nooo why fail??');\n   *     expect(2, 'nooo why fail??').to.be.below(1);\n   *\n   * The aliases `.lt` and `.lessThan` can be used interchangeably with\n   * `.below`.\n   *\n   * @name below\n   * @alias lt\n   * @alias lessThan\n   * @param {Number} n\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertBelow (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , doLength = flag(this, 'doLength')\n      , flagMsg = flag(this, 'message')\n      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\n      , ssfi = flag(this, 'ssfi')\n      , objType = _.type(obj).toLowerCase()\n      , nType = _.type(n).toLowerCase()\n      , errorMessage\n      , shouldThrow = true;\n\n    if (doLength && objType !== 'map' && objType !== 'set') {\n      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\n    }\n\n    if (!doLength && (objType === 'date' && nType !== 'date')) {\n      errorMessage = msgPrefix + 'the argument to below must be a date';\n    } else if (nType !== 'number' && (doLength || objType === 'number')) {\n      errorMessage = msgPrefix + 'the argument to below must be a number';\n    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\n      var printObj = (objType === 'string') ? \"'\" + obj + \"'\" : obj;\n      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\n    } else {\n      shouldThrow = false;\n    }\n\n    if (shouldThrow) {\n      throw new AssertionError(errorMessage, undefined, ssfi);\n    }\n\n    if (doLength) {\n      var descriptor = 'length'\n        , itemsCount;\n      if (objType === 'map' || objType === 'set') {\n        descriptor = 'size';\n        itemsCount = obj.size;\n      } else {\n        itemsCount = obj.length;\n      }\n      this.assert(\n          itemsCount < n\n        , 'expected #{this} to have a ' + descriptor + ' below #{exp} but got #{act}'\n        , 'expected #{this} to not have a ' + descriptor + ' below #{exp}'\n        , n\n        , itemsCount\n      );\n    } else {\n      this.assert(\n          obj < n\n        , 'expected #{this} to be below #{exp}'\n        , 'expected #{this} to be at least #{exp}'\n        , n\n      );\n    }\n  }\n\n  Assertion.addMethod('below', assertBelow);\n  Assertion.addMethod('lt', assertBelow);\n  Assertion.addMethod('lessThan', assertBelow);\n\n  /**\n   * ### .most(n[, msg])\n   *\n   * Asserts that the target is a number or a date less than or equal to the given number\n   * or date `n` respectively. However, it's often best to assert that the target is equal to its\n   * expected value.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.be.at.most(2); // Not recommended\n   *     expect(1).to.be.at.most(1); // Not recommended\n   *\n   * Add `.lengthOf` earlier in the chain to assert that the target's `length`\n   * or `size` is less than or equal to the given number `n`.\n   *\n   *     expect('foo').to.have.lengthOf(3); // Recommended\n   *     expect('foo').to.have.lengthOf.at.most(4); // Not recommended\n   *\n   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n   *     expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.most`.\n   *\n   *     expect(2).to.equal(2); // Recommended\n   *     expect(2).to.not.be.at.most(1); // Not recommended\n   *\n   * `.most` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`.\n   *\n   *     expect(2).to.be.at.most(1, 'nooo why fail??');\n   *     expect(2, 'nooo why fail??').to.be.at.most(1);\n   *\n   * The alias `.lte` can be used interchangeably with `.most`.\n   *\n   * @name most\n   * @alias lte\n   * @param {Number} n\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertMost (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , doLength = flag(this, 'doLength')\n      , flagMsg = flag(this, 'message')\n      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\n      , ssfi = flag(this, 'ssfi')\n      , objType = _.type(obj).toLowerCase()\n      , nType = _.type(n).toLowerCase()\n      , errorMessage\n      , shouldThrow = true;\n\n    if (doLength && objType !== 'map' && objType !== 'set') {\n      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\n    }\n\n    if (!doLength && (objType === 'date' && nType !== 'date')) {\n      errorMessage = msgPrefix + 'the argument to most must be a date';\n    } else if (nType !== 'number' && (doLength || objType === 'number')) {\n      errorMessage = msgPrefix + 'the argument to most must be a number';\n    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\n      var printObj = (objType === 'string') ? \"'\" + obj + \"'\" : obj;\n      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\n    } else {\n      shouldThrow = false;\n    }\n\n    if (shouldThrow) {\n      throw new AssertionError(errorMessage, undefined, ssfi);\n    }\n\n    if (doLength) {\n      var descriptor = 'length'\n        , itemsCount;\n      if (objType === 'map' || objType === 'set') {\n        descriptor = 'size';\n        itemsCount = obj.size;\n      } else {\n        itemsCount = obj.length;\n      }\n      this.assert(\n          itemsCount <= n\n        , 'expected #{this} to have a ' + descriptor + ' at most #{exp} but got #{act}'\n        , 'expected #{this} to have a ' + descriptor + ' above #{exp}'\n        , n\n        , itemsCount\n      );\n    } else {\n      this.assert(\n          obj <= n\n        , 'expected #{this} to be at most #{exp}'\n        , 'expected #{this} to be above #{exp}'\n        , n\n      );\n    }\n  }\n\n  Assertion.addMethod('most', assertMost);\n  Assertion.addMethod('lte', assertMost);\n\n  /**\n   * ### .within(start, finish[, msg])\n   *\n   * Asserts that the target is a number or a date greater than or equal to the given\n   * number or date `start`, and less than or equal to the given number or date `finish` respectively.\n   * However, it's often best to assert that the target is equal to its expected\n   * value.\n   *\n   *     expect(2).to.equal(2); // Recommended\n   *     expect(2).to.be.within(1, 3); // Not recommended\n   *     expect(2).to.be.within(2, 3); // Not recommended\n   *     expect(2).to.be.within(1, 2); // Not recommended\n   *\n   * Add `.lengthOf` earlier in the chain to assert that the target's `length`\n   * or `size` is greater than or equal to the given number `start`, and less\n   * than or equal to the given number `finish`.\n   *\n   *     expect('foo').to.have.lengthOf(3); // Recommended\n   *     expect('foo').to.have.lengthOf.within(2, 4); // Not recommended\n   *\n   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n   *     expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.within`.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.not.be.within(2, 4); // Not recommended\n   *\n   * `.within` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect(4).to.be.within(1, 3, 'nooo why fail??');\n   *     expect(4, 'nooo why fail??').to.be.within(1, 3);\n   *\n   * @name within\n   * @param {Number} start lower bound inclusive\n   * @param {Number} finish upper bound inclusive\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addMethod('within', function (start, finish, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , doLength = flag(this, 'doLength')\n      , flagMsg = flag(this, 'message')\n      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\n      , ssfi = flag(this, 'ssfi')\n      , objType = _.type(obj).toLowerCase()\n      , startType = _.type(start).toLowerCase()\n      , finishType = _.type(finish).toLowerCase()\n      , errorMessage\n      , shouldThrow = true\n      , range = (startType === 'date' && finishType === 'date')\n          ? start.toUTCString() + '..' + finish.toUTCString()\n          : start + '..' + finish;\n\n    if (doLength && objType !== 'map' && objType !== 'set') {\n      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\n    }\n\n    if (!doLength && (objType === 'date' && (startType !== 'date' || finishType !== 'date'))) {\n      errorMessage = msgPrefix + 'the arguments to within must be dates';\n    } else if ((startType !== 'number' || finishType !== 'number') && (doLength || objType === 'number')) {\n      errorMessage = msgPrefix + 'the arguments to within must be numbers';\n    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\n      var printObj = (objType === 'string') ? \"'\" + obj + \"'\" : obj;\n      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\n    } else {\n      shouldThrow = false;\n    }\n\n    if (shouldThrow) {\n      throw new AssertionError(errorMessage, undefined, ssfi);\n    }\n\n    if (doLength) {\n      var descriptor = 'length'\n        , itemsCount;\n      if (objType === 'map' || objType === 'set') {\n        descriptor = 'size';\n        itemsCount = obj.size;\n      } else {\n        itemsCount = obj.length;\n      }\n      this.assert(\n          itemsCount >= start && itemsCount <= finish\n        , 'expected #{this} to have a ' + descriptor + ' within ' + range\n        , 'expected #{this} to not have a ' + descriptor + ' within ' + range\n      );\n    } else {\n      this.assert(\n          obj >= start && obj <= finish\n        , 'expected #{this} to be within ' + range\n        , 'expected #{this} to not be within ' + range\n      );\n    }\n  });\n\n  /**\n   * ### .instanceof(constructor[, msg])\n   *\n   * Asserts that the target is an instance of the given `constructor`.\n   *\n   *     function Cat () { }\n   *\n   *     expect(new Cat()).to.be.an.instanceof(Cat);\n   *     expect([1, 2]).to.be.an.instanceof(Array);\n   *\n   * Add `.not` earlier in the chain to negate `.instanceof`.\n   *\n   *     expect({a: 1}).to.not.be.an.instanceof(Array);\n   *\n   * `.instanceof` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect(1).to.be.an.instanceof(Array, 'nooo why fail??');\n   *     expect(1, 'nooo why fail??').to.be.an.instanceof(Array);\n   *\n   * Due to limitations in ES5, `.instanceof` may not always work as expected\n   * when using a transpiler such as Babel or TypeScript. In particular, it may\n   * produce unexpected results when subclassing built-in object such as\n   * `Array`, `Error`, and `Map`. See your transpiler's docs for details:\n   *\n   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))\n   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))\n   *\n   * The alias `.instanceOf` can be used interchangeably with `.instanceof`.\n   *\n   * @name instanceof\n   * @param {Constructor} constructor\n   * @param {String} msg _optional_\n   * @alias instanceOf\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertInstanceOf (constructor, msg) {\n    if (msg) flag(this, 'message', msg);\n\n    var target = flag(this, 'object')\n    var ssfi = flag(this, 'ssfi');\n    var flagMsg = flag(this, 'message');\n\n    try {\n      var isInstanceOf = target instanceof constructor;\n    } catch (err) {\n      if (err instanceof TypeError) {\n        flagMsg = flagMsg ? flagMsg + ': ' : '';\n        throw new AssertionError(\n          flagMsg + 'The instanceof assertion needs a constructor but '\n            + _.type(constructor) + ' was given.',\n          undefined,\n          ssfi\n        );\n      }\n      throw err;\n    }\n\n    var name = _.getName(constructor);\n    if (name === null) {\n      name = 'an unnamed constructor';\n    }\n\n    this.assert(\n        isInstanceOf\n      , 'expected #{this} to be an instance of ' + name\n      , 'expected #{this} to not be an instance of ' + name\n    );\n  };\n\n  Assertion.addMethod('instanceof', assertInstanceOf);\n  Assertion.addMethod('instanceOf', assertInstanceOf);\n\n  /**\n   * ### .property(name[, val[, msg]])\n   *\n   * Asserts that the target has a property with the given key `name`.\n   *\n   *     expect({a: 1}).to.have.property('a');\n   *\n   * When `val` is provided, `.property` also asserts that the property's value\n   * is equal to the given `val`.\n   *\n   *     expect({a: 1}).to.have.property('a', 1);\n   *\n   * By default, strict (`===`) equality is used. Add `.deep` earlier in the\n   * chain to use deep equality instead. See the `deep-eql` project page for\n   * info on the deep equality algorithm: https://github.com/chaijs/deep-eql.\n   *\n   *     // Target object deeply (but not strictly) has property `x: {a: 1}`\n   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});\n   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});\n   *\n   * The target's enumerable and non-enumerable properties are always included\n   * in the search. By default, both own and inherited properties are included.\n   * Add `.own` earlier in the chain to exclude inherited properties from the\n   * search.\n   *\n   *     Object.prototype.b = 2;\n   *\n   *     expect({a: 1}).to.have.own.property('a');\n   *     expect({a: 1}).to.have.own.property('a', 1);\n   *     expect({a: 1}).to.have.property('b');\n   *     expect({a: 1}).to.not.have.own.property('b');\n   *\n   * `.deep` and `.own` can be combined.\n   *\n   *     expect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});\n   *\n   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when\n   * referencing nested properties.\n   *\n   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');\n   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');\n   *\n   * If `.` or `[]` are part of an actual property name, they can be escaped by\n   * adding two backslashes before them.\n   *\n   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\\\.a.\\\\[b\\\\]');\n   *\n   * `.deep` and `.nested` can be combined.\n   *\n   *     expect({a: {b: [{c: 3}]}})\n   *       .to.have.deep.nested.property('a.b[0]', {c: 3});\n   *\n   * `.own` and `.nested` cannot be combined.\n   *\n   * Add `.not` earlier in the chain to negate `.property`.\n   *\n   *     expect({a: 1}).to.not.have.property('b');\n   *\n   * However, it's dangerous to negate `.property` when providing `val`. The\n   * problem is that it creates uncertain expectations by asserting that the\n   * target either doesn't have a property with the given key `name`, or that it\n   * does have a property with the given key `name` but its value isn't equal to\n   * the given `val`. It's often best to identify the exact output that's\n   * expected, and then write an assertion that only accepts that exact output.\n   *\n   * When the target isn't expected to have a property with the given key\n   * `name`, it's often best to assert exactly that.\n   *\n   *     expect({b: 2}).to.not.have.property('a'); // Recommended\n   *     expect({b: 2}).to.not.have.property('a', 1); // Not recommended\n   *\n   * When the target is expected to have a property with the given key `name`,\n   * it's often best to assert that the property has its expected value, rather\n   * than asserting that it doesn't have one of many unexpected values.\n   *\n   *     expect({a: 3}).to.have.property('a', 3); // Recommended\n   *     expect({a: 3}).to.not.have.property('a', 1); // Not recommended\n   *\n   * `.property` changes the target of any assertions that follow in the chain\n   * to be the value of the property from the original target object.\n   *\n   *     expect({a: 1}).to.have.property('a').that.is.a('number');\n   *\n   * `.property` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`. When not providing `val`, only use the\n   * second form.\n   *\n   *     // Recommended\n   *     expect({a: 1}).to.have.property('a', 2, 'nooo why fail??');\n   *     expect({a: 1}, 'nooo why fail??').to.have.property('a', 2);\n   *     expect({a: 1}, 'nooo why fail??').to.have.property('b');\n   *\n   *     // Not recommended\n   *     expect({a: 1}).to.have.property('b', undefined, 'nooo why fail??');\n   *\n   * The above assertion isn't the same thing as not providing `val`. Instead,\n   * it's asserting that the target object has a `b` property that's equal to\n   * `undefined`.\n   *\n   * The assertions `.ownProperty` and `.haveOwnProperty` can be used\n   * interchangeably with `.own.property`.\n   *\n   * @name property\n   * @param {String} name\n   * @param {Mixed} val (optional)\n   * @param {String} msg _optional_\n   * @returns value of property for chaining\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertProperty (name, val, msg) {\n    if (msg) flag(this, 'message', msg);\n\n    var isNested = flag(this, 'nested')\n      , isOwn = flag(this, 'own')\n      , flagMsg = flag(this, 'message')\n      , obj = flag(this, 'object')\n      , ssfi = flag(this, 'ssfi')\n      , nameType = typeof name;\n\n    flagMsg = flagMsg ? flagMsg + ': ' : '';\n\n    if (isNested) {\n      if (nameType !== 'string') {\n        throw new AssertionError(\n          flagMsg + 'the argument to property must be a string when using nested syntax',\n          undefined,\n          ssfi\n        );\n      }\n    } else {\n      if (nameType !== 'string' && nameType !== 'number' && nameType !== 'symbol') {\n        throw new AssertionError(\n          flagMsg + 'the argument to property must be a string, number, or symbol',\n          undefined,\n          ssfi\n        );\n      }\n    }\n\n    if (isNested && isOwn) {\n      throw new AssertionError(\n        flagMsg + 'The \"nested\" and \"own\" flags cannot be combined.',\n        undefined,\n        ssfi\n      );\n    }\n\n    if (obj === null || obj === undefined) {\n      throw new AssertionError(\n        flagMsg + 'Target cannot be null or undefined.',\n        undefined,\n        ssfi\n      );\n    }\n\n    var isDeep = flag(this, 'deep')\n      , negate = flag(this, 'negate')\n      , pathInfo = isNested ? _.getPathInfo(obj, name) : null\n      , value = isNested ? pathInfo.value : obj[name];\n\n    var descriptor = '';\n    if (isDeep) descriptor += 'deep ';\n    if (isOwn) descriptor += 'own ';\n    if (isNested) descriptor += 'nested ';\n    descriptor += 'property ';\n\n    var hasProperty;\n    if (isOwn) hasProperty = Object.prototype.hasOwnProperty.call(obj, name);\n    else if (isNested) hasProperty = pathInfo.exists;\n    else hasProperty = _.hasProperty(obj, name);\n\n    // When performing a negated assertion for both name and val, merely having\n    // a property with the given name isn't enough to cause the assertion to\n    // fail. It must both have a property with the given name, and the value of\n    // that property must equal the given val. Therefore, skip this assertion in\n    // favor of the next.\n    if (!negate || arguments.length === 1) {\n      this.assert(\n          hasProperty\n        , 'expected #{this} to have ' + descriptor + _.inspect(name)\n        , 'expected #{this} to not have ' + descriptor + _.inspect(name));\n    }\n\n    if (arguments.length > 1) {\n      this.assert(\n          hasProperty && (isDeep ? _.eql(val, value) : val === value)\n        , 'expected #{this} to have ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'\n        , 'expected #{this} to not have ' + descriptor + _.inspect(name) + ' of #{act}'\n        , val\n        , value\n      );\n    }\n\n    flag(this, 'object', value);\n  }\n\n  Assertion.addMethod('property', assertProperty);\n\n  function assertOwnProperty (name, value, msg) {\n    flag(this, 'own', true);\n    assertProperty.apply(this, arguments);\n  }\n\n  Assertion.addMethod('ownProperty', assertOwnProperty);\n  Assertion.addMethod('haveOwnProperty', assertOwnProperty);\n\n  /**\n   * ### .ownPropertyDescriptor(name[, descriptor[, msg]])\n   *\n   * Asserts that the target has its own property descriptor with the given key\n   * `name`. Enumerable and non-enumerable properties are included in the\n   * search.\n   *\n   *     expect({a: 1}).to.have.ownPropertyDescriptor('a');\n   *\n   * When `descriptor` is provided, `.ownPropertyDescriptor` also asserts that\n   * the property's descriptor is deeply equal to the given `descriptor`. See\n   * the `deep-eql` project page for info on the deep equality algorithm:\n   * https://github.com/chaijs/deep-eql.\n   *\n   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {\n   *       configurable: true,\n   *       enumerable: true,\n   *       writable: true,\n   *       value: 1,\n   *     });\n   *\n   * Add `.not` earlier in the chain to negate `.ownPropertyDescriptor`.\n   *\n   *     expect({a: 1}).to.not.have.ownPropertyDescriptor('b');\n   *\n   * However, it's dangerous to negate `.ownPropertyDescriptor` when providing\n   * a `descriptor`. The problem is that it creates uncertain expectations by\n   * asserting that the target either doesn't have a property descriptor with\n   * the given key `name`, or that it does have a property descriptor with the\n   * given key `name` but its not deeply equal to the given `descriptor`. It's\n   * often best to identify the exact output that's expected, and then write an\n   * assertion that only accepts that exact output.\n   *\n   * When the target isn't expected to have a property descriptor with the given\n   * key `name`, it's often best to assert exactly that.\n   *\n   *     // Recommended\n   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a');\n   *\n   *     // Not recommended\n   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a', {\n   *       configurable: true,\n   *       enumerable: true,\n   *       writable: true,\n   *       value: 1,\n   *     });\n   *\n   * When the target is expected to have a property descriptor with the given\n   * key `name`, it's often best to assert that the property has its expected\n   * descriptor, rather than asserting that it doesn't have one of many\n   * unexpected descriptors.\n   *\n   *     // Recommended\n   *     expect({a: 3}).to.have.ownPropertyDescriptor('a', {\n   *       configurable: true,\n   *       enumerable: true,\n   *       writable: true,\n   *       value: 3,\n   *     });\n   *\n   *     // Not recommended\n   *     expect({a: 3}).to.not.have.ownPropertyDescriptor('a', {\n   *       configurable: true,\n   *       enumerable: true,\n   *       writable: true,\n   *       value: 1,\n   *     });\n   *\n   * `.ownPropertyDescriptor` changes the target of any assertions that follow\n   * in the chain to be the value of the property descriptor from the original\n   * target object.\n   *\n   *     expect({a: 1}).to.have.ownPropertyDescriptor('a')\n   *       .that.has.property('enumerable', true);\n   *\n   * `.ownPropertyDescriptor` accepts an optional `msg` argument which is a\n   * custom error message to show when the assertion fails. The message can also\n   * be given as the second argument to `expect`. When not providing\n   * `descriptor`, only use the second form.\n   *\n   *     // Recommended\n   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {\n   *       configurable: true,\n   *       enumerable: true,\n   *       writable: true,\n   *       value: 2,\n   *     }, 'nooo why fail??');\n   *\n   *     // Recommended\n   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('a', {\n   *       configurable: true,\n   *       enumerable: true,\n   *       writable: true,\n   *       value: 2,\n   *     });\n   *\n   *     // Recommended\n   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('b');\n   *\n   *     // Not recommended\n   *     expect({a: 1})\n   *       .to.have.ownPropertyDescriptor('b', undefined, 'nooo why fail??');\n   *\n   * The above assertion isn't the same thing as not providing `descriptor`.\n   * Instead, it's asserting that the target object has a `b` property\n   * descriptor that's deeply equal to `undefined`.\n   *\n   * The alias `.haveOwnPropertyDescriptor` can be used interchangeably with\n   * `.ownPropertyDescriptor`.\n   *\n   * @name ownPropertyDescriptor\n   * @alias haveOwnPropertyDescriptor\n   * @param {String} name\n   * @param {Object} descriptor _optional_\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertOwnPropertyDescriptor (name, descriptor, msg) {\n    if (typeof descriptor === 'string') {\n      msg = descriptor;\n      descriptor = null;\n    }\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);\n    if (actualDescriptor && descriptor) {\n      this.assert(\n          _.eql(descriptor, actualDescriptor)\n        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor)\n        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor)\n        , descriptor\n        , actualDescriptor\n        , true\n      );\n    } else {\n      this.assert(\n          actualDescriptor\n        , 'expected #{this} to have an own property descriptor for ' + _.inspect(name)\n        , 'expected #{this} to not have an own property descriptor for ' + _.inspect(name)\n      );\n    }\n    flag(this, 'object', actualDescriptor);\n  }\n\n  Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);\n  Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);\n\n  /**\n   * ### .lengthOf(n[, msg])\n   *\n   * Asserts that the target's `length` or `size` is equal to the given number\n   * `n`.\n   *\n   *     expect([1, 2, 3]).to.have.lengthOf(3);\n   *     expect('foo').to.have.lengthOf(3);\n   *     expect(new Set([1, 2, 3])).to.have.lengthOf(3);\n   *     expect(new Map([['a', 1], ['b', 2], ['c', 3]])).to.have.lengthOf(3);\n   *\n   * Add `.not` earlier in the chain to negate `.lengthOf`. However, it's often\n   * best to assert that the target's `length` property is equal to its expected\n   * value, rather than not equal to one of many unexpected values.\n   *\n   *     expect('foo').to.have.lengthOf(3); // Recommended\n   *     expect('foo').to.not.have.lengthOf(4); // Not recommended\n   *\n   * `.lengthOf` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect([1, 2, 3]).to.have.lengthOf(2, 'nooo why fail??');\n   *     expect([1, 2, 3], 'nooo why fail??').to.have.lengthOf(2);\n   *\n   * `.lengthOf` can also be used as a language chain, causing all `.above`,\n   * `.below`, `.least`, `.most`, and `.within` assertions that follow in the\n   * chain to use the target's `length` property as the target. However, it's\n   * often best to assert that the target's `length` property is equal to its\n   * expected length, rather than asserting that its `length` property falls\n   * within some range of values.\n   *\n   *     // Recommended\n   *     expect([1, 2, 3]).to.have.lengthOf(3);\n   *\n   *     // Not recommended\n   *     expect([1, 2, 3]).to.have.lengthOf.above(2);\n   *     expect([1, 2, 3]).to.have.lengthOf.below(4);\n   *     expect([1, 2, 3]).to.have.lengthOf.at.least(3);\n   *     expect([1, 2, 3]).to.have.lengthOf.at.most(3);\n   *     expect([1, 2, 3]).to.have.lengthOf.within(2,4);\n   *\n   * Due to a compatibility issue, the alias `.length` can't be chained directly\n   * off of an uninvoked method such as `.a`. Therefore, `.length` can't be used\n   * interchangeably with `.lengthOf` in every situation. It's recommended to\n   * always use `.lengthOf` instead of `.length`.\n   *\n   *     expect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error\n   *     expect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected\n   *\n   * @name lengthOf\n   * @alias length\n   * @param {Number} n\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertLengthChain () {\n    flag(this, 'doLength', true);\n  }\n\n  function assertLength (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , objType = _.type(obj).toLowerCase()\n      , flagMsg = flag(this, 'message')\n      , ssfi = flag(this, 'ssfi')\n      , descriptor = 'length'\n      , itemsCount;\n\n    switch (objType) {\n      case 'map':\n      case 'set':\n        descriptor = 'size';\n        itemsCount = obj.size;\n        break;\n      default:\n        new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\n        itemsCount = obj.length;\n    }\n\n    this.assert(\n        itemsCount == n\n      , 'expected #{this} to have a ' + descriptor + ' of #{exp} but got #{act}'\n      , 'expected #{this} to not have a ' + descriptor + ' of #{act}'\n      , n\n      , itemsCount\n    );\n  }\n\n  Assertion.addChainableMethod('length', assertLength, assertLengthChain);\n  Assertion.addChainableMethod('lengthOf', assertLength, assertLengthChain);\n\n  /**\n   * ### .match(re[, msg])\n   *\n   * Asserts that the target matches the given regular expression `re`.\n   *\n   *     expect('foobar').to.match(/^foo/);\n   *\n   * Add `.not` earlier in the chain to negate `.match`.\n   *\n   *     expect('foobar').to.not.match(/taco/);\n   *\n   * `.match` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`.\n   *\n   *     expect('foobar').to.match(/taco/, 'nooo why fail??');\n   *     expect('foobar', 'nooo why fail??').to.match(/taco/);\n   *\n   * The alias `.matches` can be used interchangeably with `.match`.\n   *\n   * @name match\n   * @alias matches\n   * @param {RegExp} re\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n  function assertMatch(re, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    this.assert(\n        re.exec(obj)\n      , 'expected #{this} to match ' + re\n      , 'expected #{this} not to match ' + re\n    );\n  }\n\n  Assertion.addMethod('match', assertMatch);\n  Assertion.addMethod('matches', assertMatch);\n\n  /**\n   * ### .string(str[, msg])\n   *\n   * Asserts that the target string contains the given substring `str`.\n   *\n   *     expect('foobar').to.have.string('bar');\n   *\n   * Add `.not` earlier in the chain to negate `.string`.\n   *\n   *     expect('foobar').to.not.have.string('taco');\n   *\n   * `.string` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect('foobar').to.have.string('taco', 'nooo why fail??');\n   *     expect('foobar', 'nooo why fail??').to.have.string('taco');\n   *\n   * @name string\n   * @param {String} str\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addMethod('string', function (str, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , flagMsg = flag(this, 'message')\n      , ssfi = flag(this, 'ssfi');\n    new Assertion(obj, flagMsg, ssfi, true).is.a('string');\n\n    this.assert(\n        ~obj.indexOf(str)\n      , 'expected #{this} to contain ' + _.inspect(str)\n      , 'expected #{this} to not contain ' + _.inspect(str)\n    );\n  });\n\n  /**\n   * ### .keys(key1[, key2[, ...]])\n   *\n   * Asserts that the target object, array, map, or set has the given keys. Only\n   * the target's own inherited properties are included in the search.\n   *\n   * When the target is an object or array, keys can be provided as one or more\n   * string arguments, a single array argument, or a single object argument. In\n   * the latter case, only the keys in the given object matter; the values are\n   * ignored.\n   *\n   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');\n   *     expect(['x', 'y']).to.have.all.keys(0, 1);\n   *\n   *     expect({a: 1, b: 2}).to.have.all.keys(['a', 'b']);\n   *     expect(['x', 'y']).to.have.all.keys([0, 1]);\n   *\n   *     expect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5\n   *     expect(['x', 'y']).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5\n   *\n   * When the target is a map or set, each key must be provided as a separate\n   * argument.\n   *\n   *     expect(new Map([['a', 1], ['b', 2]])).to.have.all.keys('a', 'b');\n   *     expect(new Set(['a', 'b'])).to.have.all.keys('a', 'b');\n   *\n   * Because `.keys` does different things based on the target's type, it's\n   * important to check the target's type before using `.keys`. See the `.a` doc\n   * for info on testing a target's type.\n   *\n   *     expect({a: 1, b: 2}).to.be.an('object').that.has.all.keys('a', 'b');\n   *\n   * By default, strict (`===`) equality is used to compare keys of maps and\n   * sets. Add `.deep` earlier in the chain to use deep equality instead. See\n   * the `deep-eql` project page for info on the deep equality algorithm:\n   * https://github.com/chaijs/deep-eql.\n   *\n   *     // Target set deeply (but not strictly) has key `{a: 1}`\n   *     expect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);\n   *     expect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);\n   *\n   * By default, the target must have all of the given keys and no more. Add\n   * `.any` earlier in the chain to only require that the target have at least\n   * one of the given keys. Also, add `.not` earlier in the chain to negate\n   * `.keys`. It's often best to add `.any` when negating `.keys`, and to use\n   * `.all` when asserting `.keys` without negation.\n   *\n   * When negating `.keys`, `.any` is preferred because `.not.any.keys` asserts\n   * exactly what's expected of the output, whereas `.not.all.keys` creates\n   * uncertain expectations.\n   *\n   *     // Recommended; asserts that target doesn't have any of the given keys\n   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');\n   *\n   *     // Not recommended; asserts that target doesn't have all of the given\n   *     // keys but may or may not have some of them\n   *     expect({a: 1, b: 2}).to.not.have.all.keys('c', 'd');\n   *\n   * When asserting `.keys` without negation, `.all` is preferred because\n   * `.all.keys` asserts exactly what's expected of the output, whereas\n   * `.any.keys` creates uncertain expectations.\n   *\n   *     // Recommended; asserts that target has all the given keys\n   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');\n   *\n   *     // Not recommended; asserts that target has at least one of the given\n   *     // keys but may or may not have more of them\n   *     expect({a: 1, b: 2}).to.have.any.keys('a', 'b');\n   *\n   * Note that `.all` is used by default when neither `.all` nor `.any` appear\n   * earlier in the chain. However, it's often best to add `.all` anyway because\n   * it improves readability.\n   *\n   *     // Both assertions are identical\n   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b'); // Recommended\n   *     expect({a: 1, b: 2}).to.have.keys('a', 'b'); // Not recommended\n   *\n   * Add `.include` earlier in the chain to require that the target's keys be a\n   * superset of the expected keys, rather than identical sets.\n   *\n   *     // Target object's keys are a superset of ['a', 'b'] but not identical\n   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');\n   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');\n   *\n   * However, if `.any` and `.include` are combined, only the `.any` takes\n   * effect. The `.include` is ignored in this case.\n   *\n   *     // Both assertions are identical\n   *     expect({a: 1}).to.have.any.keys('a', 'b');\n   *     expect({a: 1}).to.include.any.keys('a', 'b');\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect({a: 1}, 'nooo why fail??').to.have.key('b');\n   *\n   * The alias `.key` can be used interchangeably with `.keys`.\n   *\n   * @name keys\n   * @alias key\n   * @param {...String|Array|Object} keys\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertKeys (keys) {\n    var obj = flag(this, 'object')\n      , objType = _.type(obj)\n      , keysType = _.type(keys)\n      , ssfi = flag(this, 'ssfi')\n      , isDeep = flag(this, 'deep')\n      , str\n      , deepStr = ''\n      , actual\n      , ok = true\n      , flagMsg = flag(this, 'message');\n\n    flagMsg = flagMsg ? flagMsg + ': ' : '';\n    var mixedArgsMsg = flagMsg + 'when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments';\n\n    if (objType === 'Map' || objType === 'Set') {\n      deepStr = isDeep ? 'deeply ' : '';\n      actual = [];\n\n      // Map and Set '.keys' aren't supported in IE 11. Therefore, use .forEach.\n      obj.forEach(function (val, key) { actual.push(key) });\n\n      if (keysType !== 'Array') {\n        keys = Array.prototype.slice.call(arguments);\n      }\n    } else {\n      actual = _.getOwnEnumerableProperties(obj);\n\n      switch (keysType) {\n        case 'Array':\n          if (arguments.length > 1) {\n            throw new AssertionError(mixedArgsMsg, undefined, ssfi);\n          }\n          break;\n        case 'Object':\n          if (arguments.length > 1) {\n            throw new AssertionError(mixedArgsMsg, undefined, ssfi);\n          }\n          keys = Object.keys(keys);\n          break;\n        default:\n          keys = Array.prototype.slice.call(arguments);\n      }\n\n      // Only stringify non-Symbols because Symbols would become \"Symbol()\"\n      keys = keys.map(function (val) {\n        return typeof val === 'symbol' ? val : String(val);\n      });\n    }\n\n    if (!keys.length) {\n      throw new AssertionError(flagMsg + 'keys required', undefined, ssfi);\n    }\n\n    var len = keys.length\n      , any = flag(this, 'any')\n      , all = flag(this, 'all')\n      , expected = keys;\n\n    if (!any && !all) {\n      all = true;\n    }\n\n    // Has any\n    if (any) {\n      ok = expected.some(function(expectedKey) {\n        return actual.some(function(actualKey) {\n          if (isDeep) {\n            return _.eql(expectedKey, actualKey);\n          } else {\n            return expectedKey === actualKey;\n          }\n        });\n      });\n    }\n\n    // Has all\n    if (all) {\n      ok = expected.every(function(expectedKey) {\n        return actual.some(function(actualKey) {\n          if (isDeep) {\n            return _.eql(expectedKey, actualKey);\n          } else {\n            return expectedKey === actualKey;\n          }\n        });\n      });\n\n      if (!flag(this, 'contains')) {\n        ok = ok && keys.length == actual.length;\n      }\n    }\n\n    // Key string\n    if (len > 1) {\n      keys = keys.map(function(key) {\n        return _.inspect(key);\n      });\n      var last = keys.pop();\n      if (all) {\n        str = keys.join(', ') + ', and ' + last;\n      }\n      if (any) {\n        str = keys.join(', ') + ', or ' + last;\n      }\n    } else {\n      str = _.inspect(keys[0]);\n    }\n\n    // Form\n    str = (len > 1 ? 'keys ' : 'key ') + str;\n\n    // Have / include\n    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;\n\n    // Assertion\n    this.assert(\n        ok\n      , 'expected #{this} to ' + deepStr + str\n      , 'expected #{this} to not ' + deepStr + str\n      , expected.slice(0).sort(_.compareByInspect)\n      , actual.sort(_.compareByInspect)\n      , true\n    );\n  }\n\n  Assertion.addMethod('keys', assertKeys);\n  Assertion.addMethod('key', assertKeys);\n\n  /**\n   * ### .throw([errorLike], [errMsgMatcher], [msg])\n   *\n   * When no arguments are provided, `.throw` invokes the target function and\n   * asserts that an error is thrown.\n   *\n   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };\n   *\n   *     expect(badFn).to.throw();\n   *\n   * When one argument is provided, and it's an error constructor, `.throw`\n   * invokes the target function and asserts that an error is thrown that's an\n   * instance of that error constructor.\n   *\n   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };\n   *\n   *     expect(badFn).to.throw(TypeError);\n   *\n   * When one argument is provided, and it's an error instance, `.throw` invokes\n   * the target function and asserts that an error is thrown that's strictly\n   * (`===`) equal to that error instance.\n   *\n   *     var err = new TypeError('Illegal salmon!');\n   *     var badFn = function () { throw err; };\n   *\n   *     expect(badFn).to.throw(err);\n   *\n   * When one argument is provided, and it's a string, `.throw` invokes the\n   * target function and asserts that an error is thrown with a message that\n   * contains that string.\n   *\n   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };\n   *\n   *     expect(badFn).to.throw('salmon');\n   *\n   * When one argument is provided, and it's a regular expression, `.throw`\n   * invokes the target function and asserts that an error is thrown with a\n   * message that matches that regular expression.\n   *\n   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };\n   *\n   *     expect(badFn).to.throw(/salmon/);\n   *\n   * When two arguments are provided, and the first is an error instance or\n   * constructor, and the second is a string or regular expression, `.throw`\n   * invokes the function and asserts that an error is thrown that fulfills both\n   * conditions as described above.\n   *\n   *     var err = new TypeError('Illegal salmon!');\n   *     var badFn = function () { throw err; };\n   *\n   *     expect(badFn).to.throw(TypeError, 'salmon');\n   *     expect(badFn).to.throw(TypeError, /salmon/);\n   *     expect(badFn).to.throw(err, 'salmon');\n   *     expect(badFn).to.throw(err, /salmon/);\n   *\n   * Add `.not` earlier in the chain to negate `.throw`.\n   *\n   *     var goodFn = function () {};\n   *\n   *     expect(goodFn).to.not.throw();\n   *\n   * However, it's dangerous to negate `.throw` when providing any arguments.\n   * The problem is that it creates uncertain expectations by asserting that the\n   * target either doesn't throw an error, or that it throws an error but of a\n   * different type than the given type, or that it throws an error of the given\n   * type but with a message that doesn't include the given string. It's often\n   * best to identify the exact output that's expected, and then write an\n   * assertion that only accepts that exact output.\n   *\n   * When the target isn't expected to throw an error, it's often best to assert\n   * exactly that.\n   *\n   *     var goodFn = function () {};\n   *\n   *     expect(goodFn).to.not.throw(); // Recommended\n   *     expect(goodFn).to.not.throw(ReferenceError, 'x'); // Not recommended\n   *\n   * When the target is expected to throw an error, it's often best to assert\n   * that the error is of its expected type, and has a message that includes an\n   * expected string, rather than asserting that it doesn't have one of many\n   * unexpected types, and doesn't have a message that includes some string.\n   *\n   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };\n   *\n   *     expect(badFn).to.throw(TypeError, 'salmon'); // Recommended\n   *     expect(badFn).to.not.throw(ReferenceError, 'x'); // Not recommended\n   *\n   * `.throw` changes the target of any assertions that follow in the chain to\n   * be the error object that's thrown.\n   *\n   *     var err = new TypeError('Illegal salmon!');\n   *     err.code = 42;\n   *     var badFn = function () { throw err; };\n   *\n   *     expect(badFn).to.throw(TypeError).with.property('code', 42);\n   *\n   * `.throw` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`. When not providing two arguments, always use\n   * the second form.\n   *\n   *     var goodFn = function () {};\n   *\n   *     expect(goodFn).to.throw(TypeError, 'x', 'nooo why fail??');\n   *     expect(goodFn, 'nooo why fail??').to.throw();\n   *\n   * Due to limitations in ES5, `.throw` may not always work as expected when\n   * using a transpiler such as Babel or TypeScript. In particular, it may\n   * produce unexpected results when subclassing the built-in `Error` object and\n   * then passing the subclassed constructor to `.throw`. See your transpiler's\n   * docs for details:\n   *\n   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))\n   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))\n   *\n   * Beware of some common mistakes when using the `throw` assertion. One common\n   * mistake is to accidentally invoke the function yourself instead of letting\n   * the `throw` assertion invoke the function for you. For example, when\n   * testing if a function named `fn` throws, provide `fn` instead of `fn()` as\n   * the target for the assertion.\n   *\n   *     expect(fn).to.throw();     // Good! Tests `fn` as desired\n   *     expect(fn()).to.throw();   // Bad! Tests result of `fn()`, not `fn`\n   *\n   * If you need to assert that your function `fn` throws when passed certain\n   * arguments, then wrap a call to `fn` inside of another function.\n   *\n   *     expect(function () { fn(42); }).to.throw();  // Function expression\n   *     expect(() => fn(42)).to.throw();             // ES6 arrow function\n   *\n   * Another common mistake is to provide an object method (or any stand-alone\n   * function that relies on `this`) as the target of the assertion. Doing so is\n   * problematic because the `this` context will be lost when the function is\n   * invoked by `.throw`; there's no way for it to know what `this` is supposed\n   * to be. There are two ways around this problem. One solution is to wrap the\n   * method or function call inside of another function. Another solution is to\n   * use `bind`.\n   *\n   *     expect(function () { cat.meow(); }).to.throw();  // Function expression\n   *     expect(() => cat.meow()).to.throw();             // ES6 arrow function\n   *     expect(cat.meow.bind(cat)).to.throw();           // Bind\n   *\n   * Finally, it's worth mentioning that it's a best practice in JavaScript to\n   * only throw `Error` and derivatives of `Error` such as `ReferenceError`,\n   * `TypeError`, and user-defined objects that extend `Error`. No other type of\n   * value will generate a stack trace when initialized. With that said, the\n   * `throw` assertion does technically support any type of value being thrown,\n   * not just `Error` and its derivatives.\n   *\n   * The aliases `.throws` and `.Throw` can be used interchangeably with\n   * `.throw`.\n   *\n   * @name throw\n   * @alias throws\n   * @alias Throw\n   * @param {Error|ErrorConstructor} errorLike\n   * @param {String|RegExp} errMsgMatcher error message\n   * @param {String} msg _optional_\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n   * @returns error for chaining (null if no error)\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertThrows (errorLike, errMsgMatcher, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , ssfi = flag(this, 'ssfi')\n      , flagMsg = flag(this, 'message')\n      , negate = flag(this, 'negate') || false;\n    new Assertion(obj, flagMsg, ssfi, true).is.a('function');\n\n    if (errorLike instanceof RegExp || typeof errorLike === 'string') {\n      errMsgMatcher = errorLike;\n      errorLike = null;\n    }\n\n    var caughtErr;\n    try {\n      obj();\n    } catch (err) {\n      caughtErr = err;\n    }\n\n    // If we have the negate flag enabled and at least one valid argument it means we do expect an error\n    // but we want it to match a given set of criteria\n    var everyArgIsUndefined = errorLike === undefined && errMsgMatcher === undefined;\n\n    // If we've got the negate flag enabled and both args, we should only fail if both aren't compatible\n    // See Issue #551 and PR #683@GitHub\n    var everyArgIsDefined = Boolean(errorLike && errMsgMatcher);\n    var errorLikeFail = false;\n    var errMsgMatcherFail = false;\n\n    // Checking if error was thrown\n    if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {\n      // We need this to display results correctly according to their types\n      var errorLikeString = 'an error';\n      if (errorLike instanceof Error) {\n        errorLikeString = '#{exp}';\n      } else if (errorLike) {\n        errorLikeString = _.checkError.getConstructorName(errorLike);\n      }\n\n      this.assert(\n          caughtErr\n        , 'expected #{this} to throw ' + errorLikeString\n        , 'expected #{this} to not throw an error but #{act} was thrown'\n        , errorLike && errorLike.toString()\n        , (caughtErr instanceof Error ?\n            caughtErr.toString() : (typeof caughtErr === 'string' ? caughtErr : caughtErr &&\n                                    _.checkError.getConstructorName(caughtErr)))\n      );\n    }\n\n    if (errorLike && caughtErr) {\n      // We should compare instances only if `errorLike` is an instance of `Error`\n      if (errorLike instanceof Error) {\n        var isCompatibleInstance = _.checkError.compatibleInstance(caughtErr, errorLike);\n\n        if (isCompatibleInstance === negate) {\n          // These checks were created to ensure we won't fail too soon when we've got both args and a negate\n          // See Issue #551 and PR #683@GitHub\n          if (everyArgIsDefined && negate) {\n            errorLikeFail = true;\n          } else {\n            this.assert(\n                negate\n              , 'expected #{this} to throw #{exp} but #{act} was thrown'\n              , 'expected #{this} to not throw #{exp}' + (caughtErr && !negate ? ' but #{act} was thrown' : '')\n              , errorLike.toString()\n              , caughtErr.toString()\n            );\n          }\n        }\n      }\n\n      var isCompatibleConstructor = _.checkError.compatibleConstructor(caughtErr, errorLike);\n      if (isCompatibleConstructor === negate) {\n        if (everyArgIsDefined && negate) {\n            errorLikeFail = true;\n        } else {\n          this.assert(\n              negate\n            , 'expected #{this} to throw #{exp} but #{act} was thrown'\n            , 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : '')\n            , (errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike))\n            , (caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr))\n          );\n        }\n      }\n    }\n\n    if (caughtErr && errMsgMatcher !== undefined && errMsgMatcher !== null) {\n      // Here we check compatible messages\n      var placeholder = 'including';\n      if (errMsgMatcher instanceof RegExp) {\n        placeholder = 'matching'\n      }\n\n      var isCompatibleMessage = _.checkError.compatibleMessage(caughtErr, errMsgMatcher);\n      if (isCompatibleMessage === negate) {\n        if (everyArgIsDefined && negate) {\n            errMsgMatcherFail = true;\n        } else {\n          this.assert(\n            negate\n            , 'expected #{this} to throw error ' + placeholder + ' #{exp} but got #{act}'\n            , 'expected #{this} to throw error not ' + placeholder + ' #{exp}'\n            ,  errMsgMatcher\n            ,  _.checkError.getMessage(caughtErr)\n          );\n        }\n      }\n    }\n\n    // If both assertions failed and both should've matched we throw an error\n    if (errorLikeFail && errMsgMatcherFail) {\n      this.assert(\n        negate\n        , 'expected #{this} to throw #{exp} but #{act} was thrown'\n        , 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : '')\n        , (errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike))\n        , (caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr))\n      );\n    }\n\n    flag(this, 'object', caughtErr);\n  };\n\n  Assertion.addMethod('throw', assertThrows);\n  Assertion.addMethod('throws', assertThrows);\n  Assertion.addMethod('Throw', assertThrows);\n\n  /**\n   * ### .respondTo(method[, msg])\n   *\n   * When the target is a non-function object, `.respondTo` asserts that the\n   * target has a method with the given name `method`. The method can be own or\n   * inherited, and it can be enumerable or non-enumerable.\n   *\n   *     function Cat () {}\n   *     Cat.prototype.meow = function () {};\n   *\n   *     expect(new Cat()).to.respondTo('meow');\n   *\n   * When the target is a function, `.respondTo` asserts that the target's\n   * `prototype` property has a method with the given name `method`. Again, the\n   * method can be own or inherited, and it can be enumerable or non-enumerable.\n   *\n   *     function Cat () {}\n   *     Cat.prototype.meow = function () {};\n   *\n   *     expect(Cat).to.respondTo('meow');\n   *\n   * Add `.itself` earlier in the chain to force `.respondTo` to treat the\n   * target as a non-function object, even if it's a function. Thus, it asserts\n   * that the target has a method with the given name `method`, rather than\n   * asserting that the target's `prototype` property has a method with the\n   * given name `method`.\n   *\n   *     function Cat () {}\n   *     Cat.prototype.meow = function () {};\n   *     Cat.hiss = function () {};\n   *\n   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');\n   *\n   * When not adding `.itself`, it's important to check the target's type before\n   * using `.respondTo`. See the `.a` doc for info on checking a target's type.\n   *\n   *     function Cat () {}\n   *     Cat.prototype.meow = function () {};\n   *\n   *     expect(new Cat()).to.be.an('object').that.respondsTo('meow');\n   *\n   * Add `.not` earlier in the chain to negate `.respondTo`.\n   *\n   *     function Dog () {}\n   *     Dog.prototype.bark = function () {};\n   *\n   *     expect(new Dog()).to.not.respondTo('meow');\n   *\n   * `.respondTo` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect({}).to.respondTo('meow', 'nooo why fail??');\n   *     expect({}, 'nooo why fail??').to.respondTo('meow');\n   *\n   * The alias `.respondsTo` can be used interchangeably with `.respondTo`.\n   *\n   * @name respondTo\n   * @alias respondsTo\n   * @param {String} method\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function respondTo (method, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , itself = flag(this, 'itself')\n      , context = ('function' === typeof obj && !itself)\n        ? obj.prototype[method]\n        : obj[method];\n\n    this.assert(\n        'function' === typeof context\n      , 'expected #{this} to respond to ' + _.inspect(method)\n      , 'expected #{this} to not respond to ' + _.inspect(method)\n    );\n  }\n\n  Assertion.addMethod('respondTo', respondTo);\n  Assertion.addMethod('respondsTo', respondTo);\n\n  /**\n   * ### .itself\n   *\n   * Forces all `.respondTo` assertions that follow in the chain to behave as if\n   * the target is a non-function object, even if it's a function. Thus, it\n   * causes `.respondTo` to assert that the target has a method with the given\n   * name, rather than asserting that the target's `prototype` property has a\n   * method with the given name.\n   *\n   *     function Cat () {}\n   *     Cat.prototype.meow = function () {};\n   *     Cat.hiss = function () {};\n   *\n   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');\n   *\n   * @name itself\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('itself', function () {\n    flag(this, 'itself', true);\n  });\n\n  /**\n   * ### .satisfy(matcher[, msg])\n   *\n   * Invokes the given `matcher` function with the target being passed as the\n   * first argument, and asserts that the value returned is truthy.\n   *\n   *     expect(1).to.satisfy(function(num) {\n   *       return num > 0;\n   *     });\n   *\n   * Add `.not` earlier in the chain to negate `.satisfy`.\n   *\n   *     expect(1).to.not.satisfy(function(num) {\n   *       return num > 2;\n   *     });\n   *\n   * `.satisfy` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect(1).to.satisfy(function(num) {\n   *       return num > 2;\n   *     }, 'nooo why fail??');\n   *\n   *     expect(1, 'nooo why fail??').to.satisfy(function(num) {\n   *       return num > 2;\n   *     });\n   *\n   * The alias `.satisfies` can be used interchangeably with `.satisfy`.\n   *\n   * @name satisfy\n   * @alias satisfies\n   * @param {Function} matcher\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function satisfy (matcher, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    var result = matcher(obj);\n    this.assert(\n        result\n      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)\n      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)\n      , flag(this, 'negate') ? false : true\n      , result\n    );\n  }\n\n  Assertion.addMethod('satisfy', satisfy);\n  Assertion.addMethod('satisfies', satisfy);\n\n  /**\n   * ### .closeTo(expected, delta[, msg])\n   *\n   * Asserts that the target is a number that's within a given +/- `delta` range\n   * of the given number `expected`. However, it's often best to assert that the\n   * target is equal to its expected value.\n   *\n   *     // Recommended\n   *     expect(1.5).to.equal(1.5);\n   *\n   *     // Not recommended\n   *     expect(1.5).to.be.closeTo(1, 0.5);\n   *     expect(1.5).to.be.closeTo(2, 0.5);\n   *     expect(1.5).to.be.closeTo(1, 1);\n   *\n   * Add `.not` earlier in the chain to negate `.closeTo`.\n   *\n   *     expect(1.5).to.equal(1.5); // Recommended\n   *     expect(1.5).to.not.be.closeTo(3, 1); // Not recommended\n   *\n   * `.closeTo` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect(1.5).to.be.closeTo(3, 1, 'nooo why fail??');\n   *     expect(1.5, 'nooo why fail??').to.be.closeTo(3, 1);\n   *\n   * The alias `.approximately` can be used interchangeably with `.closeTo`.\n   *\n   * @name closeTo\n   * @alias approximately\n   * @param {Number} expected\n   * @param {Number} delta\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function closeTo(expected, delta, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , flagMsg = flag(this, 'message')\n      , ssfi = flag(this, 'ssfi');\n\n    new Assertion(obj, flagMsg, ssfi, true).is.a('number');\n    if (typeof expected !== 'number' || typeof delta !== 'number') {\n      flagMsg = flagMsg ? flagMsg + ': ' : '';\n      throw new AssertionError(\n          flagMsg + 'the arguments to closeTo or approximately must be numbers',\n          undefined,\n          ssfi\n      );\n    }\n\n    this.assert(\n        Math.abs(obj - expected) <= delta\n      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta\n      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta\n    );\n  }\n\n  Assertion.addMethod('closeTo', closeTo);\n  Assertion.addMethod('approximately', closeTo);\n\n  // Note: Duplicates are ignored if testing for inclusion instead of sameness.\n  function isSubsetOf(subset, superset, cmp, contains, ordered) {\n    if (!contains) {\n      if (subset.length !== superset.length) return false;\n      superset = superset.slice();\n    }\n\n    return subset.every(function(elem, idx) {\n      if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];\n\n      if (!cmp) {\n        var matchIdx = superset.indexOf(elem);\n        if (matchIdx === -1) return false;\n\n        // Remove match from superset so not counted twice if duplicate in subset.\n        if (!contains) superset.splice(matchIdx, 1);\n        return true;\n      }\n\n      return superset.some(function(elem2, matchIdx) {\n        if (!cmp(elem, elem2)) return false;\n\n        // Remove match from superset so not counted twice if duplicate in subset.\n        if (!contains) superset.splice(matchIdx, 1);\n        return true;\n      });\n    });\n  }\n\n  /**\n   * ### .members(set[, msg])\n   *\n   * Asserts that the target array has the same members as the given array\n   * `set`.\n   *\n   *     expect([1, 2, 3]).to.have.members([2, 1, 3]);\n   *     expect([1, 2, 2]).to.have.members([2, 1, 2]);\n   *\n   * By default, members are compared using strict (`===`) equality. Add `.deep`\n   * earlier in the chain to use deep equality instead. See the `deep-eql`\n   * project page for info on the deep equality algorithm:\n   * https://github.com/chaijs/deep-eql.\n   *\n   *     // Target array deeply (but not strictly) has member `{a: 1}`\n   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);\n   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);\n   *\n   * By default, order doesn't matter. Add `.ordered` earlier in the chain to\n   * require that members appear in the same order.\n   *\n   *     expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);\n   *     expect([1, 2, 3]).to.have.members([2, 1, 3])\n   *       .but.not.ordered.members([2, 1, 3]);\n   *\n   * By default, both arrays must be the same size. Add `.include` earlier in\n   * the chain to require that the target's members be a superset of the\n   * expected members. Note that duplicates are ignored in the subset when\n   * `.include` is added.\n   *\n   *     // Target array is a superset of [1, 2] but not identical\n   *     expect([1, 2, 3]).to.include.members([1, 2]);\n   *     expect([1, 2, 3]).to.not.have.members([1, 2]);\n   *\n   *     // Duplicates in the subset are ignored\n   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);\n   *\n   * `.deep`, `.ordered`, and `.include` can all be combined. However, if\n   * `.include` and `.ordered` are combined, the ordering begins at the start of\n   * both arrays.\n   *\n   *     expect([{a: 1}, {b: 2}, {c: 3}])\n   *       .to.include.deep.ordered.members([{a: 1}, {b: 2}])\n   *       .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);\n   *\n   * Add `.not` earlier in the chain to negate `.members`. However, it's\n   * dangerous to do so. The problem is that it creates uncertain expectations\n   * by asserting that the target array doesn't have all of the same members as\n   * the given array `set` but may or may not have some of them. It's often best\n   * to identify the exact output that's expected, and then write an assertion\n   * that only accepts that exact output.\n   *\n   *     expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended\n   *     expect([1, 2]).to.not.have.members([3, 4]); // Not recommended\n   *\n   * `.members` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect([1, 2]).to.have.members([1, 2, 3], 'nooo why fail??');\n   *     expect([1, 2], 'nooo why fail??').to.have.members([1, 2, 3]);\n   *\n   * @name members\n   * @param {Array} set\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addMethod('members', function (subset, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , flagMsg = flag(this, 'message')\n      , ssfi = flag(this, 'ssfi');\n\n    new Assertion(obj, flagMsg, ssfi, true).to.be.an('array');\n    new Assertion(subset, flagMsg, ssfi, true).to.be.an('array');\n\n    var contains = flag(this, 'contains');\n    var ordered = flag(this, 'ordered');\n\n    var subject, failMsg, failNegateMsg;\n\n    if (contains) {\n      subject = ordered ? 'an ordered superset' : 'a superset';\n      failMsg = 'expected #{this} to be ' + subject + ' of #{exp}';\n      failNegateMsg = 'expected #{this} to not be ' + subject + ' of #{exp}';\n    } else {\n      subject = ordered ? 'ordered members' : 'members';\n      failMsg = 'expected #{this} to have the same ' + subject + ' as #{exp}';\n      failNegateMsg = 'expected #{this} to not have the same ' + subject + ' as #{exp}';\n    }\n\n    var cmp = flag(this, 'deep') ? _.eql : undefined;\n\n    this.assert(\n        isSubsetOf(subset, obj, cmp, contains, ordered)\n      , failMsg\n      , failNegateMsg\n      , subset\n      , obj\n      , true\n    );\n  });\n\n  /**\n   * ### .oneOf(list[, msg])\n   *\n   * Asserts that the target is a member of the given array `list`. However,\n   * it's often best to assert that the target is equal to its expected value.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.be.oneOf([1, 2, 3]); // Not recommended\n   *\n   * Comparisons are performed using strict (`===`) equality.\n   *\n   * Add `.not` earlier in the chain to negate `.oneOf`.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended\n   *\n   * `.oneOf` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`.\n   *\n   *     expect(1).to.be.oneOf([2, 3, 4], 'nooo why fail??');\n   *     expect(1, 'nooo why fail??').to.be.oneOf([2, 3, 4]);\n   *\n   * @name oneOf\n   * @param {Array<*>} list\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function oneOf (list, msg) {\n    if (msg) flag(this, 'message', msg);\n    var expected = flag(this, 'object')\n      , flagMsg = flag(this, 'message')\n      , ssfi = flag(this, 'ssfi');\n    new Assertion(list, flagMsg, ssfi, true).to.be.an('array');\n\n    this.assert(\n        list.indexOf(expected) > -1\n      , 'expected #{this} to be one of #{exp}'\n      , 'expected #{this} to not be one of #{exp}'\n      , list\n      , expected\n    );\n  }\n\n  Assertion.addMethod('oneOf', oneOf);\n\n  /**\n   * ### .change(subject[, prop[, msg]])\n   *\n   * When one argument is provided, `.change` asserts that the given function\n   * `subject` returns a different value when it's invoked before the target\n   * function compared to when it's invoked afterward. However, it's often best\n   * to assert that `subject` is equal to its expected value.\n   *\n   *     var dots = ''\n   *       , addDot = function () { dots += '.'; }\n   *       , getDots = function () { return dots; };\n   *\n   *     // Recommended\n   *     expect(getDots()).to.equal('');\n   *     addDot();\n   *     expect(getDots()).to.equal('.');\n   *\n   *     // Not recommended\n   *     expect(addDot).to.change(getDots);\n   *\n   * When two arguments are provided, `.change` asserts that the value of the\n   * given object `subject`'s `prop` property is different before invoking the\n   * target function compared to afterward.\n   *\n   *     var myObj = {dots: ''}\n   *       , addDot = function () { myObj.dots += '.'; };\n   *\n   *     // Recommended\n   *     expect(myObj).to.have.property('dots', '');\n   *     addDot();\n   *     expect(myObj).to.have.property('dots', '.');\n   *\n   *     // Not recommended\n   *     expect(addDot).to.change(myObj, 'dots');\n   *\n   * Strict (`===`) equality is used to compare before and after values.\n   *\n   * Add `.not` earlier in the chain to negate `.change`.\n   *\n   *     var dots = ''\n   *       , noop = function () {}\n   *       , getDots = function () { return dots; };\n   *\n   *     expect(noop).to.not.change(getDots);\n   *\n   *     var myObj = {dots: ''}\n   *       , noop = function () {};\n   *\n   *     expect(noop).to.not.change(myObj, 'dots');\n   *\n   * `.change` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`. When not providing two arguments, always\n   * use the second form.\n   *\n   *     var myObj = {dots: ''}\n   *       , addDot = function () { myObj.dots += '.'; };\n   *\n   *     expect(addDot).to.not.change(myObj, 'dots', 'nooo why fail??');\n   *\n   *     var dots = ''\n   *       , addDot = function () { dots += '.'; }\n   *       , getDots = function () { return dots; };\n   *\n   *     expect(addDot, 'nooo why fail??').to.not.change(getDots);\n   *\n   * `.change` also causes all `.by` assertions that follow in the chain to\n   * assert how much a numeric subject was increased or decreased by. However,\n   * it's dangerous to use `.change.by`. The problem is that it creates\n   * uncertain expectations by asserting that the subject either increases by\n   * the given delta, or that it decreases by the given delta. It's often best\n   * to identify the exact output that's expected, and then write an assertion\n   * that only accepts that exact output.\n   *\n   *     var myObj = {val: 1}\n   *       , addTwo = function () { myObj.val += 2; }\n   *       , subtractTwo = function () { myObj.val -= 2; };\n   *\n   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\n   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended\n   *\n   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\n   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended\n   *\n   * The alias `.changes` can be used interchangeably with `.change`.\n   *\n   * @name change\n   * @alias changes\n   * @param {String} subject\n   * @param {String} prop name _optional_\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertChanges (subject, prop, msg) {\n    if (msg) flag(this, 'message', msg);\n    var fn = flag(this, 'object')\n      , flagMsg = flag(this, 'message')\n      , ssfi = flag(this, 'ssfi');\n    new Assertion(fn, flagMsg, ssfi, true).is.a('function');\n\n    var initial;\n    if (!prop) {\n      new Assertion(subject, flagMsg, ssfi, true).is.a('function');\n      initial = subject();\n    } else {\n      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);\n      initial = subject[prop];\n    }\n\n    fn();\n\n    var final = prop === undefined || prop === null ? subject() : subject[prop];\n    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;\n\n    // This gets flagged because of the .by(delta) assertion\n    flag(this, 'deltaMsgObj', msgObj);\n    flag(this, 'initialDeltaValue', initial);\n    flag(this, 'finalDeltaValue', final);\n    flag(this, 'deltaBehavior', 'change');\n    flag(this, 'realDelta', final !== initial);\n\n    this.assert(\n      initial !== final\n      , 'expected ' + msgObj + ' to change'\n      , 'expected ' + msgObj + ' to not change'\n    );\n  }\n\n  Assertion.addMethod('change', assertChanges);\n  Assertion.addMethod('changes', assertChanges);\n\n  /**\n   * ### .increase(subject[, prop[, msg]])\n   *\n   * When one argument is provided, `.increase` asserts that the given function\n   * `subject` returns a greater number when it's invoked after invoking the\n   * target function compared to when it's invoked beforehand. `.increase` also\n   * causes all `.by` assertions that follow in the chain to assert how much\n   * greater of a number is returned. It's often best to assert that the return\n   * value increased by the expected amount, rather than asserting it increased\n   * by any amount.\n   *\n   *     var val = 1\n   *       , addTwo = function () { val += 2; }\n   *       , getVal = function () { return val; };\n   *\n   *     expect(addTwo).to.increase(getVal).by(2); // Recommended\n   *     expect(addTwo).to.increase(getVal); // Not recommended\n   *\n   * When two arguments are provided, `.increase` asserts that the value of the\n   * given object `subject`'s `prop` property is greater after invoking the\n   * target function compared to beforehand.\n   *\n   *     var myObj = {val: 1}\n   *       , addTwo = function () { myObj.val += 2; };\n   *\n   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\n   *     expect(addTwo).to.increase(myObj, 'val'); // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.increase`. However, it's\n   * dangerous to do so. The problem is that it creates uncertain expectations\n   * by asserting that the subject either decreases, or that it stays the same.\n   * It's often best to identify the exact output that's expected, and then\n   * write an assertion that only accepts that exact output.\n   *\n   * When the subject is expected to decrease, it's often best to assert that it\n   * decreased by the expected amount.\n   *\n   *     var myObj = {val: 1}\n   *       , subtractTwo = function () { myObj.val -= 2; };\n   *\n   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\n   *     expect(subtractTwo).to.not.increase(myObj, 'val'); // Not recommended\n   *\n   * When the subject is expected to stay the same, it's often best to assert\n   * exactly that.\n   *\n   *     var myObj = {val: 1}\n   *       , noop = function () {};\n   *\n   *     expect(noop).to.not.change(myObj, 'val'); // Recommended\n   *     expect(noop).to.not.increase(myObj, 'val'); // Not recommended\n   *\n   * `.increase` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`. When not providing two arguments, always\n   * use the second form.\n   *\n   *     var myObj = {val: 1}\n   *       , noop = function () {};\n   *\n   *     expect(noop).to.increase(myObj, 'val', 'nooo why fail??');\n   *\n   *     var val = 1\n   *       , noop = function () {}\n   *       , getVal = function () { return val; };\n   *\n   *     expect(noop, 'nooo why fail??').to.increase(getVal);\n   *\n   * The alias `.increases` can be used interchangeably with `.increase`.\n   *\n   * @name increase\n   * @alias increases\n   * @param {String|Function} subject\n   * @param {String} prop name _optional_\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertIncreases (subject, prop, msg) {\n    if (msg) flag(this, 'message', msg);\n    var fn = flag(this, 'object')\n      , flagMsg = flag(this, 'message')\n      , ssfi = flag(this, 'ssfi');\n    new Assertion(fn, flagMsg, ssfi, true).is.a('function');\n\n    var initial;\n    if (!prop) {\n      new Assertion(subject, flagMsg, ssfi, true).is.a('function');\n      initial = subject();\n    } else {\n      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);\n      initial = subject[prop];\n    }\n\n    // Make sure that the target is a number\n    new Assertion(initial, flagMsg, ssfi, true).is.a('number');\n\n    fn();\n\n    var final = prop === undefined || prop === null ? subject() : subject[prop];\n    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;\n\n    flag(this, 'deltaMsgObj', msgObj);\n    flag(this, 'initialDeltaValue', initial);\n    flag(this, 'finalDeltaValue', final);\n    flag(this, 'deltaBehavior', 'increase');\n    flag(this, 'realDelta', final - initial);\n\n    this.assert(\n      final - initial > 0\n      , 'expected ' + msgObj + ' to increase'\n      , 'expected ' + msgObj + ' to not increase'\n    );\n  }\n\n  Assertion.addMethod('increase', assertIncreases);\n  Assertion.addMethod('increases', assertIncreases);\n\n  /**\n   * ### .decrease(subject[, prop[, msg]])\n   *\n   * When one argument is provided, `.decrease` asserts that the given function\n   * `subject` returns a lesser number when it's invoked after invoking the\n   * target function compared to when it's invoked beforehand. `.decrease` also\n   * causes all `.by` assertions that follow in the chain to assert how much\n   * lesser of a number is returned. It's often best to assert that the return\n   * value decreased by the expected amount, rather than asserting it decreased\n   * by any amount.\n   *\n   *     var val = 1\n   *       , subtractTwo = function () { val -= 2; }\n   *       , getVal = function () { return val; };\n   *\n   *     expect(subtractTwo).to.decrease(getVal).by(2); // Recommended\n   *     expect(subtractTwo).to.decrease(getVal); // Not recommended\n   *\n   * When two arguments are provided, `.decrease` asserts that the value of the\n   * given object `subject`'s `prop` property is lesser after invoking the\n   * target function compared to beforehand.\n   *\n   *     var myObj = {val: 1}\n   *       , subtractTwo = function () { myObj.val -= 2; };\n   *\n   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\n   *     expect(subtractTwo).to.decrease(myObj, 'val'); // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.decrease`. However, it's\n   * dangerous to do so. The problem is that it creates uncertain expectations\n   * by asserting that the subject either increases, or that it stays the same.\n   * It's often best to identify the exact output that's expected, and then\n   * write an assertion that only accepts that exact output.\n   *\n   * When the subject is expected to increase, it's often best to assert that it\n   * increased by the expected amount.\n   *\n   *     var myObj = {val: 1}\n   *       , addTwo = function () { myObj.val += 2; };\n   *\n   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\n   *     expect(addTwo).to.not.decrease(myObj, 'val'); // Not recommended\n   *\n   * When the subject is expected to stay the same, it's often best to assert\n   * exactly that.\n   *\n   *     var myObj = {val: 1}\n   *       , noop = function () {};\n   *\n   *     expect(noop).to.not.change(myObj, 'val'); // Recommended\n   *     expect(noop).to.not.decrease(myObj, 'val'); // Not recommended\n   *\n   * `.decrease` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`. When not providing two arguments, always\n   * use the second form.\n   *\n   *     var myObj = {val: 1}\n   *       , noop = function () {};\n   *\n   *     expect(noop).to.decrease(myObj, 'val', 'nooo why fail??');\n   *\n   *     var val = 1\n   *       , noop = function () {}\n   *       , getVal = function () { return val; };\n   *\n   *     expect(noop, 'nooo why fail??').to.decrease(getVal);\n   *\n   * The alias `.decreases` can be used interchangeably with `.decrease`.\n   *\n   * @name decrease\n   * @alias decreases\n   * @param {String|Function} subject\n   * @param {String} prop name _optional_\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertDecreases (subject, prop, msg) {\n    if (msg) flag(this, 'message', msg);\n    var fn = flag(this, 'object')\n      , flagMsg = flag(this, 'message')\n      , ssfi = flag(this, 'ssfi');\n    new Assertion(fn, flagMsg, ssfi, true).is.a('function');\n\n    var initial;\n    if (!prop) {\n      new Assertion(subject, flagMsg, ssfi, true).is.a('function');\n      initial = subject();\n    } else {\n      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);\n      initial = subject[prop];\n    }\n\n    // Make sure that the target is a number\n    new Assertion(initial, flagMsg, ssfi, true).is.a('number');\n\n    fn();\n\n    var final = prop === undefined || prop === null ? subject() : subject[prop];\n    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;\n\n    flag(this, 'deltaMsgObj', msgObj);\n    flag(this, 'initialDeltaValue', initial);\n    flag(this, 'finalDeltaValue', final);\n    flag(this, 'deltaBehavior', 'decrease');\n    flag(this, 'realDelta', initial - final);\n\n    this.assert(\n      final - initial < 0\n      , 'expected ' + msgObj + ' to decrease'\n      , 'expected ' + msgObj + ' to not decrease'\n    );\n  }\n\n  Assertion.addMethod('decrease', assertDecreases);\n  Assertion.addMethod('decreases', assertDecreases);\n\n  /**\n   * ### .by(delta[, msg])\n   *\n   * When following an `.increase` assertion in the chain, `.by` asserts that\n   * the subject of the `.increase` assertion increased by the given `delta`.\n   *\n   *     var myObj = {val: 1}\n   *       , addTwo = function () { myObj.val += 2; };\n   *\n   *     expect(addTwo).to.increase(myObj, 'val').by(2);\n   *\n   * When following a `.decrease` assertion in the chain, `.by` asserts that the\n   * subject of the `.decrease` assertion decreased by the given `delta`.\n   *\n   *     var myObj = {val: 1}\n   *       , subtractTwo = function () { myObj.val -= 2; };\n   *\n   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2);\n   *\n   * When following a `.change` assertion in the chain, `.by` asserts that the\n   * subject of the `.change` assertion either increased or decreased by the\n   * given `delta`. However, it's dangerous to use `.change.by`. The problem is\n   * that it creates uncertain expectations. It's often best to identify the\n   * exact output that's expected, and then write an assertion that only accepts\n   * that exact output.\n   *\n   *     var myObj = {val: 1}\n   *       , addTwo = function () { myObj.val += 2; }\n   *       , subtractTwo = function () { myObj.val -= 2; };\n   *\n   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\n   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended\n   *\n   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\n   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.by`. However, it's often best\n   * to assert that the subject changed by its expected delta, rather than\n   * asserting that it didn't change by one of countless unexpected deltas.\n   *\n   *     var myObj = {val: 1}\n   *       , addTwo = function () { myObj.val += 2; };\n   *\n   *     // Recommended\n   *     expect(addTwo).to.increase(myObj, 'val').by(2);\n   *\n   *     // Not recommended\n   *     expect(addTwo).to.increase(myObj, 'val').but.not.by(3);\n   *\n   * `.by` accepts an optional `msg` argument which is a custom error message to\n   * show when the assertion fails. The message can also be given as the second\n   * argument to `expect`.\n   *\n   *     var myObj = {val: 1}\n   *       , addTwo = function () { myObj.val += 2; };\n   *\n   *     expect(addTwo).to.increase(myObj, 'val').by(3, 'nooo why fail??');\n   *     expect(addTwo, 'nooo why fail??').to.increase(myObj, 'val').by(3);\n   *\n   * @name by\n   * @param {Number} delta\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertDelta(delta, msg) {\n    if (msg) flag(this, 'message', msg);\n\n    var msgObj = flag(this, 'deltaMsgObj');\n    var initial = flag(this, 'initialDeltaValue');\n    var final = flag(this, 'finalDeltaValue');\n    var behavior = flag(this, 'deltaBehavior');\n    var realDelta = flag(this, 'realDelta');\n\n    var expression;\n    if (behavior === 'change') {\n      expression = Math.abs(final - initial) === Math.abs(delta);\n    } else {\n      expression = realDelta === Math.abs(delta);\n    }\n\n    this.assert(\n      expression\n      , 'expected ' + msgObj + ' to ' + behavior + ' by ' + delta\n      , 'expected ' + msgObj + ' to not ' + behavior + ' by ' + delta\n    );\n  }\n\n  Assertion.addMethod('by', assertDelta);\n\n  /**\n   * ### .extensible\n   *\n   * Asserts that the target is extensible, which means that new properties can\n   * be added to it. Primitives are never extensible.\n   *\n   *     expect({a: 1}).to.be.extensible;\n   *\n   * Add `.not` earlier in the chain to negate `.extensible`.\n   *\n   *     var nonExtensibleObject = Object.preventExtensions({})\n   *       , sealedObject = Object.seal({})\n   *       , frozenObject = Object.freeze({});\n   *\n   *     expect(nonExtensibleObject).to.not.be.extensible;\n   *     expect(sealedObject).to.not.be.extensible;\n   *     expect(frozenObject).to.not.be.extensible;\n   *     expect(1).to.not.be.extensible;\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect(1, 'nooo why fail??').to.be.extensible;\n   *\n   * @name extensible\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('extensible', function() {\n    var obj = flag(this, 'object');\n\n    // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.\n    // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible\n    // The following provides ES6 behavior for ES5 environments.\n\n    var isExtensible = obj === Object(obj) && Object.isExtensible(obj);\n\n    this.assert(\n      isExtensible\n      , 'expected #{this} to be extensible'\n      , 'expected #{this} to not be extensible'\n    );\n  });\n\n  /**\n   * ### .sealed\n   *\n   * Asserts that the target is sealed, which means that new properties can't be\n   * added to it, and its existing properties can't be reconfigured or deleted.\n   * However, it's possible that its existing properties can still be reassigned\n   * to different values. Primitives are always sealed.\n   *\n   *     var sealedObject = Object.seal({});\n   *     var frozenObject = Object.freeze({});\n   *\n   *     expect(sealedObject).to.be.sealed;\n   *     expect(frozenObject).to.be.sealed;\n   *     expect(1).to.be.sealed;\n   *\n   * Add `.not` earlier in the chain to negate `.sealed`.\n   *\n   *     expect({a: 1}).to.not.be.sealed;\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect({a: 1}, 'nooo why fail??').to.be.sealed;\n   *\n   * @name sealed\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('sealed', function() {\n    var obj = flag(this, 'object');\n\n    // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.\n    // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed\n    // The following provides ES6 behavior for ES5 environments.\n\n    var isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;\n\n    this.assert(\n      isSealed\n      , 'expected #{this} to be sealed'\n      , 'expected #{this} to not be sealed'\n    );\n  });\n\n  /**\n   * ### .frozen\n   *\n   * Asserts that the target is frozen, which means that new properties can't be\n   * added to it, and its existing properties can't be reassigned to different\n   * values, reconfigured, or deleted. Primitives are always frozen.\n   *\n   *     var frozenObject = Object.freeze({});\n   *\n   *     expect(frozenObject).to.be.frozen;\n   *     expect(1).to.be.frozen;\n   *\n   * Add `.not` earlier in the chain to negate `.frozen`.\n   *\n   *     expect({a: 1}).to.not.be.frozen;\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect({a: 1}, 'nooo why fail??').to.be.frozen;\n   *\n   * @name frozen\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('frozen', function() {\n    var obj = flag(this, 'object');\n\n    // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.\n    // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen\n    // The following provides ES6 behavior for ES5 environments.\n\n    var isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;\n\n    this.assert(\n      isFrozen\n      , 'expected #{this} to be frozen'\n      , 'expected #{this} to not be frozen'\n    );\n  });\n\n  /**\n   * ### .finite\n   *\n   * Asserts that the target is a number, and isn't `NaN` or positive/negative\n   * `Infinity`.\n   *\n   *     expect(1).to.be.finite;\n   *\n   * Add `.not` earlier in the chain to negate `.finite`. However, it's\n   * dangerous to do so. The problem is that it creates uncertain expectations\n   * by asserting that the subject either isn't a number, or that it's `NaN`, or\n   * that it's positive `Infinity`, or that it's negative `Infinity`. It's often\n   * best to identify the exact output that's expected, and then write an\n   * assertion that only accepts that exact output.\n   *\n   * When the target isn't expected to be a number, it's often best to assert\n   * that it's the expected type, rather than asserting that it isn't one of\n   * many unexpected types.\n   *\n   *     expect('foo').to.be.a('string'); // Recommended\n   *     expect('foo').to.not.be.finite; // Not recommended\n   *\n   * When the target is expected to be `NaN`, it's often best to assert exactly\n   * that.\n   *\n   *     expect(NaN).to.be.NaN; // Recommended\n   *     expect(NaN).to.not.be.finite; // Not recommended\n   *\n   * When the target is expected to be positive infinity, it's often best to\n   * assert exactly that.\n   *\n   *     expect(Infinity).to.equal(Infinity); // Recommended\n   *     expect(Infinity).to.not.be.finite; // Not recommended\n   *\n   * When the target is expected to be negative infinity, it's often best to\n   * assert exactly that.\n   *\n   *     expect(-Infinity).to.equal(-Infinity); // Recommended\n   *     expect(-Infinity).to.not.be.finite; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect('foo', 'nooo why fail??').to.be.finite;\n   *\n   * @name finite\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('finite', function(msg) {\n    var obj = flag(this, 'object');\n\n    this.assert(\n        typeof obj === 'number' && isFinite(obj)\n      , 'expected #{this} to be a finite number'\n      , 'expected #{this} to not be a finite number'\n    );\n  });\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/core/assertions.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/interface/assert.js":
/*!*********************************************************!*\
  !*** ../node_modules/chai/lib/chai/interface/assert.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, util) {\n  /*!\n   * Chai dependencies.\n   */\n\n  var Assertion = chai.Assertion\n    , flag = util.flag;\n\n  /*!\n   * Module export.\n   */\n\n  /**\n   * ### assert(expression, message)\n   *\n   * Write your own test expressions.\n   *\n   *     assert('foo' !== 'bar', 'foo is not bar');\n   *     assert(Array.isArray([]), 'empty arrays are arrays');\n   *\n   * @param {Mixed} expression to test for truthiness\n   * @param {String} message to display on error\n   * @name assert\n   * @namespace Assert\n   * @api public\n   */\n\n  var assert = chai.assert = function (express, errmsg) {\n    var test = new Assertion(null, null, chai.assert, true);\n    test.assert(\n        express\n      , errmsg\n      , '[ negation message unavailable ]'\n    );\n  };\n\n  /**\n   * ### .fail([message])\n   * ### .fail(actual, expected, [message], [operator])\n   *\n   * Throw a failure. Node.js `assert` module-compatible.\n   *\n   *     assert.fail();\n   *     assert.fail(\"custom error message\");\n   *     assert.fail(1, 2);\n   *     assert.fail(1, 2, \"custom error message\");\n   *     assert.fail(1, 2, \"custom error message\", \">\");\n   *     assert.fail(1, 2, undefined, \">\");\n   *\n   * @name fail\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @param {String} operator\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.fail = function (actual, expected, message, operator) {\n    if (arguments.length < 2) {\n        // Comply with Node's fail([message]) interface\n\n        message = actual;\n        actual = undefined;\n    }\n\n    message = message || 'assert.fail()';\n    throw new chai.AssertionError(message, {\n        actual: actual\n      , expected: expected\n      , operator: operator\n    }, assert.fail);\n  };\n\n  /**\n   * ### .isOk(object, [message])\n   *\n   * Asserts that `object` is truthy.\n   *\n   *     assert.isOk('everything', 'everything is ok');\n   *     assert.isOk(false, 'this will fail');\n   *\n   * @name isOk\n   * @alias ok\n   * @param {Mixed} object to test\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isOk = function (val, msg) {\n    new Assertion(val, msg, assert.isOk, true).is.ok;\n  };\n\n  /**\n   * ### .isNotOk(object, [message])\n   *\n   * Asserts that `object` is falsy.\n   *\n   *     assert.isNotOk('everything', 'this will fail');\n   *     assert.isNotOk(false, 'this will pass');\n   *\n   * @name isNotOk\n   * @alias notOk\n   * @param {Mixed} object to test\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotOk = function (val, msg) {\n    new Assertion(val, msg, assert.isNotOk, true).is.not.ok;\n  };\n\n  /**\n   * ### .equal(actual, expected, [message])\n   *\n   * Asserts non-strict equality (`==`) of `actual` and `expected`.\n   *\n   *     assert.equal(3, '3', '== coerces values to strings');\n   *\n   * @name equal\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.equal = function (act, exp, msg) {\n    var test = new Assertion(act, msg, assert.equal, true);\n\n    test.assert(\n        exp == flag(test, 'object')\n      , 'expected #{this} to equal #{exp}'\n      , 'expected #{this} to not equal #{act}'\n      , exp\n      , act\n      , true\n    );\n  };\n\n  /**\n   * ### .notEqual(actual, expected, [message])\n   *\n   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.\n   *\n   *     assert.notEqual(3, 4, 'these numbers are not equal');\n   *\n   * @name notEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notEqual = function (act, exp, msg) {\n    var test = new Assertion(act, msg, assert.notEqual, true);\n\n    test.assert(\n        exp != flag(test, 'object')\n      , 'expected #{this} to not equal #{exp}'\n      , 'expected #{this} to equal #{act}'\n      , exp\n      , act\n      , true\n    );\n  };\n\n  /**\n   * ### .strictEqual(actual, expected, [message])\n   *\n   * Asserts strict equality (`===`) of `actual` and `expected`.\n   *\n   *     assert.strictEqual(true, true, 'these booleans are strictly equal');\n   *\n   * @name strictEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.strictEqual = function (act, exp, msg) {\n    new Assertion(act, msg, assert.strictEqual, true).to.equal(exp);\n  };\n\n  /**\n   * ### .notStrictEqual(actual, expected, [message])\n   *\n   * Asserts strict inequality (`!==`) of `actual` and `expected`.\n   *\n   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');\n   *\n   * @name notStrictEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notStrictEqual = function (act, exp, msg) {\n    new Assertion(act, msg, assert.notStrictEqual, true).to.not.equal(exp);\n  };\n\n  /**\n   * ### .deepEqual(actual, expected, [message])\n   *\n   * Asserts that `actual` is deeply equal to `expected`.\n   *\n   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });\n   *\n   * @name deepEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @alias deepStrictEqual\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.deepEqual = assert.deepStrictEqual = function (act, exp, msg) {\n    new Assertion(act, msg, assert.deepEqual, true).to.eql(exp);\n  };\n\n  /**\n   * ### .notDeepEqual(actual, expected, [message])\n   *\n   * Assert that `actual` is not deeply equal to `expected`.\n   *\n   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });\n   *\n   * @name notDeepEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notDeepEqual = function (act, exp, msg) {\n    new Assertion(act, msg, assert.notDeepEqual, true).to.not.eql(exp);\n  };\n\n   /**\n   * ### .isAbove(valueToCheck, valueToBeAbove, [message])\n   *\n   * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`.\n   *\n   *     assert.isAbove(5, 2, '5 is strictly greater than 2');\n   *\n   * @name isAbove\n   * @param {Mixed} valueToCheck\n   * @param {Mixed} valueToBeAbove\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isAbove = function (val, abv, msg) {\n    new Assertion(val, msg, assert.isAbove, true).to.be.above(abv);\n  };\n\n   /**\n   * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])\n   *\n   * Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`.\n   *\n   *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');\n   *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');\n   *\n   * @name isAtLeast\n   * @param {Mixed} valueToCheck\n   * @param {Mixed} valueToBeAtLeast\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isAtLeast = function (val, atlst, msg) {\n    new Assertion(val, msg, assert.isAtLeast, true).to.be.least(atlst);\n  };\n\n   /**\n   * ### .isBelow(valueToCheck, valueToBeBelow, [message])\n   *\n   * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`.\n   *\n   *     assert.isBelow(3, 6, '3 is strictly less than 6');\n   *\n   * @name isBelow\n   * @param {Mixed} valueToCheck\n   * @param {Mixed} valueToBeBelow\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isBelow = function (val, blw, msg) {\n    new Assertion(val, msg, assert.isBelow, true).to.be.below(blw);\n  };\n\n   /**\n   * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])\n   *\n   * Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`.\n   *\n   *     assert.isAtMost(3, 6, '3 is less than or equal to 6');\n   *     assert.isAtMost(4, 4, '4 is less than or equal to 4');\n   *\n   * @name isAtMost\n   * @param {Mixed} valueToCheck\n   * @param {Mixed} valueToBeAtMost\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isAtMost = function (val, atmst, msg) {\n    new Assertion(val, msg, assert.isAtMost, true).to.be.most(atmst);\n  };\n\n  /**\n   * ### .isTrue(value, [message])\n   *\n   * Asserts that `value` is true.\n   *\n   *     var teaServed = true;\n   *     assert.isTrue(teaServed, 'the tea has been served');\n   *\n   * @name isTrue\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isTrue = function (val, msg) {\n    new Assertion(val, msg, assert.isTrue, true).is['true'];\n  };\n\n  /**\n   * ### .isNotTrue(value, [message])\n   *\n   * Asserts that `value` is not true.\n   *\n   *     var tea = 'tasty chai';\n   *     assert.isNotTrue(tea, 'great, time for tea!');\n   *\n   * @name isNotTrue\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotTrue = function (val, msg) {\n    new Assertion(val, msg, assert.isNotTrue, true).to.not.equal(true);\n  };\n\n  /**\n   * ### .isFalse(value, [message])\n   *\n   * Asserts that `value` is false.\n   *\n   *     var teaServed = false;\n   *     assert.isFalse(teaServed, 'no tea yet? hmm...');\n   *\n   * @name isFalse\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isFalse = function (val, msg) {\n    new Assertion(val, msg, assert.isFalse, true).is['false'];\n  };\n\n  /**\n   * ### .isNotFalse(value, [message])\n   *\n   * Asserts that `value` is not false.\n   *\n   *     var tea = 'tasty chai';\n   *     assert.isNotFalse(tea, 'great, time for tea!');\n   *\n   * @name isNotFalse\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotFalse = function (val, msg) {\n    new Assertion(val, msg, assert.isNotFalse, true).to.not.equal(false);\n  };\n\n  /**\n   * ### .isNull(value, [message])\n   *\n   * Asserts that `value` is null.\n   *\n   *     assert.isNull(err, 'there was no error');\n   *\n   * @name isNull\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNull = function (val, msg) {\n    new Assertion(val, msg, assert.isNull, true).to.equal(null);\n  };\n\n  /**\n   * ### .isNotNull(value, [message])\n   *\n   * Asserts that `value` is not null.\n   *\n   *     var tea = 'tasty chai';\n   *     assert.isNotNull(tea, 'great, time for tea!');\n   *\n   * @name isNotNull\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotNull = function (val, msg) {\n    new Assertion(val, msg, assert.isNotNull, true).to.not.equal(null);\n  };\n\n  /**\n   * ### .isNaN\n   *\n   * Asserts that value is NaN.\n   *\n   *     assert.isNaN(NaN, 'NaN is NaN');\n   *\n   * @name isNaN\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNaN = function (val, msg) {\n    new Assertion(val, msg, assert.isNaN, true).to.be.NaN;\n  };\n\n  /**\n   * ### .isNotNaN\n   *\n   * Asserts that value is not NaN.\n   *\n   *     assert.isNotNaN(4, '4 is not NaN');\n   *\n   * @name isNotNaN\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n  assert.isNotNaN = function (val, msg) {\n    new Assertion(val, msg, assert.isNotNaN, true).not.to.be.NaN;\n  };\n\n  /**\n   * ### .exists\n   *\n   * Asserts that the target is neither `null` nor `undefined`.\n   *\n   *     var foo = 'hi';\n   *\n   *     assert.exists(foo, 'foo is neither `null` nor `undefined`');\n   *\n   * @name exists\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.exists = function (val, msg) {\n    new Assertion(val, msg, assert.exists, true).to.exist;\n  };\n\n  /**\n   * ### .notExists\n   *\n   * Asserts that the target is either `null` or `undefined`.\n   *\n   *     var bar = null\n   *       , baz;\n   *\n   *     assert.notExists(bar);\n   *     assert.notExists(baz, 'baz is either null or undefined');\n   *\n   * @name notExists\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notExists = function (val, msg) {\n    new Assertion(val, msg, assert.notExists, true).to.not.exist;\n  };\n\n  /**\n   * ### .isUndefined(value, [message])\n   *\n   * Asserts that `value` is `undefined`.\n   *\n   *     var tea;\n   *     assert.isUndefined(tea, 'no tea defined');\n   *\n   * @name isUndefined\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isUndefined = function (val, msg) {\n    new Assertion(val, msg, assert.isUndefined, true).to.equal(undefined);\n  };\n\n  /**\n   * ### .isDefined(value, [message])\n   *\n   * Asserts that `value` is not `undefined`.\n   *\n   *     var tea = 'cup of chai';\n   *     assert.isDefined(tea, 'tea has been defined');\n   *\n   * @name isDefined\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isDefined = function (val, msg) {\n    new Assertion(val, msg, assert.isDefined, true).to.not.equal(undefined);\n  };\n\n  /**\n   * ### .isFunction(value, [message])\n   *\n   * Asserts that `value` is a function.\n   *\n   *     function serveTea() { return 'cup of tea'; };\n   *     assert.isFunction(serveTea, 'great, we can have tea now');\n   *\n   * @name isFunction\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isFunction = function (val, msg) {\n    new Assertion(val, msg, assert.isFunction, true).to.be.a('function');\n  };\n\n  /**\n   * ### .isNotFunction(value, [message])\n   *\n   * Asserts that `value` is _not_ a function.\n   *\n   *     var serveTea = [ 'heat', 'pour', 'sip' ];\n   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');\n   *\n   * @name isNotFunction\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotFunction = function (val, msg) {\n    new Assertion(val, msg, assert.isNotFunction, true).to.not.be.a('function');\n  };\n\n  /**\n   * ### .isObject(value, [message])\n   *\n   * Asserts that `value` is an object of type 'Object' (as revealed by `Object.prototype.toString`).\n   * _The assertion does not match subclassed objects._\n   *\n   *     var selection = { name: 'Chai', serve: 'with spices' };\n   *     assert.isObject(selection, 'tea selection is an object');\n   *\n   * @name isObject\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isObject = function (val, msg) {\n    new Assertion(val, msg, assert.isObject, true).to.be.a('object');\n  };\n\n  /**\n   * ### .isNotObject(value, [message])\n   *\n   * Asserts that `value` is _not_ an object of type 'Object' (as revealed by `Object.prototype.toString`).\n   *\n   *     var selection = 'chai'\n   *     assert.isNotObject(selection, 'tea selection is not an object');\n   *     assert.isNotObject(null, 'null is not an object');\n   *\n   * @name isNotObject\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotObject = function (val, msg) {\n    new Assertion(val, msg, assert.isNotObject, true).to.not.be.a('object');\n  };\n\n  /**\n   * ### .isArray(value, [message])\n   *\n   * Asserts that `value` is an array.\n   *\n   *     var menu = [ 'green', 'chai', 'oolong' ];\n   *     assert.isArray(menu, 'what kind of tea do we want?');\n   *\n   * @name isArray\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isArray = function (val, msg) {\n    new Assertion(val, msg, assert.isArray, true).to.be.an('array');\n  };\n\n  /**\n   * ### .isNotArray(value, [message])\n   *\n   * Asserts that `value` is _not_ an array.\n   *\n   *     var menu = 'green|chai|oolong';\n   *     assert.isNotArray(menu, 'what kind of tea do we want?');\n   *\n   * @name isNotArray\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotArray = function (val, msg) {\n    new Assertion(val, msg, assert.isNotArray, true).to.not.be.an('array');\n  };\n\n  /**\n   * ### .isString(value, [message])\n   *\n   * Asserts that `value` is a string.\n   *\n   *     var teaOrder = 'chai';\n   *     assert.isString(teaOrder, 'order placed');\n   *\n   * @name isString\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isString = function (val, msg) {\n    new Assertion(val, msg, assert.isString, true).to.be.a('string');\n  };\n\n  /**\n   * ### .isNotString(value, [message])\n   *\n   * Asserts that `value` is _not_ a string.\n   *\n   *     var teaOrder = 4;\n   *     assert.isNotString(teaOrder, 'order placed');\n   *\n   * @name isNotString\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotString = function (val, msg) {\n    new Assertion(val, msg, assert.isNotString, true).to.not.be.a('string');\n  };\n\n  /**\n   * ### .isNumber(value, [message])\n   *\n   * Asserts that `value` is a number.\n   *\n   *     var cups = 2;\n   *     assert.isNumber(cups, 'how many cups');\n   *\n   * @name isNumber\n   * @param {Number} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNumber = function (val, msg) {\n    new Assertion(val, msg, assert.isNumber, true).to.be.a('number');\n  };\n\n  /**\n   * ### .isNotNumber(value, [message])\n   *\n   * Asserts that `value` is _not_ a number.\n   *\n   *     var cups = '2 cups please';\n   *     assert.isNotNumber(cups, 'how many cups');\n   *\n   * @name isNotNumber\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotNumber = function (val, msg) {\n    new Assertion(val, msg, assert.isNotNumber, true).to.not.be.a('number');\n  };\n\n   /**\n   * ### .isFinite(value, [message])\n   *\n   * Asserts that `value` is a finite number. Unlike `.isNumber`, this will fail for `NaN` and `Infinity`.\n   *\n   *     var cups = 2;\n   *     assert.isFinite(cups, 'how many cups');\n   *\n   *     assert.isFinite(NaN); // throws\n   *\n   * @name isFinite\n   * @param {Number} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isFinite = function (val, msg) {\n    new Assertion(val, msg, assert.isFinite, true).to.be.finite;\n  };\n\n  /**\n   * ### .isBoolean(value, [message])\n   *\n   * Asserts that `value` is a boolean.\n   *\n   *     var teaReady = true\n   *       , teaServed = false;\n   *\n   *     assert.isBoolean(teaReady, 'is the tea ready');\n   *     assert.isBoolean(teaServed, 'has tea been served');\n   *\n   * @name isBoolean\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isBoolean = function (val, msg) {\n    new Assertion(val, msg, assert.isBoolean, true).to.be.a('boolean');\n  };\n\n  /**\n   * ### .isNotBoolean(value, [message])\n   *\n   * Asserts that `value` is _not_ a boolean.\n   *\n   *     var teaReady = 'yep'\n   *       , teaServed = 'nope';\n   *\n   *     assert.isNotBoolean(teaReady, 'is the tea ready');\n   *     assert.isNotBoolean(teaServed, 'has tea been served');\n   *\n   * @name isNotBoolean\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotBoolean = function (val, msg) {\n    new Assertion(val, msg, assert.isNotBoolean, true).to.not.be.a('boolean');\n  };\n\n  /**\n   * ### .typeOf(value, name, [message])\n   *\n   * Asserts that `value`'s type is `name`, as determined by\n   * `Object.prototype.toString`.\n   *\n   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');\n   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');\n   *     assert.typeOf('tea', 'string', 'we have a string');\n   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');\n   *     assert.typeOf(null, 'null', 'we have a null');\n   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');\n   *\n   * @name typeOf\n   * @param {Mixed} value\n   * @param {String} name\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.typeOf = function (val, type, msg) {\n    new Assertion(val, msg, assert.typeOf, true).to.be.a(type);\n  };\n\n  /**\n   * ### .notTypeOf(value, name, [message])\n   *\n   * Asserts that `value`'s type is _not_ `name`, as determined by\n   * `Object.prototype.toString`.\n   *\n   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');\n   *\n   * @name notTypeOf\n   * @param {Mixed} value\n   * @param {String} typeof name\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notTypeOf = function (val, type, msg) {\n    new Assertion(val, msg, assert.notTypeOf, true).to.not.be.a(type);\n  };\n\n  /**\n   * ### .instanceOf(object, constructor, [message])\n   *\n   * Asserts that `value` is an instance of `constructor`.\n   *\n   *     var Tea = function (name) { this.name = name; }\n   *       , chai = new Tea('chai');\n   *\n   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');\n   *\n   * @name instanceOf\n   * @param {Object} object\n   * @param {Constructor} constructor\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.instanceOf = function (val, type, msg) {\n    new Assertion(val, msg, assert.instanceOf, true).to.be.instanceOf(type);\n  };\n\n  /**\n   * ### .notInstanceOf(object, constructor, [message])\n   *\n   * Asserts `value` is not an instance of `constructor`.\n   *\n   *     var Tea = function (name) { this.name = name; }\n   *       , chai = new String('chai');\n   *\n   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');\n   *\n   * @name notInstanceOf\n   * @param {Object} object\n   * @param {Constructor} constructor\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notInstanceOf = function (val, type, msg) {\n    new Assertion(val, msg, assert.notInstanceOf, true)\n      .to.not.be.instanceOf(type);\n  };\n\n  /**\n   * ### .include(haystack, needle, [message])\n   *\n   * Asserts that `haystack` includes `needle`. Can be used to assert the\n   * inclusion of a value in an array, a substring in a string, or a subset of\n   * properties in an object.\n   *\n   *     assert.include([1,2,3], 2, 'array contains value');\n   *     assert.include('foobar', 'foo', 'string contains substring');\n   *     assert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property');\n   *\n   * Strict equality (===) is used. When asserting the inclusion of a value in\n   * an array, the array is searched for an element that's strictly equal to the\n   * given value. When asserting a subset of properties in an object, the object\n   * is searched for the given property keys, checking that each one is present\n   * and strictly equal to the given property value. For instance:\n   *\n   *     var obj1 = {a: 1}\n   *       , obj2 = {b: 2};\n   *     assert.include([obj1, obj2], obj1);\n   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1});\n   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1, bar: obj2});\n   *\n   * @name include\n   * @param {Array|String} haystack\n   * @param {Mixed} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.include = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.include, true).include(inc);\n  };\n\n  /**\n   * ### .notInclude(haystack, needle, [message])\n   *\n   * Asserts that `haystack` does not include `needle`. Can be used to assert\n   * the absence of a value in an array, a substring in a string, or a subset of\n   * properties in an object.\n   *\n   *     assert.notInclude([1,2,3], 4, \"array doesn't contain value\");\n   *     assert.notInclude('foobar', 'baz', \"string doesn't contain substring\");\n   *     assert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn't contain property');\n   *\n   * Strict equality (===) is used. When asserting the absence of a value in an\n   * array, the array is searched to confirm the absence of an element that's\n   * strictly equal to the given value. When asserting a subset of properties in\n   * an object, the object is searched to confirm that at least one of the given\n   * property keys is either not present or not strictly equal to the given\n   * property value. For instance:\n   *\n   *     var obj1 = {a: 1}\n   *       , obj2 = {b: 2};\n   *     assert.notInclude([obj1, obj2], {a: 1});\n   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});\n   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: obj1, bar: {b: 2}});\n   *\n   * @name notInclude\n   * @param {Array|String} haystack\n   * @param {Mixed} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notInclude = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.notInclude, true).not.include(inc);\n  };\n\n  /**\n   * ### .deepInclude(haystack, needle, [message])\n   *\n   * Asserts that `haystack` includes `needle`. Can be used to assert the\n   * inclusion of a value in an array or a subset of properties in an object.\n   * Deep equality is used.\n   *\n   *     var obj1 = {a: 1}\n   *       , obj2 = {b: 2};\n   *     assert.deepInclude([obj1, obj2], {a: 1});\n   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});\n   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 2}});\n   *\n   * @name deepInclude\n   * @param {Array|String} haystack\n   * @param {Mixed} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.deepInclude = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.deepInclude, true).deep.include(inc);\n  };\n\n  /**\n   * ### .notDeepInclude(haystack, needle, [message])\n   *\n   * Asserts that `haystack` does not include `needle`. Can be used to assert\n   * the absence of a value in an array or a subset of properties in an object.\n   * Deep equality is used.\n   *\n   *     var obj1 = {a: 1}\n   *       , obj2 = {b: 2};\n   *     assert.notDeepInclude([obj1, obj2], {a: 9});\n   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 9}});\n   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 9}});\n   *\n   * @name notDeepInclude\n   * @param {Array|String} haystack\n   * @param {Mixed} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notDeepInclude = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.notDeepInclude, true).not.deep.include(inc);\n  };\n\n  /**\n   * ### .nestedInclude(haystack, needle, [message])\n   *\n   * Asserts that 'haystack' includes 'needle'.\n   * Can be used to assert the inclusion of a subset of properties in an\n   * object.\n   * Enables the use of dot- and bracket-notation for referencing nested\n   * properties.\n   * '[]' and '.' in property names can be escaped using double backslashes.\n   *\n   *     assert.nestedInclude({'.a': {'b': 'x'}}, {'\\\\.a.[b]': 'x'});\n   *     assert.nestedInclude({'a': {'[b]': 'x'}}, {'a.\\\\[b\\\\]': 'x'});\n   *\n   * @name nestedInclude\n   * @param {Object} haystack\n   * @param {Object} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.nestedInclude = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.nestedInclude, true).nested.include(inc);\n  };\n\n  /**\n   * ### .notNestedInclude(haystack, needle, [message])\n   *\n   * Asserts that 'haystack' does not include 'needle'.\n   * Can be used to assert the absence of a subset of properties in an\n   * object.\n   * Enables the use of dot- and bracket-notation for referencing nested\n   * properties.\n   * '[]' and '.' in property names can be escaped using double backslashes.\n   *\n   *     assert.notNestedInclude({'.a': {'b': 'x'}}, {'\\\\.a.b': 'y'});\n   *     assert.notNestedInclude({'a': {'[b]': 'x'}}, {'a.\\\\[b\\\\]': 'y'});\n   *\n   * @name notNestedInclude\n   * @param {Object} haystack\n   * @param {Object} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notNestedInclude = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.notNestedInclude, true)\n      .not.nested.include(inc);\n  };\n\n  /**\n   * ### .deepNestedInclude(haystack, needle, [message])\n   *\n   * Asserts that 'haystack' includes 'needle'.\n   * Can be used to assert the inclusion of a subset of properties in an\n   * object while checking for deep equality.\n   * Enables the use of dot- and bracket-notation for referencing nested\n   * properties.\n   * '[]' and '.' in property names can be escaped using double backslashes.\n   *\n   *     assert.deepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {x: 1}});\n   *     assert.deepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\\\.a.\\\\[b\\\\]': {x: 1}});\n   *\n   * @name deepNestedInclude\n   * @param {Object} haystack\n   * @param {Object} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.deepNestedInclude = function(exp, inc, msg) {\n    new Assertion(exp, msg, assert.deepNestedInclude, true)\n      .deep.nested.include(inc);\n  };\n\n  /**\n   * ### .notDeepNestedInclude(haystack, needle, [message])\n   *\n   * Asserts that 'haystack' does not include 'needle'.\n   * Can be used to assert the absence of a subset of properties in an\n   * object while checking for deep equality.\n   * Enables the use of dot- and bracket-notation for referencing nested\n   * properties.\n   * '[]' and '.' in property names can be escaped using double backslashes.\n   *\n   *     assert.notDeepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {y: 1}})\n   *     assert.notDeepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\\\.a.\\\\[b\\\\]': {y: 2}});\n   *\n   * @name notDeepNestedInclude\n   * @param {Object} haystack\n   * @param {Object} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notDeepNestedInclude = function(exp, inc, msg) {\n    new Assertion(exp, msg, assert.notDeepNestedInclude, true)\n      .not.deep.nested.include(inc);\n  };\n\n  /**\n   * ### .ownInclude(haystack, needle, [message])\n   *\n   * Asserts that 'haystack' includes 'needle'.\n   * Can be used to assert the inclusion of a subset of properties in an\n   * object while ignoring inherited properties.\n   *\n   *     assert.ownInclude({ a: 1 }, { a: 1 });\n   *\n   * @name ownInclude\n   * @param {Object} haystack\n   * @param {Object} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.ownInclude = function(exp, inc, msg) {\n    new Assertion(exp, msg, assert.ownInclude, true).own.include(inc);\n  };\n\n  /**\n   * ### .notOwnInclude(haystack, needle, [message])\n   *\n   * Asserts that 'haystack' includes 'needle'.\n   * Can be used to assert the absence of a subset of properties in an\n   * object while ignoring inherited properties.\n   *\n   *     Object.prototype.b = 2;\n   *\n   *     assert.notOwnInclude({ a: 1 }, { b: 2 });\n   *\n   * @name notOwnInclude\n   * @param {Object} haystack\n   * @param {Object} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notOwnInclude = function(exp, inc, msg) {\n    new Assertion(exp, msg, assert.notOwnInclude, true).not.own.include(inc);\n  };\n\n  /**\n   * ### .deepOwnInclude(haystack, needle, [message])\n   *\n   * Asserts that 'haystack' includes 'needle'.\n   * Can be used to assert the inclusion of a subset of properties in an\n   * object while ignoring inherited properties and checking for deep equality.\n   *\n   *      assert.deepOwnInclude({a: {b: 2}}, {a: {b: 2}});\n   *\n   * @name deepOwnInclude\n   * @param {Object} haystack\n   * @param {Object} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.deepOwnInclude = function(exp, inc, msg) {\n    new Assertion(exp, msg, assert.deepOwnInclude, true)\n      .deep.own.include(inc);\n  };\n\n   /**\n   * ### .notDeepOwnInclude(haystack, needle, [message])\n   *\n   * Asserts that 'haystack' includes 'needle'.\n   * Can be used to assert the absence of a subset of properties in an\n   * object while ignoring inherited properties and checking for deep equality.\n   *\n   *      assert.notDeepOwnInclude({a: {b: 2}}, {a: {c: 3}});\n   *\n   * @name notDeepOwnInclude\n   * @param {Object} haystack\n   * @param {Object} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notDeepOwnInclude = function(exp, inc, msg) {\n    new Assertion(exp, msg, assert.notDeepOwnInclude, true)\n      .not.deep.own.include(inc);\n  };\n\n  /**\n   * ### .match(value, regexp, [message])\n   *\n   * Asserts that `value` matches the regular expression `regexp`.\n   *\n   *     assert.match('foobar', /^foo/, 'regexp matches');\n   *\n   * @name match\n   * @param {Mixed} value\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.match = function (exp, re, msg) {\n    new Assertion(exp, msg, assert.match, true).to.match(re);\n  };\n\n  /**\n   * ### .notMatch(value, regexp, [message])\n   *\n   * Asserts that `value` does not match the regular expression `regexp`.\n   *\n   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');\n   *\n   * @name notMatch\n   * @param {Mixed} value\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notMatch = function (exp, re, msg) {\n    new Assertion(exp, msg, assert.notMatch, true).to.not.match(re);\n  };\n\n  /**\n   * ### .property(object, property, [message])\n   *\n   * Asserts that `object` has a direct or inherited property named by\n   * `property`.\n   *\n   *     assert.property({ tea: { green: 'matcha' }}, 'tea');\n   *     assert.property({ tea: { green: 'matcha' }}, 'toString');\n   *\n   * @name property\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.property = function (obj, prop, msg) {\n    new Assertion(obj, msg, assert.property, true).to.have.property(prop);\n  };\n\n  /**\n   * ### .notProperty(object, property, [message])\n   *\n   * Asserts that `object` does _not_ have a direct or inherited property named\n   * by `property`.\n   *\n   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');\n   *\n   * @name notProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg, assert.notProperty, true)\n      .to.not.have.property(prop);\n  };\n\n  /**\n   * ### .propertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a direct or inherited property named by\n   * `property` with a value given by `value`. Uses a strict equality check\n   * (===).\n   *\n   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');\n   *\n   * @name propertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.propertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg, assert.propertyVal, true)\n      .to.have.property(prop, val);\n  };\n\n  /**\n   * ### .notPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` does _not_ have a direct or inherited property named\n   * by `property` with value given by `value`. Uses a strict equality check\n   * (===).\n   *\n   *     assert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad');\n   *     assert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good');\n   *\n   * @name notPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg, assert.notPropertyVal, true)\n      .to.not.have.property(prop, val);\n  };\n\n  /**\n   * ### .deepPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a direct or inherited property named by\n   * `property` with a value given by `value`. Uses a deep equality check.\n   *\n   *     assert.deepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });\n   *\n   * @name deepPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.deepPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg, assert.deepPropertyVal, true)\n      .to.have.deep.property(prop, val);\n  };\n\n  /**\n   * ### .notDeepPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` does _not_ have a direct or inherited property named\n   * by `property` with value given by `value`. Uses a deep equality check.\n   *\n   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });\n   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });\n   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });\n   *\n   * @name notDeepPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notDeepPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg, assert.notDeepPropertyVal, true)\n      .to.not.have.deep.property(prop, val);\n  };\n\n  /**\n   * ### .ownProperty(object, property, [message])\n   *\n   * Asserts that `object` has a direct property named by `property`. Inherited\n   * properties aren't checked.\n   *\n   *     assert.ownProperty({ tea: { green: 'matcha' }}, 'tea');\n   *\n   * @name ownProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.ownProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg, assert.ownProperty, true)\n      .to.have.own.property(prop);\n  };\n\n  /**\n   * ### .notOwnProperty(object, property, [message])\n   *\n   * Asserts that `object` does _not_ have a direct property named by\n   * `property`. Inherited properties aren't checked.\n   *\n   *     assert.notOwnProperty({ tea: { green: 'matcha' }}, 'coffee');\n   *     assert.notOwnProperty({}, 'toString');\n   *\n   * @name notOwnProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notOwnProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg, assert.notOwnProperty, true)\n      .to.not.have.own.property(prop);\n  };\n\n  /**\n   * ### .ownPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a direct property named by `property` and a value\n   * equal to the provided `value`. Uses a strict equality check (===).\n   * Inherited properties aren't checked.\n   *\n   *     assert.ownPropertyVal({ coffee: 'is good'}, 'coffee', 'is good');\n   *\n   * @name ownPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.ownPropertyVal = function (obj, prop, value, msg) {\n    new Assertion(obj, msg, assert.ownPropertyVal, true)\n      .to.have.own.property(prop, value);\n  };\n\n  /**\n   * ### .notOwnPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` does _not_ have a direct property named by `property`\n   * with a value equal to the provided `value`. Uses a strict equality check\n   * (===). Inherited properties aren't checked.\n   *\n   *     assert.notOwnPropertyVal({ tea: 'is better'}, 'tea', 'is worse');\n   *     assert.notOwnPropertyVal({}, 'toString', Object.prototype.toString);\n   *\n   * @name notOwnPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notOwnPropertyVal = function (obj, prop, value, msg) {\n    new Assertion(obj, msg, assert.notOwnPropertyVal, true)\n      .to.not.have.own.property(prop, value);\n  };\n\n  /**\n   * ### .deepOwnPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a direct property named by `property` and a value\n   * equal to the provided `value`. Uses a deep equality check. Inherited\n   * properties aren't checked.\n   *\n   *     assert.deepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });\n   *\n   * @name deepOwnPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.deepOwnPropertyVal = function (obj, prop, value, msg) {\n    new Assertion(obj, msg, assert.deepOwnPropertyVal, true)\n      .to.have.deep.own.property(prop, value);\n  };\n\n  /**\n   * ### .notDeepOwnPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` does _not_ have a direct property named by `property`\n   * with a value equal to the provided `value`. Uses a deep equality check.\n   * Inherited properties aren't checked.\n   *\n   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });\n   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });\n   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });\n   *     assert.notDeepOwnPropertyVal({}, 'toString', Object.prototype.toString);\n   *\n   * @name notDeepOwnPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notDeepOwnPropertyVal = function (obj, prop, value, msg) {\n    new Assertion(obj, msg, assert.notDeepOwnPropertyVal, true)\n      .to.not.have.deep.own.property(prop, value);\n  };\n\n  /**\n   * ### .nestedProperty(object, property, [message])\n   *\n   * Asserts that `object` has a direct or inherited property named by\n   * `property`, which can be a string using dot- and bracket-notation for\n   * nested reference.\n   *\n   *     assert.nestedProperty({ tea: { green: 'matcha' }}, 'tea.green');\n   *\n   * @name nestedProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.nestedProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg, assert.nestedProperty, true)\n      .to.have.nested.property(prop);\n  };\n\n  /**\n   * ### .notNestedProperty(object, property, [message])\n   *\n   * Asserts that `object` does _not_ have a property named by `property`, which\n   * can be a string using dot- and bracket-notation for nested reference. The\n   * property cannot exist on the object nor anywhere in its prototype chain.\n   *\n   *     assert.notNestedProperty({ tea: { green: 'matcha' }}, 'tea.oolong');\n   *\n   * @name notNestedProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notNestedProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg, assert.notNestedProperty, true)\n      .to.not.have.nested.property(prop);\n  };\n\n  /**\n   * ### .nestedPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property` with value given\n   * by `value`. `property` can use dot- and bracket-notation for nested\n   * reference. Uses a strict equality check (===).\n   *\n   *     assert.nestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');\n   *\n   * @name nestedPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.nestedPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg, assert.nestedPropertyVal, true)\n      .to.have.nested.property(prop, val);\n  };\n\n  /**\n   * ### .notNestedPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` does _not_ have a property named by `property` with\n   * value given by `value`. `property` can use dot- and bracket-notation for\n   * nested reference. Uses a strict equality check (===).\n   *\n   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');\n   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'coffee.green', 'matcha');\n   *\n   * @name notNestedPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notNestedPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg, assert.notNestedPropertyVal, true)\n      .to.not.have.nested.property(prop, val);\n  };\n\n  /**\n   * ### .deepNestedPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property` with a value given\n   * by `value`. `property` can use dot- and bracket-notation for nested\n   * reference. Uses a deep equality check.\n   *\n   *     assert.deepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yum' });\n   *\n   * @name deepNestedPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.deepNestedPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg, assert.deepNestedPropertyVal, true)\n      .to.have.deep.nested.property(prop, val);\n  };\n\n  /**\n   * ### .notDeepNestedPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` does _not_ have a property named by `property` with\n   * value given by `value`. `property` can use dot- and bracket-notation for\n   * nested reference. Uses a deep equality check.\n   *\n   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { oolong: 'yum' });\n   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yuck' });\n   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.black', { matcha: 'yum' });\n   *\n   * @name notDeepNestedPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notDeepNestedPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg, assert.notDeepNestedPropertyVal, true)\n      .to.not.have.deep.nested.property(prop, val);\n  }\n\n  /**\n   * ### .lengthOf(object, length, [message])\n   *\n   * Asserts that `object` has a `length` or `size` with the expected value.\n   *\n   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');\n   *     assert.lengthOf('foobar', 6, 'string has length of 6');\n   *     assert.lengthOf(new Set([1,2,3]), 3, 'set has size of 3');\n   *     assert.lengthOf(new Map([['a',1],['b',2],['c',3]]), 3, 'map has size of 3');\n   *\n   * @name lengthOf\n   * @param {Mixed} object\n   * @param {Number} length\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.lengthOf = function (exp, len, msg) {\n    new Assertion(exp, msg, assert.lengthOf, true).to.have.lengthOf(len);\n  };\n\n  /**\n   * ### .hasAnyKeys(object, [keys], [message])\n   *\n   * Asserts that `object` has at least one of the `keys` provided.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'iDontExist', 'baz']);\n   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, iDontExist: 99, baz: 1337});\n   *     assert.hasAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);\n   *     assert.hasAnyKeys(new Set([{foo: 'bar'}, 'anotherKey']), [{foo: 'bar'}, 'anotherKey']);\n   *\n   * @name hasAnyKeys\n   * @param {Mixed} object\n   * @param {Array|Object} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.hasAnyKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.hasAnyKeys, true).to.have.any.keys(keys);\n  }\n\n  /**\n   * ### .hasAllKeys(object, [keys], [message])\n   *\n   * Asserts that `object` has all and only all of the `keys` provided.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);\n   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337]);\n   *     assert.hasAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);\n   *     assert.hasAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);\n   *\n   * @name hasAllKeys\n   * @param {Mixed} object\n   * @param {String[]} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.hasAllKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.hasAllKeys, true).to.have.all.keys(keys);\n  }\n\n  /**\n   * ### .containsAllKeys(object, [keys], [message])\n   *\n   * Asserts that `object` has all of the `keys` provided but may have more keys not listed.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'baz']);\n   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);\n   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, baz: 1337});\n   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337});\n   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}]);\n   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);\n   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}]);\n   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);\n   *\n   * @name containsAllKeys\n   * @param {Mixed} object\n   * @param {String[]} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.containsAllKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.containsAllKeys, true)\n      .to.contain.all.keys(keys);\n  }\n\n  /**\n   * ### .doesNotHaveAnyKeys(object, [keys], [message])\n   *\n   * Asserts that `object` has none of the `keys` provided.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);\n   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});\n   *     assert.doesNotHaveAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);\n   *     assert.doesNotHaveAnyKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);\n   *\n   * @name doesNotHaveAnyKeys\n   * @param {Mixed} object\n   * @param {String[]} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotHaveAnyKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.doesNotHaveAnyKeys, true)\n      .to.not.have.any.keys(keys);\n  }\n\n  /**\n   * ### .doesNotHaveAllKeys(object, [keys], [message])\n   *\n   * Asserts that `object` does not have at least one of the `keys` provided.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);\n   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});\n   *     assert.doesNotHaveAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);\n   *     assert.doesNotHaveAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);\n   *\n   * @name doesNotHaveAllKeys\n   * @param {Mixed} object\n   * @param {String[]} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotHaveAllKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.doesNotHaveAllKeys, true)\n      .to.not.have.all.keys(keys);\n  }\n\n  /**\n   * ### .hasAnyDeepKeys(object, [keys], [message])\n   *\n   * Asserts that `object` has at least one of the `keys` provided.\n   * Since Sets and Maps can have objects as keys you can use this assertion to perform\n   * a deep comparison.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});\n   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), [{one: 'one'}, {two: 'two'}]);\n   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);\n   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});\n   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {three: 'three'}]);\n   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);\n   *\n   * @name doesNotHaveAllKeys\n   * @param {Mixed} object\n   * @param {Array|Object} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.hasAnyDeepKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.hasAnyDeepKeys, true)\n      .to.have.any.deep.keys(keys);\n  }\n\n /**\n   * ### .hasAllDeepKeys(object, [keys], [message])\n   *\n   * Asserts that `object` has all and only all of the `keys` provided.\n   * Since Sets and Maps can have objects as keys you can use this assertion to perform\n   * a deep comparison.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne']]), {one: 'one'});\n   *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);\n   *     assert.hasAllDeepKeys(new Set([{one: 'one'}]), {one: 'one'});\n   *     assert.hasAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);\n   *\n   * @name hasAllDeepKeys\n   * @param {Mixed} object\n   * @param {Array|Object} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.hasAllDeepKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.hasAllDeepKeys, true)\n      .to.have.all.deep.keys(keys);\n  }\n\n /**\n   * ### .containsAllDeepKeys(object, [keys], [message])\n   *\n   * Asserts that `object` contains all of the `keys` provided.\n   * Since Sets and Maps can have objects as keys you can use this assertion to perform\n   * a deep comparison.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});\n   *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);\n   *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});\n   *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);\n   *\n   * @name containsAllDeepKeys\n   * @param {Mixed} object\n   * @param {Array|Object} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.containsAllDeepKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.containsAllDeepKeys, true)\n      .to.contain.all.deep.keys(keys);\n  }\n\n /**\n   * ### .doesNotHaveAnyDeepKeys(object, [keys], [message])\n   *\n   * Asserts that `object` has none of the `keys` provided.\n   * Since Sets and Maps can have objects as keys you can use this assertion to perform\n   * a deep comparison.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});\n   *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);\n   *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});\n   *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);\n   *\n   * @name doesNotHaveAnyDeepKeys\n   * @param {Mixed} object\n   * @param {Array|Object} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotHaveAnyDeepKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.doesNotHaveAnyDeepKeys, true)\n      .to.not.have.any.deep.keys(keys);\n  }\n\n /**\n   * ### .doesNotHaveAllDeepKeys(object, [keys], [message])\n   *\n   * Asserts that `object` does not have at least one of the `keys` provided.\n   * Since Sets and Maps can have objects as keys you can use this assertion to perform\n   * a deep comparison.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});\n   *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {one: 'one'}]);\n   *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});\n   *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {fifty: 'fifty'}]);\n   *\n   * @name doesNotHaveAllDeepKeys\n   * @param {Mixed} object\n   * @param {Array|Object} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotHaveAllDeepKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.doesNotHaveAllDeepKeys, true)\n      .to.not.have.all.deep.keys(keys);\n  }\n\n /**\n   * ### .throws(fn, [errorLike/string/regexp], [string/regexp], [message])\n   *\n   * If `errorLike` is an `Error` constructor, asserts that `fn` will throw an error that is an\n   * instance of `errorLike`.\n   * If `errorLike` is an `Error` instance, asserts that the error thrown is the same\n   * instance as `errorLike`.\n   * If `errMsgMatcher` is provided, it also asserts that the error thrown will have a\n   * message matching `errMsgMatcher`.\n   *\n   *     assert.throws(fn, 'Error thrown must have this msg');\n   *     assert.throws(fn, /Error thrown must have a msg that matches this/);\n   *     assert.throws(fn, ReferenceError);\n   *     assert.throws(fn, errorInstance);\n   *     assert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg');\n   *     assert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg');\n   *     assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/);\n   *     assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/);\n   *\n   * @name throws\n   * @alias throw\n   * @alias Throw\n   * @param {Function} fn\n   * @param {ErrorConstructor|Error} errorLike\n   * @param {RegExp|String} errMsgMatcher\n   * @param {String} message\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.throws = function (fn, errorLike, errMsgMatcher, msg) {\n    if ('string' === typeof errorLike || errorLike instanceof RegExp) {\n      errMsgMatcher = errorLike;\n      errorLike = null;\n    }\n\n    var assertErr = new Assertion(fn, msg, assert.throws, true)\n      .to.throw(errorLike, errMsgMatcher);\n    return flag(assertErr, 'object');\n  };\n\n  /**\n   * ### .doesNotThrow(fn, [errorLike/string/regexp], [string/regexp], [message])\n   *\n   * If `errorLike` is an `Error` constructor, asserts that `fn` will _not_ throw an error that is an\n   * instance of `errorLike`.\n   * If `errorLike` is an `Error` instance, asserts that the error thrown is _not_ the same\n   * instance as `errorLike`.\n   * If `errMsgMatcher` is provided, it also asserts that the error thrown will _not_ have a\n   * message matching `errMsgMatcher`.\n   *\n   *     assert.doesNotThrow(fn, 'Any Error thrown must not have this message');\n   *     assert.doesNotThrow(fn, /Any Error thrown must not match this/);\n   *     assert.doesNotThrow(fn, Error);\n   *     assert.doesNotThrow(fn, errorInstance);\n   *     assert.doesNotThrow(fn, Error, 'Error must not have this message');\n   *     assert.doesNotThrow(fn, errorInstance, 'Error must not have this message');\n   *     assert.doesNotThrow(fn, Error, /Error must not match this/);\n   *     assert.doesNotThrow(fn, errorInstance, /Error must not match this/);\n   *\n   * @name doesNotThrow\n   * @param {Function} fn\n   * @param {ErrorConstructor} errorLike\n   * @param {RegExp|String} errMsgMatcher\n   * @param {String} message\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotThrow = function (fn, errorLike, errMsgMatcher, msg) {\n    if ('string' === typeof errorLike || errorLike instanceof RegExp) {\n      errMsgMatcher = errorLike;\n      errorLike = null;\n    }\n\n    new Assertion(fn, msg, assert.doesNotThrow, true)\n      .to.not.throw(errorLike, errMsgMatcher);\n  };\n\n  /**\n   * ### .operator(val1, operator, val2, [message])\n   *\n   * Compares two values using `operator`.\n   *\n   *     assert.operator(1, '<', 2, 'everything is ok');\n   *     assert.operator(1, '>', 2, 'this will fail');\n   *\n   * @name operator\n   * @param {Mixed} val1\n   * @param {String} operator\n   * @param {Mixed} val2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.operator = function (val, operator, val2, msg) {\n    var ok;\n    switch(operator) {\n      case '==':\n        ok = val == val2;\n        break;\n      case '===':\n        ok = val === val2;\n        break;\n      case '>':\n        ok = val > val2;\n        break;\n      case '>=':\n        ok = val >= val2;\n        break;\n      case '<':\n        ok = val < val2;\n        break;\n      case '<=':\n        ok = val <= val2;\n        break;\n      case '!=':\n        ok = val != val2;\n        break;\n      case '!==':\n        ok = val !== val2;\n        break;\n      default:\n        msg = msg ? msg + ': ' : msg;\n        throw new chai.AssertionError(\n          msg + 'Invalid operator \"' + operator + '\"',\n          undefined,\n          assert.operator\n        );\n    }\n    var test = new Assertion(ok, msg, assert.operator, true);\n    test.assert(\n        true === flag(test, 'object')\n      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)\n      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );\n  };\n\n  /**\n   * ### .closeTo(actual, expected, delta, [message])\n   *\n   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n   *\n   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');\n   *\n   * @name closeTo\n   * @param {Number} actual\n   * @param {Number} expected\n   * @param {Number} delta\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.closeTo = function (act, exp, delta, msg) {\n    new Assertion(act, msg, assert.closeTo, true).to.be.closeTo(exp, delta);\n  };\n\n  /**\n   * ### .approximately(actual, expected, delta, [message])\n   *\n   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n   *\n   *     assert.approximately(1.5, 1, 0.5, 'numbers are close');\n   *\n   * @name approximately\n   * @param {Number} actual\n   * @param {Number} expected\n   * @param {Number} delta\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.approximately = function (act, exp, delta, msg) {\n    new Assertion(act, msg, assert.approximately, true)\n      .to.be.approximately(exp, delta);\n  };\n\n  /**\n   * ### .sameMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` have the same members in any order. Uses a\n   * strict equality check (===).\n   *\n   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');\n   *\n   * @name sameMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.sameMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg, assert.sameMembers, true)\n      .to.have.same.members(set2);\n  }\n\n  /**\n   * ### .notSameMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` don't have the same members in any order.\n   * Uses a strict equality check (===).\n   *\n   *     assert.notSameMembers([ 1, 2, 3 ], [ 5, 1, 3 ], 'not same members');\n   *\n   * @name notSameMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notSameMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg, assert.notSameMembers, true)\n      .to.not.have.same.members(set2);\n  }\n\n  /**\n   * ### .sameDeepMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` have the same members in any order. Uses a\n   * deep equality check.\n   *\n   *     assert.sameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members');\n   *\n   * @name sameDeepMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.sameDeepMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg, assert.sameDeepMembers, true)\n      .to.have.same.deep.members(set2);\n  }\n\n  /**\n   * ### .notSameDeepMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` don't have the same members in any order.\n   * Uses a deep equality check.\n   *\n   *     assert.notSameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { f: 5 }], 'not same deep members');\n   *\n   * @name notSameDeepMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notSameDeepMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg, assert.notSameDeepMembers, true)\n      .to.not.have.same.deep.members(set2);\n  }\n\n  /**\n   * ### .sameOrderedMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` have the same members in the same order.\n   * Uses a strict equality check (===).\n   *\n   *     assert.sameOrderedMembers([ 1, 2, 3 ], [ 1, 2, 3 ], 'same ordered members');\n   *\n   * @name sameOrderedMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.sameOrderedMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg, assert.sameOrderedMembers, true)\n      .to.have.same.ordered.members(set2);\n  }\n\n  /**\n   * ### .notSameOrderedMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` don't have the same members in the same\n   * order. Uses a strict equality check (===).\n   *\n   *     assert.notSameOrderedMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'not same ordered members');\n   *\n   * @name notSameOrderedMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notSameOrderedMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg, assert.notSameOrderedMembers, true)\n      .to.not.have.same.ordered.members(set2);\n  }\n\n  /**\n   * ### .sameDeepOrderedMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` have the same members in the same order.\n   * Uses a deep equality check.\n   *\n   * assert.sameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { c: 3 } ], 'same deep ordered members');\n   *\n   * @name sameDeepOrderedMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.sameDeepOrderedMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg, assert.sameDeepOrderedMembers, true)\n      .to.have.same.deep.ordered.members(set2);\n  }\n\n  /**\n   * ### .notSameDeepOrderedMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` don't have the same members in the same\n   * order. Uses a deep equality check.\n   *\n   * assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { z: 5 } ], 'not same deep ordered members');\n   * assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { c: 3 } ], 'not same deep ordered members');\n   *\n   * @name notSameDeepOrderedMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notSameDeepOrderedMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg, assert.notSameDeepOrderedMembers, true)\n      .to.not.have.same.deep.ordered.members(set2);\n  }\n\n  /**\n   * ### .includeMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` is included in `superset` in any order. Uses a\n   * strict equality check (===). Duplicates are ignored.\n   *\n   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1, 2 ], 'include members');\n   *\n   * @name includeMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.includeMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg, assert.includeMembers, true)\n      .to.include.members(subset);\n  }\n\n  /**\n   * ### .notIncludeMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` isn't included in `superset` in any order. Uses a\n   * strict equality check (===). Duplicates are ignored.\n   *\n   *     assert.notIncludeMembers([ 1, 2, 3 ], [ 5, 1 ], 'not include members');\n   *\n   * @name notIncludeMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notIncludeMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg, assert.notIncludeMembers, true)\n      .to.not.include.members(subset);\n  }\n\n  /**\n   * ### .includeDeepMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` is included in `superset` in any order. Uses a deep\n   * equality check. Duplicates are ignored.\n   *\n   *     assert.includeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { b: 2 } ], 'include deep members');\n   *\n   * @name includeDeepMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.includeDeepMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg, assert.includeDeepMembers, true)\n      .to.include.deep.members(subset);\n  }\n\n  /**\n   * ### .notIncludeDeepMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` isn't included in `superset` in any order. Uses a\n   * deep equality check. Duplicates are ignored.\n   *\n   *     assert.notIncludeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { f: 5 } ], 'not include deep members');\n   *\n   * @name notIncludeDeepMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notIncludeDeepMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg, assert.notIncludeDeepMembers, true)\n      .to.not.include.deep.members(subset);\n  }\n\n  /**\n   * ### .includeOrderedMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` is included in `superset` in the same order\n   * beginning with the first element in `superset`. Uses a strict equality\n   * check (===).\n   *\n   *     assert.includeOrderedMembers([ 1, 2, 3 ], [ 1, 2 ], 'include ordered members');\n   *\n   * @name includeOrderedMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.includeOrderedMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg, assert.includeOrderedMembers, true)\n      .to.include.ordered.members(subset);\n  }\n\n  /**\n   * ### .notIncludeOrderedMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` isn't included in `superset` in the same order\n   * beginning with the first element in `superset`. Uses a strict equality\n   * check (===).\n   *\n   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 1 ], 'not include ordered members');\n   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 3 ], 'not include ordered members');\n   *\n   * @name notIncludeOrderedMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notIncludeOrderedMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg, assert.notIncludeOrderedMembers, true)\n      .to.not.include.ordered.members(subset);\n  }\n\n  /**\n   * ### .includeDeepOrderedMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` is included in `superset` in the same order\n   * beginning with the first element in `superset`. Uses a deep equality\n   * check.\n   *\n   *     assert.includeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 } ], 'include deep ordered members');\n   *\n   * @name includeDeepOrderedMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.includeDeepOrderedMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg, assert.includeDeepOrderedMembers, true)\n      .to.include.deep.ordered.members(subset);\n  }\n\n  /**\n   * ### .notIncludeDeepOrderedMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` isn't included in `superset` in the same order\n   * beginning with the first element in `superset`. Uses a deep equality\n   * check.\n   *\n   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { f: 5 } ], 'not include deep ordered members');\n   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 } ], 'not include deep ordered members');\n   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { c: 3 } ], 'not include deep ordered members');\n   *\n   * @name notIncludeDeepOrderedMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notIncludeDeepOrderedMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg, assert.notIncludeDeepOrderedMembers, true)\n      .to.not.include.deep.ordered.members(subset);\n  }\n\n  /**\n   * ### .oneOf(inList, list, [message])\n   *\n   * Asserts that non-object, non-array value `inList` appears in the flat array `list`.\n   *\n   *     assert.oneOf(1, [ 2, 1 ], 'Not found in list');\n   *\n   * @name oneOf\n   * @param {*} inList\n   * @param {Array<*>} list\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.oneOf = function (inList, list, msg) {\n    new Assertion(inList, msg, assert.oneOf, true).to.be.oneOf(list);\n  }\n\n  /**\n   * ### .changes(function, object, property, [message])\n   *\n   * Asserts that a function changes the value of a property.\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 22 };\n   *     assert.changes(fn, obj, 'val');\n   *\n   * @name changes\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.changes = function (fn, obj, prop, msg) {\n    if (arguments.length === 3 && typeof obj === 'function') {\n      msg = prop;\n      prop = null;\n    }\n\n    new Assertion(fn, msg, assert.changes, true).to.change(obj, prop);\n  }\n\n   /**\n   * ### .changesBy(function, object, property, delta, [message])\n   *\n   * Asserts that a function changes the value of a property by an amount (delta).\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val += 2 };\n   *     assert.changesBy(fn, obj, 'val', 2);\n   *\n   * @name changesBy\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {Number} change amount (delta)\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.changesBy = function (fn, obj, prop, delta, msg) {\n    if (arguments.length === 4 && typeof obj === 'function') {\n      var tmpMsg = delta;\n      delta = prop;\n      msg = tmpMsg;\n    } else if (arguments.length === 3) {\n      delta = prop;\n      prop = null;\n    }\n\n    new Assertion(fn, msg, assert.changesBy, true)\n      .to.change(obj, prop).by(delta);\n  }\n\n   /**\n   * ### .doesNotChange(function, object, property, [message])\n   *\n   * Asserts that a function does not change the value of a property.\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { console.log('foo'); };\n   *     assert.doesNotChange(fn, obj, 'val');\n   *\n   * @name doesNotChange\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotChange = function (fn, obj, prop, msg) {\n    if (arguments.length === 3 && typeof obj === 'function') {\n      msg = prop;\n      prop = null;\n    }\n\n    return new Assertion(fn, msg, assert.doesNotChange, true)\n      .to.not.change(obj, prop);\n  }\n\n  /**\n   * ### .changesButNotBy(function, object, property, delta, [message])\n   *\n   * Asserts that a function does not change the value of a property or of a function's return value by an amount (delta)\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val += 10 };\n   *     assert.changesButNotBy(fn, obj, 'val', 5);\n   *\n   * @name changesButNotBy\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {Number} change amount (delta)\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.changesButNotBy = function (fn, obj, prop, delta, msg) {\n    if (arguments.length === 4 && typeof obj === 'function') {\n      var tmpMsg = delta;\n      delta = prop;\n      msg = tmpMsg;\n    } else if (arguments.length === 3) {\n      delta = prop;\n      prop = null;\n    }\n\n    new Assertion(fn, msg, assert.changesButNotBy, true)\n      .to.change(obj, prop).but.not.by(delta);\n  }\n\n  /**\n   * ### .increases(function, object, property, [message])\n   *\n   * Asserts that a function increases a numeric object property.\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 13 };\n   *     assert.increases(fn, obj, 'val');\n   *\n   * @name increases\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.increases = function (fn, obj, prop, msg) {\n    if (arguments.length === 3 && typeof obj === 'function') {\n      msg = prop;\n      prop = null;\n    }\n\n    return new Assertion(fn, msg, assert.increases, true)\n      .to.increase(obj, prop);\n  }\n\n  /**\n   * ### .increasesBy(function, object, property, delta, [message])\n   *\n   * Asserts that a function increases a numeric object property or a function's return value by an amount (delta).\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val += 10 };\n   *     assert.increasesBy(fn, obj, 'val', 10);\n   *\n   * @name increasesBy\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {Number} change amount (delta)\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.increasesBy = function (fn, obj, prop, delta, msg) {\n    if (arguments.length === 4 && typeof obj === 'function') {\n      var tmpMsg = delta;\n      delta = prop;\n      msg = tmpMsg;\n    } else if (arguments.length === 3) {\n      delta = prop;\n      prop = null;\n    }\n\n    new Assertion(fn, msg, assert.increasesBy, true)\n      .to.increase(obj, prop).by(delta);\n  }\n\n  /**\n   * ### .doesNotIncrease(function, object, property, [message])\n   *\n   * Asserts that a function does not increase a numeric object property.\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 8 };\n   *     assert.doesNotIncrease(fn, obj, 'val');\n   *\n   * @name doesNotIncrease\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotIncrease = function (fn, obj, prop, msg) {\n    if (arguments.length === 3 && typeof obj === 'function') {\n      msg = prop;\n      prop = null;\n    }\n\n    return new Assertion(fn, msg, assert.doesNotIncrease, true)\n      .to.not.increase(obj, prop);\n  }\n\n  /**\n   * ### .increasesButNotBy(function, object, property, [message])\n   *\n   * Asserts that a function does not increase a numeric object property or function's return value by an amount (delta).\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 15 };\n   *     assert.increasesButNotBy(fn, obj, 'val', 10);\n   *\n   * @name increasesButNotBy\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {Number} change amount (delta)\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.increasesButNotBy = function (fn, obj, prop, delta, msg) {\n    if (arguments.length === 4 && typeof obj === 'function') {\n      var tmpMsg = delta;\n      delta = prop;\n      msg = tmpMsg;\n    } else if (arguments.length === 3) {\n      delta = prop;\n      prop = null;\n    }\n\n    new Assertion(fn, msg, assert.increasesButNotBy, true)\n      .to.increase(obj, prop).but.not.by(delta);\n  }\n\n  /**\n   * ### .decreases(function, object, property, [message])\n   *\n   * Asserts that a function decreases a numeric object property.\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 5 };\n   *     assert.decreases(fn, obj, 'val');\n   *\n   * @name decreases\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.decreases = function (fn, obj, prop, msg) {\n    if (arguments.length === 3 && typeof obj === 'function') {\n      msg = prop;\n      prop = null;\n    }\n\n    return new Assertion(fn, msg, assert.decreases, true)\n      .to.decrease(obj, prop);\n  }\n\n  /**\n   * ### .decreasesBy(function, object, property, delta, [message])\n   *\n   * Asserts that a function decreases a numeric object property or a function's return value by an amount (delta)\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val -= 5 };\n   *     assert.decreasesBy(fn, obj, 'val', 5);\n   *\n   * @name decreasesBy\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {Number} change amount (delta)\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.decreasesBy = function (fn, obj, prop, delta, msg) {\n    if (arguments.length === 4 && typeof obj === 'function') {\n      var tmpMsg = delta;\n      delta = prop;\n      msg = tmpMsg;\n    } else if (arguments.length === 3) {\n      delta = prop;\n      prop = null;\n    }\n\n    new Assertion(fn, msg, assert.decreasesBy, true)\n      .to.decrease(obj, prop).by(delta);\n  }\n\n  /**\n   * ### .doesNotDecrease(function, object, property, [message])\n   *\n   * Asserts that a function does not decreases a numeric object property.\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 15 };\n   *     assert.doesNotDecrease(fn, obj, 'val');\n   *\n   * @name doesNotDecrease\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotDecrease = function (fn, obj, prop, msg) {\n    if (arguments.length === 3 && typeof obj === 'function') {\n      msg = prop;\n      prop = null;\n    }\n\n    return new Assertion(fn, msg, assert.doesNotDecrease, true)\n      .to.not.decrease(obj, prop);\n  }\n\n  /**\n   * ### .doesNotDecreaseBy(function, object, property, delta, [message])\n   *\n   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 5 };\n   *     assert.doesNotDecreaseBy(fn, obj, 'val', 1);\n   *\n   * @name doesNotDecrease\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {Number} change amount (delta)\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotDecreaseBy = function (fn, obj, prop, delta, msg) {\n    if (arguments.length === 4 && typeof obj === 'function') {\n      var tmpMsg = delta;\n      delta = prop;\n      msg = tmpMsg;\n    } else if (arguments.length === 3) {\n      delta = prop;\n      prop = null;\n    }\n\n    return new Assertion(fn, msg, assert.doesNotDecreaseBy, true)\n      .to.not.decrease(obj, prop).by(delta);\n  }\n\n  /**\n   * ### .decreasesButNotBy(function, object, property, delta, [message])\n   *\n   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 5 };\n   *     assert.decreasesButNotBy(fn, obj, 'val', 1);\n   *\n   * @name decreasesButNotBy\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {Number} change amount (delta)\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.decreasesButNotBy = function (fn, obj, prop, delta, msg) {\n    if (arguments.length === 4 && typeof obj === 'function') {\n      var tmpMsg = delta;\n      delta = prop;\n      msg = tmpMsg;\n    } else if (arguments.length === 3) {\n      delta = prop;\n      prop = null;\n    }\n\n    new Assertion(fn, msg, assert.decreasesButNotBy, true)\n      .to.decrease(obj, prop).but.not.by(delta);\n  }\n\n  /*!\n   * ### .ifError(object)\n   *\n   * Asserts if value is not a false value, and throws if it is a true value.\n   * This is added to allow for chai to be a drop-in replacement for Node's\n   * assert class.\n   *\n   *     var err = new Error('I am a custom error');\n   *     assert.ifError(err); // Rethrows err!\n   *\n   * @name ifError\n   * @param {Object} object\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.ifError = function (val) {\n    if (val) {\n      throw(val);\n    }\n  };\n\n  /**\n   * ### .isExtensible(object)\n   *\n   * Asserts that `object` is extensible (can have new properties added to it).\n   *\n   *     assert.isExtensible({});\n   *\n   * @name isExtensible\n   * @alias extensible\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isExtensible = function (obj, msg) {\n    new Assertion(obj, msg, assert.isExtensible, true).to.be.extensible;\n  };\n\n  /**\n   * ### .isNotExtensible(object)\n   *\n   * Asserts that `object` is _not_ extensible.\n   *\n   *     var nonExtensibleObject = Object.preventExtensions({});\n   *     var sealedObject = Object.seal({});\n   *     var frozenObject = Object.freeze({});\n   *\n   *     assert.isNotExtensible(nonExtensibleObject);\n   *     assert.isNotExtensible(sealedObject);\n   *     assert.isNotExtensible(frozenObject);\n   *\n   * @name isNotExtensible\n   * @alias notExtensible\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotExtensible = function (obj, msg) {\n    new Assertion(obj, msg, assert.isNotExtensible, true).to.not.be.extensible;\n  };\n\n  /**\n   * ### .isSealed(object)\n   *\n   * Asserts that `object` is sealed (cannot have new properties added to it\n   * and its existing properties cannot be removed).\n   *\n   *     var sealedObject = Object.seal({});\n   *     var frozenObject = Object.seal({});\n   *\n   *     assert.isSealed(sealedObject);\n   *     assert.isSealed(frozenObject);\n   *\n   * @name isSealed\n   * @alias sealed\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isSealed = function (obj, msg) {\n    new Assertion(obj, msg, assert.isSealed, true).to.be.sealed;\n  };\n\n  /**\n   * ### .isNotSealed(object)\n   *\n   * Asserts that `object` is _not_ sealed.\n   *\n   *     assert.isNotSealed({});\n   *\n   * @name isNotSealed\n   * @alias notSealed\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotSealed = function (obj, msg) {\n    new Assertion(obj, msg, assert.isNotSealed, true).to.not.be.sealed;\n  };\n\n  /**\n   * ### .isFrozen(object)\n   *\n   * Asserts that `object` is frozen (cannot have new properties added to it\n   * and its existing properties cannot be modified).\n   *\n   *     var frozenObject = Object.freeze({});\n   *     assert.frozen(frozenObject);\n   *\n   * @name isFrozen\n   * @alias frozen\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isFrozen = function (obj, msg) {\n    new Assertion(obj, msg, assert.isFrozen, true).to.be.frozen;\n  };\n\n  /**\n   * ### .isNotFrozen(object)\n   *\n   * Asserts that `object` is _not_ frozen.\n   *\n   *     assert.isNotFrozen({});\n   *\n   * @name isNotFrozen\n   * @alias notFrozen\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotFrozen = function (obj, msg) {\n    new Assertion(obj, msg, assert.isNotFrozen, true).to.not.be.frozen;\n  };\n\n  /**\n   * ### .isEmpty(target)\n   *\n   * Asserts that the target does not contain any values.\n   * For arrays and strings, it checks the `length` property.\n   * For `Map` and `Set` instances, it checks the `size` property.\n   * For non-function objects, it gets the count of own\n   * enumerable string keys.\n   *\n   *     assert.isEmpty([]);\n   *     assert.isEmpty('');\n   *     assert.isEmpty(new Map);\n   *     assert.isEmpty({});\n   *\n   * @name isEmpty\n   * @alias empty\n   * @param {Object|Array|String|Map|Set} target\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isEmpty = function(val, msg) {\n    new Assertion(val, msg, assert.isEmpty, true).to.be.empty;\n  };\n\n  /**\n   * ### .isNotEmpty(target)\n   *\n   * Asserts that the target contains values.\n   * For arrays and strings, it checks the `length` property.\n   * For `Map` and `Set` instances, it checks the `size` property.\n   * For non-function objects, it gets the count of own\n   * enumerable string keys.\n   *\n   *     assert.isNotEmpty([1, 2]);\n   *     assert.isNotEmpty('34');\n   *     assert.isNotEmpty(new Set([5, 6]));\n   *     assert.isNotEmpty({ key: 7 });\n   *\n   * @name isNotEmpty\n   * @alias notEmpty\n   * @param {Object|Array|String|Map|Set} target\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotEmpty = function(val, msg) {\n    new Assertion(val, msg, assert.isNotEmpty, true).to.not.be.empty;\n  };\n\n  /*!\n   * Aliases.\n   */\n\n  (function alias(name, as){\n    assert[as] = assert[name];\n    return alias;\n  })\n  ('isOk', 'ok')\n  ('isNotOk', 'notOk')\n  ('throws', 'throw')\n  ('throws', 'Throw')\n  ('isExtensible', 'extensible')\n  ('isNotExtensible', 'notExtensible')\n  ('isSealed', 'sealed')\n  ('isNotSealed', 'notSealed')\n  ('isFrozen', 'frozen')\n  ('isNotFrozen', 'notFrozen')\n  ('isEmpty', 'empty')\n  ('isNotEmpty', 'notEmpty');\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/interface/assert.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/interface/expect.js":
/*!*********************************************************!*\
  !*** ../node_modules/chai/lib/chai/interface/expect.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, util) {\n  chai.expect = function (val, message) {\n    return new chai.Assertion(val, message);\n  };\n\n  /**\n   * ### .fail([message])\n   * ### .fail(actual, expected, [message], [operator])\n   *\n   * Throw a failure.\n   *\n   *     expect.fail();\n   *     expect.fail(\"custom error message\");\n   *     expect.fail(1, 2);\n   *     expect.fail(1, 2, \"custom error message\");\n   *     expect.fail(1, 2, \"custom error message\", \">\");\n   *     expect.fail(1, 2, undefined, \">\");\n   *\n   * @name fail\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @param {String} operator\n   * @namespace BDD\n   * @api public\n   */\n\n  chai.expect.fail = function (actual, expected, message, operator) {\n    if (arguments.length < 2) {\n        message = actual;\n        actual = undefined;\n    }\n\n    message = message || 'expect.fail()';\n    throw new chai.AssertionError(message, {\n        actual: actual\n      , expected: expected\n      , operator: operator\n    }, chai.expect.fail);\n  };\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/interface/expect.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/interface/should.js":
/*!*********************************************************!*\
  !*** ../node_modules/chai/lib/chai/interface/should.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, util) {\n  var Assertion = chai.Assertion;\n\n  function loadShould () {\n    // explicitly define this method as function as to have it's name to include as `ssfi`\n    function shouldGetter() {\n      if (this instanceof String\n          || this instanceof Number\n          || this instanceof Boolean\n          || typeof Symbol === 'function' && this instanceof Symbol) {\n        return new Assertion(this.valueOf(), null, shouldGetter);\n      }\n      return new Assertion(this, null, shouldGetter);\n    }\n    function shouldSetter(value) {\n      // See https://github.com/chaijs/chai/issues/86: this makes\n      // `whatever.should = someValue` actually set `someValue`, which is\n      // especially useful for `global.should = require('chai').should()`.\n      //\n      // Note that we have to use [[DefineProperty]] instead of [[Put]]\n      // since otherwise we would trigger this very setter!\n      Object.defineProperty(this, 'should', {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    }\n    // modify Object.prototype to have `should`\n    Object.defineProperty(Object.prototype, 'should', {\n      set: shouldSetter\n      , get: shouldGetter\n      , configurable: true\n    });\n\n    var should = {};\n\n    /**\n     * ### .fail([message])\n     * ### .fail(actual, expected, [message], [operator])\n     *\n     * Throw a failure.\n     *\n     *     should.fail();\n     *     should.fail(\"custom error message\");\n     *     should.fail(1, 2);\n     *     should.fail(1, 2, \"custom error message\");\n     *     should.fail(1, 2, \"custom error message\", \">\");\n     *     should.fail(1, 2, undefined, \">\");\n     *\n     *\n     * @name fail\n     * @param {Mixed} actual\n     * @param {Mixed} expected\n     * @param {String} message\n     * @param {String} operator\n     * @namespace BDD\n     * @api public\n     */\n\n    should.fail = function (actual, expected, message, operator) {\n      if (arguments.length < 2) {\n          message = actual;\n          actual = undefined;\n      }\n\n      message = message || 'should.fail()';\n      throw new chai.AssertionError(message, {\n          actual: actual\n        , expected: expected\n        , operator: operator\n      }, should.fail);\n    };\n\n    /**\n     * ### .equal(actual, expected, [message])\n     *\n     * Asserts non-strict equality (`==`) of `actual` and `expected`.\n     *\n     *     should.equal(3, '3', '== coerces values to strings');\n     *\n     * @name equal\n     * @param {Mixed} actual\n     * @param {Mixed} expected\n     * @param {String} message\n     * @namespace Should\n     * @api public\n     */\n\n    should.equal = function (val1, val2, msg) {\n      new Assertion(val1, msg).to.equal(val2);\n    };\n\n    /**\n     * ### .throw(function, [constructor/string/regexp], [string/regexp], [message])\n     *\n     * Asserts that `function` will throw an error that is an instance of\n     * `constructor`, or alternately that it will throw an error with message\n     * matching `regexp`.\n     *\n     *     should.throw(fn, 'function throws a reference error');\n     *     should.throw(fn, /function throws a reference error/);\n     *     should.throw(fn, ReferenceError);\n     *     should.throw(fn, ReferenceError, 'function throws a reference error');\n     *     should.throw(fn, ReferenceError, /function throws a reference error/);\n     *\n     * @name throw\n     * @alias Throw\n     * @param {Function} function\n     * @param {ErrorConstructor} constructor\n     * @param {RegExp} regexp\n     * @param {String} message\n     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n     * @namespace Should\n     * @api public\n     */\n\n    should.Throw = function (fn, errt, errs, msg) {\n      new Assertion(fn, msg).to.Throw(errt, errs);\n    };\n\n    /**\n     * ### .exist\n     *\n     * Asserts that the target is neither `null` nor `undefined`.\n     *\n     *     var foo = 'hi';\n     *\n     *     should.exist(foo, 'foo exists');\n     *\n     * @name exist\n     * @namespace Should\n     * @api public\n     */\n\n    should.exist = function (val, msg) {\n      new Assertion(val, msg).to.exist;\n    }\n\n    // negation\n    should.not = {}\n\n    /**\n     * ### .not.equal(actual, expected, [message])\n     *\n     * Asserts non-strict inequality (`!=`) of `actual` and `expected`.\n     *\n     *     should.not.equal(3, 4, 'these numbers are not equal');\n     *\n     * @name not.equal\n     * @param {Mixed} actual\n     * @param {Mixed} expected\n     * @param {String} message\n     * @namespace Should\n     * @api public\n     */\n\n    should.not.equal = function (val1, val2, msg) {\n      new Assertion(val1, msg).to.not.equal(val2);\n    };\n\n    /**\n     * ### .throw(function, [constructor/regexp], [message])\n     *\n     * Asserts that `function` will _not_ throw an error that is an instance of\n     * `constructor`, or alternately that it will not throw an error with message\n     * matching `regexp`.\n     *\n     *     should.not.throw(fn, Error, 'function does not throw');\n     *\n     * @name not.throw\n     * @alias not.Throw\n     * @param {Function} function\n     * @param {ErrorConstructor} constructor\n     * @param {RegExp} regexp\n     * @param {String} message\n     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n     * @namespace Should\n     * @api public\n     */\n\n    should.not.Throw = function (fn, errt, errs, msg) {\n      new Assertion(fn, msg).to.not.Throw(errt, errs);\n    };\n\n    /**\n     * ### .not.exist\n     *\n     * Asserts that the target is neither `null` nor `undefined`.\n     *\n     *     var bar = null;\n     *\n     *     should.not.exist(bar, 'bar does not exist');\n     *\n     * @name not.exist\n     * @namespace Should\n     * @api public\n     */\n\n    should.not.exist = function (val, msg) {\n      new Assertion(val, msg).to.not.exist;\n    }\n\n    should['throw'] = should['Throw'];\n    should.not['throw'] = should.not['Throw'];\n\n    return should;\n  };\n\n  chai.should = loadShould;\n  chai.Should = loadShould;\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/interface/should.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/addChainableMethod.js":
/*!*****************************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/addChainableMethod.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - addChainingMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar addLengthGuard = __webpack_require__(/*! ./addLengthGuard */ \"../node_modules/chai/lib/chai/utils/addLengthGuard.js\");\nvar chai = __webpack_require__(/*! ../../chai */ \"../node_modules/chai/lib/chai.js\");\nvar flag = __webpack_require__(/*! ./flag */ \"../node_modules/chai/lib/chai/utils/flag.js\");\nvar proxify = __webpack_require__(/*! ./proxify */ \"../node_modules/chai/lib/chai/utils/proxify.js\");\nvar transferFlags = __webpack_require__(/*! ./transferFlags */ \"../node_modules/chai/lib/chai/utils/transferFlags.js\");\n\n/*!\n * Module variables\n */\n\n// Check whether `Object.setPrototypeOf` is supported\nvar canSetPrototype = typeof Object.setPrototypeOf === 'function';\n\n// Without `Object.setPrototypeOf` support, this module will need to add properties to a function.\n// However, some of functions' own props are not configurable and should be skipped.\nvar testFn = function() {};\nvar excludeNames = Object.getOwnPropertyNames(testFn).filter(function(name) {\n  var propDesc = Object.getOwnPropertyDescriptor(testFn, name);\n\n  // Note: PhantomJS 1.x includes `callee` as one of `testFn`'s own properties,\n  // but then returns `undefined` as the property descriptor for `callee`. As a\n  // workaround, we perform an otherwise unnecessary type-check for `propDesc`,\n  // and then filter it out if it's not an object as it should be.\n  if (typeof propDesc !== 'object')\n    return true;\n\n  return !propDesc.configurable;\n});\n\n// Cache `Function` properties\nvar call  = Function.prototype.call,\n    apply = Function.prototype.apply;\n\n/**\n * ### .addChainableMethod(ctx, name, method, chainingBehavior)\n *\n * Adds a method to an object, such that the method can also be chained.\n *\n *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {\n *       var obj = utils.flag(this, 'object');\n *       new chai.Assertion(obj).to.be.equal(str);\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);\n *\n * The result can then be used as both a method assertion, executing both `method` and\n * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.\n *\n *     expect(fooStr).to.be.foo('bar');\n *     expect(fooStr).to.be.foo.equal('foo');\n *\n * @param {Object} ctx object to which the method is added\n * @param {String} name of method to add\n * @param {Function} method function to be used for `name`, when called\n * @param {Function} chainingBehavior function to be called every time the property is accessed\n * @namespace Utils\n * @name addChainableMethod\n * @api public\n */\n\nmodule.exports = function addChainableMethod(ctx, name, method, chainingBehavior) {\n  if (typeof chainingBehavior !== 'function') {\n    chainingBehavior = function () { };\n  }\n\n  var chainableBehavior = {\n      method: method\n    , chainingBehavior: chainingBehavior\n  };\n\n  // save the methods so we can overwrite them later, if we need to.\n  if (!ctx.__methods) {\n    ctx.__methods = {};\n  }\n  ctx.__methods[name] = chainableBehavior;\n\n  Object.defineProperty(ctx, name,\n    { get: function chainableMethodGetter() {\n        chainableBehavior.chainingBehavior.call(this);\n\n        var chainableMethodWrapper = function () {\n          // Setting the `ssfi` flag to `chainableMethodWrapper` causes this\n          // function to be the starting point for removing implementation\n          // frames from the stack trace of a failed assertion.\n          //\n          // However, we only want to use this function as the starting point if\n          // the `lockSsfi` flag isn't set.\n          //\n          // If the `lockSsfi` flag is set, then this assertion is being\n          // invoked from inside of another assertion. In this case, the `ssfi`\n          // flag has already been set by the outer assertion.\n          //\n          // Note that overwriting a chainable method merely replaces the saved\n          // methods in `ctx.__methods` instead of completely replacing the\n          // overwritten assertion. Therefore, an overwriting assertion won't\n          // set the `ssfi` or `lockSsfi` flags.\n          if (!flag(this, 'lockSsfi')) {\n            flag(this, 'ssfi', chainableMethodWrapper);\n          }\n\n          var result = chainableBehavior.method.apply(this, arguments);\n          if (result !== undefined) {\n            return result;\n          }\n\n          var newAssertion = new chai.Assertion();\n          transferFlags(this, newAssertion);\n          return newAssertion;\n        };\n\n        addLengthGuard(chainableMethodWrapper, name, true);\n\n        // Use `Object.setPrototypeOf` if available\n        if (canSetPrototype) {\n          // Inherit all properties from the object by replacing the `Function` prototype\n          var prototype = Object.create(this);\n          // Restore the `call` and `apply` methods from `Function`\n          prototype.call = call;\n          prototype.apply = apply;\n          Object.setPrototypeOf(chainableMethodWrapper, prototype);\n        }\n        // Otherwise, redefine all properties (slow!)\n        else {\n          var asserterNames = Object.getOwnPropertyNames(ctx);\n          asserterNames.forEach(function (asserterName) {\n            if (excludeNames.indexOf(asserterName) !== -1) {\n              return;\n            }\n\n            var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);\n            Object.defineProperty(chainableMethodWrapper, asserterName, pd);\n          });\n        }\n\n        transferFlags(this, chainableMethodWrapper);\n        return proxify(chainableMethodWrapper);\n      }\n    , configurable: true\n  });\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/utils/addChainableMethod.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/addLengthGuard.js":
/*!*************************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/addLengthGuard.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var fnLengthDesc = Object.getOwnPropertyDescriptor(function () {}, 'length');\n\n/*!\n * Chai - addLengthGuard utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .addLengthGuard(fn, assertionName, isChainable)\n *\n * Define `length` as a getter on the given uninvoked method assertion. The\n * getter acts as a guard against chaining `length` directly off of an uninvoked\n * method assertion, which is a problem because it references `function`'s\n * built-in `length` property instead of Chai's `length` assertion. When the\n * getter catches the user making this mistake, it throws an error with a\n * helpful message.\n *\n * There are two ways in which this mistake can be made. The first way is by\n * chaining the `length` assertion directly off of an uninvoked chainable\n * method. In this case, Chai suggests that the user use `lengthOf` instead. The\n * second way is by chaining the `length` assertion directly off of an uninvoked\n * non-chainable method. Non-chainable methods must be invoked prior to\n * chaining. In this case, Chai suggests that the user consult the docs for the\n * given assertion.\n *\n * If the `length` property of functions is unconfigurable, then return `fn`\n * without modification.\n *\n * Note that in ES6, the function's `length` property is configurable, so once\n * support for legacy environments is dropped, Chai's `length` property can\n * replace the built-in function's `length` property, and this length guard will\n * no longer be necessary. In the mean time, maintaining consistency across all\n * environments is the priority.\n *\n * @param {Function} fn\n * @param {String} assertionName\n * @param {Boolean} isChainable\n * @namespace Utils\n * @name addLengthGuard\n */\n\nmodule.exports = function addLengthGuard (fn, assertionName, isChainable) {\n  if (!fnLengthDesc.configurable) return fn;\n\n  Object.defineProperty(fn, 'length', {\n    get: function () {\n      if (isChainable) {\n        throw Error('Invalid Chai property: ' + assertionName + '.length. Due' +\n          ' to a compatibility issue, \"length\" cannot directly follow \"' +\n          assertionName + '\". Use \"' + assertionName + '.lengthOf\" instead.');\n      }\n\n      throw Error('Invalid Chai property: ' + assertionName + '.length. See' +\n        ' docs for proper usage of \"' + assertionName + '\".');\n    }\n  });\n\n  return fn;\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/utils/addLengthGuard.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/addMethod.js":
/*!********************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/addMethod.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - addMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar addLengthGuard = __webpack_require__(/*! ./addLengthGuard */ \"../node_modules/chai/lib/chai/utils/addLengthGuard.js\");\nvar chai = __webpack_require__(/*! ../../chai */ \"../node_modules/chai/lib/chai.js\");\nvar flag = __webpack_require__(/*! ./flag */ \"../node_modules/chai/lib/chai/utils/flag.js\");\nvar proxify = __webpack_require__(/*! ./proxify */ \"../node_modules/chai/lib/chai/utils/proxify.js\");\nvar transferFlags = __webpack_require__(/*! ./transferFlags */ \"../node_modules/chai/lib/chai/utils/transferFlags.js\");\n\n/**\n * ### .addMethod(ctx, name, method)\n *\n * Adds a method to the prototype of an object.\n *\n *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {\n *       var obj = utils.flag(this, 'object');\n *       new chai.Assertion(obj).to.be.equal(str);\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.addMethod('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(fooStr).to.be.foo('bar');\n *\n * @param {Object} ctx object to which the method is added\n * @param {String} name of method to add\n * @param {Function} method function to be used for name\n * @namespace Utils\n * @name addMethod\n * @api public\n */\n\nmodule.exports = function addMethod(ctx, name, method) {\n  var methodWrapper = function () {\n    // Setting the `ssfi` flag to `methodWrapper` causes this function to be the\n    // starting point for removing implementation frames from the stack trace of\n    // a failed assertion.\n    //\n    // However, we only want to use this function as the starting point if the\n    // `lockSsfi` flag isn't set.\n    //\n    // If the `lockSsfi` flag is set, then either this assertion has been\n    // overwritten by another assertion, or this assertion is being invoked from\n    // inside of another assertion. In the first case, the `ssfi` flag has\n    // already been set by the overwriting assertion. In the second case, the\n    // `ssfi` flag has already been set by the outer assertion.\n    if (!flag(this, 'lockSsfi')) {\n      flag(this, 'ssfi', methodWrapper);\n    }\n\n    var result = method.apply(this, arguments);\n    if (result !== undefined)\n      return result;\n\n    var newAssertion = new chai.Assertion();\n    transferFlags(this, newAssertion);\n    return newAssertion;\n  };\n\n  addLengthGuard(methodWrapper, name, false);\n  ctx[name] = proxify(methodWrapper, name);\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/utils/addMethod.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/addProperty.js":
/*!**********************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/addProperty.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - addProperty utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar chai = __webpack_require__(/*! ../../chai */ \"../node_modules/chai/lib/chai.js\");\nvar flag = __webpack_require__(/*! ./flag */ \"../node_modules/chai/lib/chai/utils/flag.js\");\nvar isProxyEnabled = __webpack_require__(/*! ./isProxyEnabled */ \"../node_modules/chai/lib/chai/utils/isProxyEnabled.js\");\nvar transferFlags = __webpack_require__(/*! ./transferFlags */ \"../node_modules/chai/lib/chai/utils/transferFlags.js\");\n\n/**\n * ### .addProperty(ctx, name, getter)\n *\n * Adds a property to the prototype of an object.\n *\n *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {\n *       var obj = utils.flag(this, 'object');\n *       new chai.Assertion(obj).to.be.instanceof(Foo);\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.addProperty('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.be.foo;\n *\n * @param {Object} ctx object to which the property is added\n * @param {String} name of property to add\n * @param {Function} getter function to be used for name\n * @namespace Utils\n * @name addProperty\n * @api public\n */\n\nmodule.exports = function addProperty(ctx, name, getter) {\n  getter = getter === undefined ? function () {} : getter;\n\n  Object.defineProperty(ctx, name,\n    { get: function propertyGetter() {\n        // Setting the `ssfi` flag to `propertyGetter` causes this function to\n        // be the starting point for removing implementation frames from the\n        // stack trace of a failed assertion.\n        //\n        // However, we only want to use this function as the starting point if\n        // the `lockSsfi` flag isn't set and proxy protection is disabled.\n        //\n        // If the `lockSsfi` flag is set, then either this assertion has been\n        // overwritten by another assertion, or this assertion is being invoked\n        // from inside of another assertion. In the first case, the `ssfi` flag\n        // has already been set by the overwriting assertion. In the second\n        // case, the `ssfi` flag has already been set by the outer assertion.\n        //\n        // If proxy protection is enabled, then the `ssfi` flag has already been\n        // set by the proxy getter.\n        if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {\n          flag(this, 'ssfi', propertyGetter);\n        }\n\n        var result = getter.call(this);\n        if (result !== undefined)\n          return result;\n\n        var newAssertion = new chai.Assertion();\n        transferFlags(this, newAssertion);\n        return newAssertion;\n      }\n    , configurable: true\n  });\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/utils/addProperty.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/compareByInspect.js":
/*!***************************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/compareByInspect.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - compareByInspect utility\n * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar inspect = __webpack_require__(/*! ./inspect */ \"../node_modules/chai/lib/chai/utils/inspect.js\");\n\n/**\n * ### .compareByInspect(mixed, mixed)\n *\n * To be used as a compareFunction with Array.prototype.sort. Compares elements\n * using inspect instead of default behavior of using toString so that Symbols\n * and objects with irregular/missing toString can still be sorted without a\n * TypeError.\n *\n * @param {Mixed} first element to compare\n * @param {Mixed} second element to compare\n * @returns {Number} -1 if 'a' should come before 'b'; otherwise 1\n * @name compareByInspect\n * @namespace Utils\n * @api public\n */\n\nmodule.exports = function compareByInspect(a, b) {\n  return inspect(a) < inspect(b) ? -1 : 1;\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/utils/compareByInspect.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/expectTypes.js":
/*!**********************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/expectTypes.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - expectTypes utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .expectTypes(obj, types)\n *\n * Ensures that the object being tested against is of a valid type.\n *\n *     utils.expectTypes(this, ['array', 'object', 'string']);\n *\n * @param {Mixed} obj constructed Assertion\n * @param {Array} type A list of allowed types for this assertion\n * @namespace Utils\n * @name expectTypes\n * @api public\n */\n\nvar AssertionError = __webpack_require__(/*! assertion-error */ \"../node_modules/assertion-error/index.js\");\nvar flag = __webpack_require__(/*! ./flag */ \"../node_modules/chai/lib/chai/utils/flag.js\");\nvar type = __webpack_require__(/*! type-detect */ \"../node_modules/type-detect/type-detect.js\");\n\nmodule.exports = function expectTypes(obj, types) {\n  var flagMsg = flag(obj, 'message');\n  var ssfi = flag(obj, 'ssfi');\n\n  flagMsg = flagMsg ? flagMsg + ': ' : '';\n\n  obj = flag(obj, 'object');\n  types = types.map(function (t) { return t.toLowerCase(); });\n  types.sort();\n\n  // Transforms ['lorem', 'ipsum'] into 'a lorem, or an ipsum'\n  var str = types.map(function (t, index) {\n    var art = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(t.charAt(0)) ? 'an' : 'a';\n    var or = types.length > 1 && index === types.length - 1 ? 'or ' : '';\n    return or + art + ' ' + t;\n  }).join(', ');\n\n  var objType = type(obj).toLowerCase();\n\n  if (!types.some(function (expected) { return objType === expected; })) {\n    throw new AssertionError(\n      flagMsg + 'object tested must be ' + str + ', but ' + objType + ' given',\n      undefined,\n      ssfi\n    );\n  }\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/utils/expectTypes.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/flag.js":
/*!***************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/flag.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Chai - flag utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .flag(object, key, [value])\n *\n * Get or set a flag value on an object. If a\n * value is provided it will be set, else it will\n * return the currently set value or `undefined` if\n * the value is not set.\n *\n *     utils.flag(this, 'foo', 'bar'); // setter\n *     utils.flag(this, 'foo'); // getter, returns `bar`\n *\n * @param {Object} object constructed Assertion\n * @param {String} key\n * @param {Mixed} value (optional)\n * @namespace Utils\n * @name flag\n * @api private\n */\n\nmodule.exports = function flag(obj, key, value) {\n  var flags = obj.__flags || (obj.__flags = Object.create(null));\n  if (arguments.length === 3) {\n    flags[key] = value;\n  } else {\n    return flags[key];\n  }\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/utils/flag.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/getActual.js":
/*!********************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/getActual.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Chai - getActual utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getActual(object, [actual])\n *\n * Returns the `actual` value for an Assertion.\n *\n * @param {Object} object (constructed Assertion)\n * @param {Arguments} chai.Assertion.prototype.assert arguments\n * @namespace Utils\n * @name getActual\n */\n\nmodule.exports = function getActual(obj, args) {\n  return args.length > 4 ? args[4] : obj._obj;\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/utils/getActual.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/getEnumerableProperties.js":
/*!**********************************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/getEnumerableProperties.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Chai - getEnumerableProperties utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getEnumerableProperties(object)\n *\n * This allows the retrieval of enumerable property names of an object,\n * inherited or not.\n *\n * @param {Object} object\n * @returns {Array}\n * @namespace Utils\n * @name getEnumerableProperties\n * @api public\n */\n\nmodule.exports = function getEnumerableProperties(object) {\n  var result = [];\n  for (var name in object) {\n    result.push(name);\n  }\n  return result;\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/utils/getEnumerableProperties.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/getMessage.js":
/*!*********************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/getMessage.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - message composition utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar flag = __webpack_require__(/*! ./flag */ \"../node_modules/chai/lib/chai/utils/flag.js\")\n  , getActual = __webpack_require__(/*! ./getActual */ \"../node_modules/chai/lib/chai/utils/getActual.js\")\n  , objDisplay = __webpack_require__(/*! ./objDisplay */ \"../node_modules/chai/lib/chai/utils/objDisplay.js\");\n\n/**\n * ### .getMessage(object, message, negateMessage)\n *\n * Construct the error message based on flags\n * and template tags. Template tags will return\n * a stringified inspection of the object referenced.\n *\n * Message template tags:\n * - `#{this}` current asserted object\n * - `#{act}` actual value\n * - `#{exp}` expected value\n *\n * @param {Object} object (constructed Assertion)\n * @param {Arguments} chai.Assertion.prototype.assert arguments\n * @namespace Utils\n * @name getMessage\n * @api public\n */\n\nmodule.exports = function getMessage(obj, args) {\n  var negate = flag(obj, 'negate')\n    , val = flag(obj, 'object')\n    , expected = args[3]\n    , actual = getActual(obj, args)\n    , msg = negate ? args[2] : args[1]\n    , flagMsg = flag(obj, 'message');\n\n  if(typeof msg === \"function\") msg = msg();\n  msg = msg || '';\n  msg = msg\n    .replace(/#\\{this\\}/g, function () { return objDisplay(val); })\n    .replace(/#\\{act\\}/g, function () { return objDisplay(actual); })\n    .replace(/#\\{exp\\}/g, function () { return objDisplay(expected); });\n\n  return flagMsg ? flagMsg + ': ' + msg : msg;\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/utils/getMessage.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/getOwnEnumerableProperties.js":
/*!*************************************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/getOwnEnumerableProperties.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - getOwnEnumerableProperties utility\n * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar getOwnEnumerablePropertySymbols = __webpack_require__(/*! ./getOwnEnumerablePropertySymbols */ \"../node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js\");\n\n/**\n * ### .getOwnEnumerableProperties(object)\n *\n * This allows the retrieval of directly-owned enumerable property names and\n * symbols of an object. This function is necessary because Object.keys only\n * returns enumerable property names, not enumerable property symbols.\n *\n * @param {Object} object\n * @returns {Array}\n * @namespace Utils\n * @name getOwnEnumerableProperties\n * @api public\n */\n\nmodule.exports = function getOwnEnumerableProperties(obj) {\n  return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/utils/getOwnEnumerableProperties.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js":
/*!******************************************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Chai - getOwnEnumerablePropertySymbols utility\n * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getOwnEnumerablePropertySymbols(object)\n *\n * This allows the retrieval of directly-owned enumerable property symbols of an\n * object. This function is necessary because Object.getOwnPropertySymbols\n * returns both enumerable and non-enumerable property symbols.\n *\n * @param {Object} object\n * @returns {Array}\n * @namespace Utils\n * @name getOwnEnumerablePropertySymbols\n * @api public\n */\n\nmodule.exports = function getOwnEnumerablePropertySymbols(obj) {\n  if (typeof Object.getOwnPropertySymbols !== 'function') return [];\n\n  return Object.getOwnPropertySymbols(obj).filter(function (sym) {\n    return Object.getOwnPropertyDescriptor(obj, sym).enumerable;\n  });\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/getProperties.js":
/*!************************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/getProperties.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Chai - getProperties utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getProperties(object)\n *\n * This allows the retrieval of property names of an object, enumerable or not,\n * inherited or not.\n *\n * @param {Object} object\n * @returns {Array}\n * @namespace Utils\n * @name getProperties\n * @api public\n */\n\nmodule.exports = function getProperties(object) {\n  var result = Object.getOwnPropertyNames(object);\n\n  function addProperty(property) {\n    if (result.indexOf(property) === -1) {\n      result.push(property);\n    }\n  }\n\n  var proto = Object.getPrototypeOf(object);\n  while (proto !== null) {\n    Object.getOwnPropertyNames(proto).forEach(addProperty);\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return result;\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/utils/getProperties.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/index.js":
/*!****************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * chai\n * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Dependencies that are used for multiple exports are required here only once\n */\n\nvar pathval = __webpack_require__(/*! pathval */ \"../node_modules/pathval/index.js\");\n\n/*!\n * test utility\n */\n\nexports.test = __webpack_require__(/*! ./test */ \"../node_modules/chai/lib/chai/utils/test.js\");\n\n/*!\n * type utility\n */\n\nexports.type = __webpack_require__(/*! type-detect */ \"../node_modules/type-detect/type-detect.js\");\n\n/*!\n * expectTypes utility\n */\nexports.expectTypes = __webpack_require__(/*! ./expectTypes */ \"../node_modules/chai/lib/chai/utils/expectTypes.js\");\n\n/*!\n * message utility\n */\n\nexports.getMessage = __webpack_require__(/*! ./getMessage */ \"../node_modules/chai/lib/chai/utils/getMessage.js\");\n\n/*!\n * actual utility\n */\n\nexports.getActual = __webpack_require__(/*! ./getActual */ \"../node_modules/chai/lib/chai/utils/getActual.js\");\n\n/*!\n * Inspect util\n */\n\nexports.inspect = __webpack_require__(/*! ./inspect */ \"../node_modules/chai/lib/chai/utils/inspect.js\");\n\n/*!\n * Object Display util\n */\n\nexports.objDisplay = __webpack_require__(/*! ./objDisplay */ \"../node_modules/chai/lib/chai/utils/objDisplay.js\");\n\n/*!\n * Flag utility\n */\n\nexports.flag = __webpack_require__(/*! ./flag */ \"../node_modules/chai/lib/chai/utils/flag.js\");\n\n/*!\n * Flag transferring utility\n */\n\nexports.transferFlags = __webpack_require__(/*! ./transferFlags */ \"../node_modules/chai/lib/chai/utils/transferFlags.js\");\n\n/*!\n * Deep equal utility\n */\n\nexports.eql = __webpack_require__(/*! deep-eql */ \"../node_modules/deep-eql/index.js\");\n\n/*!\n * Deep path info\n */\n\nexports.getPathInfo = pathval.getPathInfo;\n\n/*!\n * Check if a property exists\n */\n\nexports.hasProperty = pathval.hasProperty;\n\n/*!\n * Function name\n */\n\nexports.getName = __webpack_require__(/*! get-func-name */ \"../node_modules/get-func-name/index.js\");\n\n/*!\n * add Property\n */\n\nexports.addProperty = __webpack_require__(/*! ./addProperty */ \"../node_modules/chai/lib/chai/utils/addProperty.js\");\n\n/*!\n * add Method\n */\n\nexports.addMethod = __webpack_require__(/*! ./addMethod */ \"../node_modules/chai/lib/chai/utils/addMethod.js\");\n\n/*!\n * overwrite Property\n */\n\nexports.overwriteProperty = __webpack_require__(/*! ./overwriteProperty */ \"../node_modules/chai/lib/chai/utils/overwriteProperty.js\");\n\n/*!\n * overwrite Method\n */\n\nexports.overwriteMethod = __webpack_require__(/*! ./overwriteMethod */ \"../node_modules/chai/lib/chai/utils/overwriteMethod.js\");\n\n/*!\n * Add a chainable method\n */\n\nexports.addChainableMethod = __webpack_require__(/*! ./addChainableMethod */ \"../node_modules/chai/lib/chai/utils/addChainableMethod.js\");\n\n/*!\n * Overwrite chainable method\n */\n\nexports.overwriteChainableMethod = __webpack_require__(/*! ./overwriteChainableMethod */ \"../node_modules/chai/lib/chai/utils/overwriteChainableMethod.js\");\n\n/*!\n * Compare by inspect method\n */\n\nexports.compareByInspect = __webpack_require__(/*! ./compareByInspect */ \"../node_modules/chai/lib/chai/utils/compareByInspect.js\");\n\n/*!\n * Get own enumerable property symbols method\n */\n\nexports.getOwnEnumerablePropertySymbols = __webpack_require__(/*! ./getOwnEnumerablePropertySymbols */ \"../node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js\");\n\n/*!\n * Get own enumerable properties method\n */\n\nexports.getOwnEnumerableProperties = __webpack_require__(/*! ./getOwnEnumerableProperties */ \"../node_modules/chai/lib/chai/utils/getOwnEnumerableProperties.js\");\n\n/*!\n * Checks error against a given set of criteria\n */\n\nexports.checkError = __webpack_require__(/*! check-error */ \"../node_modules/check-error/index.js\");\n\n/*!\n * Proxify util\n */\n\nexports.proxify = __webpack_require__(/*! ./proxify */ \"../node_modules/chai/lib/chai/utils/proxify.js\");\n\n/*!\n * addLengthGuard util\n */\n\nexports.addLengthGuard = __webpack_require__(/*! ./addLengthGuard */ \"../node_modules/chai/lib/chai/utils/addLengthGuard.js\");\n\n/*!\n * isProxyEnabled helper\n */\n\nexports.isProxyEnabled = __webpack_require__(/*! ./isProxyEnabled */ \"../node_modules/chai/lib/chai/utils/isProxyEnabled.js\");\n\n/*!\n * isNaN method\n */\n\nexports.isNaN = __webpack_require__(/*! ./isNaN */ \"../node_modules/chai/lib/chai/utils/isNaN.js\");\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/utils/index.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/inspect.js":
/*!******************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/inspect.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// This is (almost) directly from Node.js utils\n// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js\n\nvar getName = __webpack_require__(/*! get-func-name */ \"../node_modules/get-func-name/index.js\");\nvar getProperties = __webpack_require__(/*! ./getProperties */ \"../node_modules/chai/lib/chai/utils/getProperties.js\");\nvar getEnumerableProperties = __webpack_require__(/*! ./getEnumerableProperties */ \"../node_modules/chai/lib/chai/utils/getEnumerableProperties.js\");\nvar config = __webpack_require__(/*! ../config */ \"../node_modules/chai/lib/chai/config.js\");\n\nmodule.exports = inspect;\n\n/**\n * ### .inspect(obj, [showHidden], [depth], [colors])\n *\n * Echoes the value of a value. Tries to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Boolean} showHidden Flag that shows hidden (not enumerable)\n *    properties of objects. Default is false.\n * @param {Number} depth Depth in which to descend in object. Default is 2.\n * @param {Boolean} colors Flag to turn on ANSI escape codes to color the\n *    output. Default is false (no coloring).\n * @namespace Utils\n * @name inspect\n */\nfunction inspect(obj, showHidden, depth, colors) {\n  var ctx = {\n    showHidden: showHidden,\n    seen: [],\n    stylize: function (str) { return str; }\n  };\n  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));\n}\n\n// Returns true if object is a DOM element.\nvar isDOMElement = function (object) {\n  if (typeof HTMLElement === 'object') {\n    return object instanceof HTMLElement;\n  } else {\n    return object &&\n      typeof object === 'object' &&\n      'nodeType' in object &&\n      object.nodeType === 1 &&\n      typeof object.nodeName === 'string';\n  }\n};\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (value && typeof value.inspect === 'function' &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (typeof ret !== 'string') {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // If this is a DOM element, try to get the outer HTML.\n  if (isDOMElement(value)) {\n    if ('outerHTML' in value) {\n      return value.outerHTML;\n      // This value does not have an outerHTML attribute,\n      //   it could still be an XML element\n    } else {\n      // Attempt to serialize it\n      try {\n        if (document.xmlVersion) {\n          var xmlSerializer = new XMLSerializer();\n          return xmlSerializer.serializeToString(value);\n        } else {\n          // Firefox 11- do not support outerHTML\n          //   It does, however, support innerHTML\n          //   Use the following to render the element\n          var ns = \"http://www.w3.org/1999/xhtml\";\n          var container = document.createElementNS(ns, '_');\n\n          container.appendChild(value.cloneNode(false));\n          var html = container.innerHTML\n            .replace('><', '>' + value.innerHTML + '<');\n          container.innerHTML = '';\n          return html;\n        }\n      } catch (err) {\n        // This could be a non-native DOM implementation,\n        //   continue with the normal flow:\n        //   printing the element as if it is an object.\n      }\n    }\n  }\n\n  // Look up the keys of the object.\n  var visibleKeys = getEnumerableProperties(value);\n  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;\n\n  var name, nameSuffix;\n\n  // Some type of object without properties can be shortcut.\n  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,\n  // a `stack` plus `description` property; ignore those for consistency.\n  if (keys.length === 0 || (isError(value) && (\n      (keys.length === 1 && keys[0] === 'stack') ||\n      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')\n     ))) {\n    if (typeof value === 'function') {\n      name = getName(value);\n      nameSuffix = name ? ': ' + name : '';\n      return ctx.stylize('[Function' + nameSuffix + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = ''\n    , array = false\n    , typedArray = false\n    , braces = ['{', '}'];\n\n  if (isTypedArray(value)) {\n    typedArray = true;\n    braces = ['[', ']'];\n  }\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (typeof value === 'function') {\n    name = getName(value);\n    nameSuffix = name ? ': ' + name : '';\n    base = ' [Function' + nameSuffix + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    return formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else if (typedArray) {\n    return formatTypedArray(value);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\nfunction formatPrimitive(ctx, value) {\n  switch (typeof value) {\n    case 'undefined':\n      return ctx.stylize('undefined', 'undefined');\n\n    case 'string':\n      var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                               .replace(/'/g, \"\\\\'\")\n                                               .replace(/\\\\\"/g, '\"') + '\\'';\n      return ctx.stylize(simple, 'string');\n\n    case 'number':\n      if (value === 0 && (1/value) === -Infinity) {\n        return ctx.stylize('-0', 'number');\n      }\n      return ctx.stylize('' + value, 'number');\n\n    case 'boolean':\n      return ctx.stylize('' + value, 'boolean');\n\n    case 'symbol':\n      return ctx.stylize(value.toString(), 'symbol');\n  }\n  // For some reason typeof null is \"object\", so special case here.\n  if (value === null) {\n    return ctx.stylize('null', 'null');\n  }\n}\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (Object.prototype.hasOwnProperty.call(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\nfunction formatTypedArray(value) {\n  var str = '[ ';\n\n  for (var i = 0; i < value.length; ++i) {\n    if (str.length >= config.truncateThreshold - 7) {\n      str += '...';\n      break;\n    }\n    str += value[i] + ', ';\n  }\n  str += ' ]';\n\n  // Removing trailing `, ` if the array was not truncated\n  if (str.indexOf(',  ]') !== -1) {\n    str = str.replace(',  ]', ' ]');\n  }\n\n  return str;\n}\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name;\n  var propDescriptor = Object.getOwnPropertyDescriptor(value, key);\n  var str;\n\n  if (propDescriptor) {\n    if (propDescriptor.get) {\n      if (propDescriptor.set) {\n        str = ctx.stylize('[Getter/Setter]', 'special');\n      } else {\n        str = ctx.stylize('[Getter]', 'special');\n      }\n    } else {\n      if (propDescriptor.set) {\n        str = ctx.stylize('[Setter]', 'special');\n      }\n    }\n  }\n  if (visibleKeys.indexOf(key) < 0) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(value[key]) < 0) {\n      if (recurseTimes === null) {\n        str = formatValue(ctx, value[key], null);\n      } else {\n        str = formatValue(ctx, value[key], recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (typeof name === 'undefined') {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\nfunction reduceToSingleString(output, base, braces) {\n  var length = output.reduce(function(prev, cur) {\n    return prev + cur.length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\nfunction isTypedArray(ar) {\n  // Unfortunately there's no way to check if an object is a TypedArray\n  // We have to check if it's one of these types\n  return (typeof ar === 'object' && /\\w+Array]$/.test(objectToString(ar)));\n}\n\nfunction isArray(ar) {\n  return Array.isArray(ar) ||\n         (typeof ar === 'object' && objectToString(ar) === '[object Array]');\n}\n\nfunction isRegExp(re) {\n  return typeof re === 'object' && objectToString(re) === '[object RegExp]';\n}\n\nfunction isDate(d) {\n  return typeof d === 'object' && objectToString(d) === '[object Date]';\n}\n\nfunction isError(e) {\n  return typeof e === 'object' && objectToString(e) === '[object Error]';\n}\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/utils/inspect.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/isNaN.js":
/*!****************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/isNaN.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Chai - isNaN utility\n * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>\n * MIT Licensed\n */\n\n/**\n * ### .isNaN(value)\n *\n * Checks if the given value is NaN or not.\n *\n *     utils.isNaN(NaN); // true\n *\n * @param {Value} The value which has to be checked if it is NaN\n * @name isNaN\n * @api private\n */\n\nfunction isNaN(value) {\n  // Refer http://www.ecma-international.org/ecma-262/6.0/#sec-isnan-number\n  // section's NOTE.\n  return value !== value;\n}\n\n// If ECMAScript 6's Number.isNaN is present, prefer that.\nmodule.exports = Number.isNaN || isNaN;\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/utils/isNaN.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/isProxyEnabled.js":
/*!*************************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/isProxyEnabled.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var config = __webpack_require__(/*! ../config */ \"../node_modules/chai/lib/chai/config.js\");\n\n/*!\n * Chai - isProxyEnabled helper\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .isProxyEnabled()\n *\n * Helper function to check if Chai's proxy protection feature is enabled. If\n * proxies are unsupported or disabled via the user's Chai config, then return\n * false. Otherwise, return true.\n *\n * @namespace Utils\n * @name isProxyEnabled\n */\n\nmodule.exports = function isProxyEnabled() {\n  return config.useProxy &&\n    typeof Proxy !== 'undefined' &&\n    typeof Reflect !== 'undefined';\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/utils/isProxyEnabled.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/objDisplay.js":
/*!*********************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/objDisplay.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - flag utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar inspect = __webpack_require__(/*! ./inspect */ \"../node_modules/chai/lib/chai/utils/inspect.js\");\nvar config = __webpack_require__(/*! ../config */ \"../node_modules/chai/lib/chai/config.js\");\n\n/**\n * ### .objDisplay(object)\n *\n * Determines if an object or an array matches\n * criteria to be inspected in-line for error\n * messages or should be truncated.\n *\n * @param {Mixed} javascript object to inspect\n * @name objDisplay\n * @namespace Utils\n * @api public\n */\n\nmodule.exports = function objDisplay(obj) {\n  var str = inspect(obj)\n    , type = Object.prototype.toString.call(obj);\n\n  if (config.truncateThreshold && str.length >= config.truncateThreshold) {\n    if (type === '[object Function]') {\n      return !obj.name || obj.name === ''\n        ? '[Function]'\n        : '[Function: ' + obj.name + ']';\n    } else if (type === '[object Array]') {\n      return '[ Array(' + obj.length + ') ]';\n    } else if (type === '[object Object]') {\n      var keys = Object.keys(obj)\n        , kstr = keys.length > 2\n          ? keys.splice(0, 2).join(', ') + ', ...'\n          : keys.join(', ');\n      return '{ Object (' + kstr + ') }';\n    } else {\n      return str;\n    }\n  } else {\n    return str;\n  }\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/utils/objDisplay.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/overwriteChainableMethod.js":
/*!***********************************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/overwriteChainableMethod.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - overwriteChainableMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar chai = __webpack_require__(/*! ../../chai */ \"../node_modules/chai/lib/chai.js\");\nvar transferFlags = __webpack_require__(/*! ./transferFlags */ \"../node_modules/chai/lib/chai/utils/transferFlags.js\");\n\n/**\n * ### .overwriteChainableMethod(ctx, name, method, chainingBehavior)\n *\n * Overwrites an already existing chainable method\n * and provides access to the previous function or\n * property.  Must return functions to be used for\n * name.\n *\n *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'lengthOf',\n *       function (_super) {\n *       }\n *     , function (_super) {\n *       }\n *     );\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.have.lengthOf(3);\n *     expect(myFoo).to.have.lengthOf.above(3);\n *\n * @param {Object} ctx object whose method / property is to be overwritten\n * @param {String} name of method / property to overwrite\n * @param {Function} method function that returns a function to be used for name\n * @param {Function} chainingBehavior function that returns a function to be used for property\n * @namespace Utils\n * @name overwriteChainableMethod\n * @api public\n */\n\nmodule.exports = function overwriteChainableMethod(ctx, name, method, chainingBehavior) {\n  var chainableBehavior = ctx.__methods[name];\n\n  var _chainingBehavior = chainableBehavior.chainingBehavior;\n  chainableBehavior.chainingBehavior = function overwritingChainableMethodGetter() {\n    var result = chainingBehavior(_chainingBehavior).call(this);\n    if (result !== undefined) {\n      return result;\n    }\n\n    var newAssertion = new chai.Assertion();\n    transferFlags(this, newAssertion);\n    return newAssertion;\n  };\n\n  var _method = chainableBehavior.method;\n  chainableBehavior.method = function overwritingChainableMethodWrapper() {\n    var result = method(_method).apply(this, arguments);\n    if (result !== undefined) {\n      return result;\n    }\n\n    var newAssertion = new chai.Assertion();\n    transferFlags(this, newAssertion);\n    return newAssertion;\n  };\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/utils/overwriteChainableMethod.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/overwriteMethod.js":
/*!**************************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/overwriteMethod.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - overwriteMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar addLengthGuard = __webpack_require__(/*! ./addLengthGuard */ \"../node_modules/chai/lib/chai/utils/addLengthGuard.js\");\nvar chai = __webpack_require__(/*! ../../chai */ \"../node_modules/chai/lib/chai.js\");\nvar flag = __webpack_require__(/*! ./flag */ \"../node_modules/chai/lib/chai/utils/flag.js\");\nvar proxify = __webpack_require__(/*! ./proxify */ \"../node_modules/chai/lib/chai/utils/proxify.js\");\nvar transferFlags = __webpack_require__(/*! ./transferFlags */ \"../node_modules/chai/lib/chai/utils/transferFlags.js\");\n\n/**\n * ### .overwriteMethod(ctx, name, fn)\n *\n * Overwrites an already existing method and provides\n * access to previous function. Must return function\n * to be used for name.\n *\n *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {\n *       return function (str) {\n *         var obj = utils.flag(this, 'object');\n *         if (obj instanceof Foo) {\n *           new chai.Assertion(obj.value).to.equal(str);\n *         } else {\n *           _super.apply(this, arguments);\n *         }\n *       }\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteMethod('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.equal('bar');\n *\n * @param {Object} ctx object whose method is to be overwritten\n * @param {String} name of method to overwrite\n * @param {Function} method function that returns a function to be used for name\n * @namespace Utils\n * @name overwriteMethod\n * @api public\n */\n\nmodule.exports = function overwriteMethod(ctx, name, method) {\n  var _method = ctx[name]\n    , _super = function () {\n      throw new Error(name + ' is not a function');\n    };\n\n  if (_method && 'function' === typeof _method)\n    _super = _method;\n\n  var overwritingMethodWrapper = function () {\n    // Setting the `ssfi` flag to `overwritingMethodWrapper` causes this\n    // function to be the starting point for removing implementation frames from\n    // the stack trace of a failed assertion.\n    //\n    // However, we only want to use this function as the starting point if the\n    // `lockSsfi` flag isn't set.\n    //\n    // If the `lockSsfi` flag is set, then either this assertion has been\n    // overwritten by another assertion, or this assertion is being invoked from\n    // inside of another assertion. In the first case, the `ssfi` flag has\n    // already been set by the overwriting assertion. In the second case, the\n    // `ssfi` flag has already been set by the outer assertion.\n    if (!flag(this, 'lockSsfi')) {\n      flag(this, 'ssfi', overwritingMethodWrapper);\n    }\n\n    // Setting the `lockSsfi` flag to `true` prevents the overwritten assertion\n    // from changing the `ssfi` flag. By this point, the `ssfi` flag is already\n    // set to the correct starting point for this assertion.\n    var origLockSsfi = flag(this, 'lockSsfi');\n    flag(this, 'lockSsfi', true);\n    var result = method(_super).apply(this, arguments);\n    flag(this, 'lockSsfi', origLockSsfi);\n\n    if (result !== undefined) {\n      return result;\n    }\n\n    var newAssertion = new chai.Assertion();\n    transferFlags(this, newAssertion);\n    return newAssertion;\n  }\n\n  addLengthGuard(overwritingMethodWrapper, name, false);\n  ctx[name] = proxify(overwritingMethodWrapper, name);\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/utils/overwriteMethod.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/overwriteProperty.js":
/*!****************************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/overwriteProperty.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - overwriteProperty utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar chai = __webpack_require__(/*! ../../chai */ \"../node_modules/chai/lib/chai.js\");\nvar flag = __webpack_require__(/*! ./flag */ \"../node_modules/chai/lib/chai/utils/flag.js\");\nvar isProxyEnabled = __webpack_require__(/*! ./isProxyEnabled */ \"../node_modules/chai/lib/chai/utils/isProxyEnabled.js\");\nvar transferFlags = __webpack_require__(/*! ./transferFlags */ \"../node_modules/chai/lib/chai/utils/transferFlags.js\");\n\n/**\n * ### .overwriteProperty(ctx, name, fn)\n *\n * Overwrites an already existing property getter and provides\n * access to previous value. Must return function to use as getter.\n *\n *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {\n *       return function () {\n *         var obj = utils.flag(this, 'object');\n *         if (obj instanceof Foo) {\n *           new chai.Assertion(obj.name).to.equal('bar');\n *         } else {\n *           _super.call(this);\n *         }\n *       }\n *     });\n *\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteProperty('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.be.ok;\n *\n * @param {Object} ctx object whose property is to be overwritten\n * @param {String} name of property to overwrite\n * @param {Function} getter function that returns a getter function to be used for name\n * @namespace Utils\n * @name overwriteProperty\n * @api public\n */\n\nmodule.exports = function overwriteProperty(ctx, name, getter) {\n  var _get = Object.getOwnPropertyDescriptor(ctx, name)\n    , _super = function () {};\n\n  if (_get && 'function' === typeof _get.get)\n    _super = _get.get\n\n  Object.defineProperty(ctx, name,\n    { get: function overwritingPropertyGetter() {\n        // Setting the `ssfi` flag to `overwritingPropertyGetter` causes this\n        // function to be the starting point for removing implementation frames\n        // from the stack trace of a failed assertion.\n        //\n        // However, we only want to use this function as the starting point if\n        // the `lockSsfi` flag isn't set and proxy protection is disabled.\n        //\n        // If the `lockSsfi` flag is set, then either this assertion has been\n        // overwritten by another assertion, or this assertion is being invoked\n        // from inside of another assertion. In the first case, the `ssfi` flag\n        // has already been set by the overwriting assertion. In the second\n        // case, the `ssfi` flag has already been set by the outer assertion.\n        //\n        // If proxy protection is enabled, then the `ssfi` flag has already been\n        // set by the proxy getter.\n        if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {\n          flag(this, 'ssfi', overwritingPropertyGetter);\n        }\n\n        // Setting the `lockSsfi` flag to `true` prevents the overwritten\n        // assertion from changing the `ssfi` flag. By this point, the `ssfi`\n        // flag is already set to the correct starting point for this assertion.\n        var origLockSsfi = flag(this, 'lockSsfi');\n        flag(this, 'lockSsfi', true);\n        var result = getter(_super).call(this);\n        flag(this, 'lockSsfi', origLockSsfi);\n\n        if (result !== undefined) {\n          return result;\n        }\n\n        var newAssertion = new chai.Assertion();\n        transferFlags(this, newAssertion);\n        return newAssertion;\n      }\n    , configurable: true\n  });\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/utils/overwriteProperty.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/proxify.js":
/*!******************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/proxify.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var config = __webpack_require__(/*! ../config */ \"../node_modules/chai/lib/chai/config.js\");\nvar flag = __webpack_require__(/*! ./flag */ \"../node_modules/chai/lib/chai/utils/flag.js\");\nvar getProperties = __webpack_require__(/*! ./getProperties */ \"../node_modules/chai/lib/chai/utils/getProperties.js\");\nvar isProxyEnabled = __webpack_require__(/*! ./isProxyEnabled */ \"../node_modules/chai/lib/chai/utils/isProxyEnabled.js\");\n\n/*!\n * Chai - proxify utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .proxify(object)\n *\n * Return a proxy of given object that throws an error when a non-existent\n * property is read. By default, the root cause is assumed to be a misspelled\n * property, and thus an attempt is made to offer a reasonable suggestion from\n * the list of existing properties. However, if a nonChainableMethodName is\n * provided, then the root cause is instead a failure to invoke a non-chainable\n * method prior to reading the non-existent property.\n *\n * If proxies are unsupported or disabled via the user's Chai config, then\n * return object without modification.\n *\n * @param {Object} obj\n * @param {String} nonChainableMethodName\n * @namespace Utils\n * @name proxify\n */\n\nvar builtins = ['__flags', '__methods', '_obj', 'assert'];\n\nmodule.exports = function proxify(obj, nonChainableMethodName) {\n  if (!isProxyEnabled()) return obj;\n\n  return new Proxy(obj, {\n    get: function proxyGetter(target, property) {\n      // This check is here because we should not throw errors on Symbol properties\n      // such as `Symbol.toStringTag`.\n      // The values for which an error should be thrown can be configured using\n      // the `config.proxyExcludedKeys` setting.\n      if (typeof property === 'string' &&\n          config.proxyExcludedKeys.indexOf(property) === -1 &&\n          !Reflect.has(target, property)) {\n        // Special message for invalid property access of non-chainable methods.\n        if (nonChainableMethodName) {\n          throw Error('Invalid Chai property: ' + nonChainableMethodName + '.' +\n            property + '. See docs for proper usage of \"' +\n            nonChainableMethodName + '\".');\n        }\n\n        // If the property is reasonably close to an existing Chai property,\n        // suggest that property to the user. Only suggest properties with a\n        // distance less than 4.\n        var suggestion = null;\n        var suggestionDistance = 4;\n        getProperties(target).forEach(function(prop) {\n          if (\n            !Object.prototype.hasOwnProperty(prop) &&\n            builtins.indexOf(prop) === -1\n          ) {\n            var dist = stringDistanceCapped(\n              property,\n              prop,\n              suggestionDistance\n            );\n            if (dist < suggestionDistance) {\n              suggestion = prop;\n              suggestionDistance = dist;\n            }\n          }\n        });\n\n        if (suggestion !== null) {\n          throw Error('Invalid Chai property: ' + property +\n            '. Did you mean \"' + suggestion + '\"?');\n        } else {\n          throw Error('Invalid Chai property: ' + property);\n        }\n      }\n\n      // Use this proxy getter as the starting point for removing implementation\n      // frames from the stack trace of a failed assertion. For property\n      // assertions, this prevents the proxy getter from showing up in the stack\n      // trace since it's invoked before the property getter. For method and\n      // chainable method assertions, this flag will end up getting changed to\n      // the method wrapper, which is good since this frame will no longer be in\n      // the stack once the method is invoked. Note that Chai builtin assertion\n      // properties such as `__flags` are skipped since this is only meant to\n      // capture the starting point of an assertion. This step is also skipped\n      // if the `lockSsfi` flag is set, thus indicating that this assertion is\n      // being called from within another assertion. In that case, the `ssfi`\n      // flag is already set to the outer assertion's starting point.\n      if (builtins.indexOf(property) === -1 && !flag(target, 'lockSsfi')) {\n        flag(target, 'ssfi', proxyGetter);\n      }\n\n      return Reflect.get(target, property);\n    }\n  });\n};\n\n/**\n * # stringDistanceCapped(strA, strB, cap)\n * Return the Levenshtein distance between two strings, but no more than cap.\n * @param {string} strA\n * @param {string} strB\n * @param {number} number\n * @return {number} min(string distance between strA and strB, cap)\n * @api private\n */\n\nfunction stringDistanceCapped(strA, strB, cap) {\n  if (Math.abs(strA.length - strB.length) >= cap) {\n    return cap;\n  }\n\n  var memo = [];\n  // `memo` is a two-dimensional array containing distances.\n  // memo[i][j] is the distance between strA.slice(0, i) and\n  // strB.slice(0, j).\n  for (var i = 0; i <= strA.length; i++) {\n    memo[i] = Array(strB.length + 1).fill(0);\n    memo[i][0] = i;\n  }\n  for (var j = 0; j < strB.length; j++) {\n    memo[0][j] = j;\n  }\n\n  for (var i = 1; i <= strA.length; i++) {\n    var ch = strA.charCodeAt(i - 1);\n    for (var j = 1; j <= strB.length; j++) {\n      if (Math.abs(i - j) >= cap) {\n        memo[i][j] = cap;\n        continue;\n      }\n      memo[i][j] = Math.min(\n        memo[i - 1][j] + 1,\n        memo[i][j - 1] + 1,\n        memo[i - 1][j - 1] +\n          (ch === strB.charCodeAt(j - 1) ? 0 : 1)\n      );\n    }\n  }\n\n  return memo[strA.length][strB.length];\n}\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/utils/proxify.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/test.js":
/*!***************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/test.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - test utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar flag = __webpack_require__(/*! ./flag */ \"../node_modules/chai/lib/chai/utils/flag.js\");\n\n/**\n * ### .test(object, expression)\n *\n * Test and object for expression.\n *\n * @param {Object} object (constructed Assertion)\n * @param {Arguments} chai.Assertion.prototype.assert arguments\n * @namespace Utils\n * @name test\n */\n\nmodule.exports = function test(obj, args) {\n  var negate = flag(obj, 'negate')\n    , expr = args[0];\n  return negate ? !expr : expr;\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/utils/test.js?");

/***/ }),

/***/ "../node_modules/chai/lib/chai/utils/transferFlags.js":
/*!************************************************************!*\
  !*** ../node_modules/chai/lib/chai/utils/transferFlags.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Chai - transferFlags utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .transferFlags(assertion, object, includeAll = true)\n *\n * Transfer all the flags for `assertion` to `object`. If\n * `includeAll` is set to `false`, then the base Chai\n * assertion flags (namely `object`, `ssfi`, `lockSsfi`,\n * and `message`) will not be transferred.\n *\n *\n *     var newAssertion = new Assertion();\n *     utils.transferFlags(assertion, newAssertion);\n *\n *     var anotherAssertion = new Assertion(myObj);\n *     utils.transferFlags(assertion, anotherAssertion, false);\n *\n * @param {Assertion} assertion the assertion to transfer the flags from\n * @param {Object} object the object to transfer the flags to; usually a new assertion\n * @param {Boolean} includeAll\n * @namespace Utils\n * @name transferFlags\n * @api private\n */\n\nmodule.exports = function transferFlags(assertion, object, includeAll) {\n  var flags = assertion.__flags || (assertion.__flags = Object.create(null));\n\n  if (!object.__flags) {\n    object.__flags = Object.create(null);\n  }\n\n  includeAll = arguments.length === 3 ? includeAll : true;\n\n  for (var flag in flags) {\n    if (includeAll ||\n        (flag !== 'object' && flag !== 'ssfi' && flag !== 'lockSsfi' && flag != 'message')) {\n      object.__flags[flag] = flags[flag];\n    }\n  }\n};\n\n\n//# sourceURL=webpack:///../node_modules/chai/lib/chai/utils/transferFlags.js?");

/***/ }),

/***/ "../node_modules/check-error/index.js":
/*!********************************************!*\
  !*** ../node_modules/check-error/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* !\n * Chai - checkError utility\n * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .checkError\n *\n * Checks that an error conforms to a given set of criteria and/or retrieves information about it.\n *\n * @api public\n */\n\n/**\n * ### .compatibleInstance(thrown, errorLike)\n *\n * Checks if two instances are compatible (strict equal).\n * Returns false if errorLike is not an instance of Error, because instances\n * can only be compatible if they're both error instances.\n *\n * @name compatibleInstance\n * @param {Error} thrown error\n * @param {Error|ErrorConstructor} errorLike object to compare against\n * @namespace Utils\n * @api public\n */\n\nfunction compatibleInstance(thrown, errorLike) {\n  return errorLike instanceof Error && thrown === errorLike;\n}\n\n/**\n * ### .compatibleConstructor(thrown, errorLike)\n *\n * Checks if two constructors are compatible.\n * This function can receive either an error constructor or\n * an error instance as the `errorLike` argument.\n * Constructors are compatible if they're the same or if one is\n * an instance of another.\n *\n * @name compatibleConstructor\n * @param {Error} thrown error\n * @param {Error|ErrorConstructor} errorLike object to compare against\n * @namespace Utils\n * @api public\n */\n\nfunction compatibleConstructor(thrown, errorLike) {\n  if (errorLike instanceof Error) {\n    // If `errorLike` is an instance of any error we compare their constructors\n    return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;\n  } else if (errorLike.prototype instanceof Error || errorLike === Error) {\n    // If `errorLike` is a constructor that inherits from Error, we compare `thrown` to `errorLike` directly\n    return thrown.constructor === errorLike || thrown instanceof errorLike;\n  }\n\n  return false;\n}\n\n/**\n * ### .compatibleMessage(thrown, errMatcher)\n *\n * Checks if an error's message is compatible with a matcher (String or RegExp).\n * If the message contains the String or passes the RegExp test,\n * it is considered compatible.\n *\n * @name compatibleMessage\n * @param {Error} thrown error\n * @param {String|RegExp} errMatcher to look for into the message\n * @namespace Utils\n * @api public\n */\n\nfunction compatibleMessage(thrown, errMatcher) {\n  var comparisonString = typeof thrown === 'string' ? thrown : thrown.message;\n  if (errMatcher instanceof RegExp) {\n    return errMatcher.test(comparisonString);\n  } else if (typeof errMatcher === 'string') {\n    return comparisonString.indexOf(errMatcher) !== -1; // eslint-disable-line no-magic-numbers\n  }\n\n  return false;\n}\n\n/**\n * ### .getFunctionName(constructorFn)\n *\n * Returns the name of a function.\n * This also includes a polyfill function if `constructorFn.name` is not defined.\n *\n * @name getFunctionName\n * @param {Function} constructorFn\n * @namespace Utils\n * @api private\n */\n\nvar functionNameMatch = /\\s*function(?:\\s|\\s*\\/\\*[^(?:*\\/)]+\\*\\/\\s*)*([^\\(\\/]+)/;\nfunction getFunctionName(constructorFn) {\n  var name = '';\n  if (typeof constructorFn.name === 'undefined') {\n    // Here we run a polyfill if constructorFn.name is not defined\n    var match = String(constructorFn).match(functionNameMatch);\n    if (match) {\n      name = match[1];\n    }\n  } else {\n    name = constructorFn.name;\n  }\n\n  return name;\n}\n\n/**\n * ### .getConstructorName(errorLike)\n *\n * Gets the constructor name for an Error instance or constructor itself.\n *\n * @name getConstructorName\n * @param {Error|ErrorConstructor} errorLike\n * @namespace Utils\n * @api public\n */\n\nfunction getConstructorName(errorLike) {\n  var constructorName = errorLike;\n  if (errorLike instanceof Error) {\n    constructorName = getFunctionName(errorLike.constructor);\n  } else if (typeof errorLike === 'function') {\n    // If `err` is not an instance of Error it is an error constructor itself or another function.\n    // If we've got a common function we get its name, otherwise we may need to create a new instance\n    // of the error just in case it's a poorly-constructed error. Please see chaijs/chai/issues/45 to know more.\n    constructorName = getFunctionName(errorLike).trim() ||\n        getFunctionName(new errorLike()); // eslint-disable-line new-cap\n  }\n\n  return constructorName;\n}\n\n/**\n * ### .getMessage(errorLike)\n *\n * Gets the error message from an error.\n * If `err` is a String itself, we return it.\n * If the error has no message, we return an empty string.\n *\n * @name getMessage\n * @param {Error|String} errorLike\n * @namespace Utils\n * @api public\n */\n\nfunction getMessage(errorLike) {\n  var msg = '';\n  if (errorLike && errorLike.message) {\n    msg = errorLike.message;\n  } else if (typeof errorLike === 'string') {\n    msg = errorLike;\n  }\n\n  return msg;\n}\n\nmodule.exports = {\n  compatibleInstance: compatibleInstance,\n  compatibleConstructor: compatibleConstructor,\n  compatibleMessage: compatibleMessage,\n  getMessage: getMessage,\n  getConstructorName: getConstructorName,\n};\n\n\n//# sourceURL=webpack:///../node_modules/check-error/index.js?");

/***/ }),

/***/ "../node_modules/deep-eql/index.js":
/*!*****************************************!*\
  !*** ../node_modules/deep-eql/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* globals Symbol: false, Uint8Array: false, WeakMap: false */\n/*!\n * deep-eql\n * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar type = __webpack_require__(/*! type-detect */ \"../node_modules/type-detect/type-detect.js\");\nfunction FakeMap() {\n  this._key = 'chai/deep-eql__' + Math.random() + Date.now();\n}\n\nFakeMap.prototype = {\n  get: function getMap(key) {\n    return key[this._key];\n  },\n  set: function setMap(key, value) {\n    if (Object.isExtensible(key)) {\n      Object.defineProperty(key, this._key, {\n        value: value,\n        configurable: true,\n      });\n    }\n  },\n};\n\nvar MemoizeMap = typeof WeakMap === 'function' ? WeakMap : FakeMap;\n/*!\n * Check to see if the MemoizeMap has recorded a result of the two operands\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {MemoizeMap} memoizeMap\n * @returns {Boolean|null} result\n*/\nfunction memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {\n  // Technically, WeakMap keys can *only* be objects, not primitives.\n  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {\n    return null;\n  }\n  var leftHandMap = memoizeMap.get(leftHandOperand);\n  if (leftHandMap) {\n    var result = leftHandMap.get(rightHandOperand);\n    if (typeof result === 'boolean') {\n      return result;\n    }\n  }\n  return null;\n}\n\n/*!\n * Set the result of the equality into the MemoizeMap\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {MemoizeMap} memoizeMap\n * @param {Boolean} result\n*/\nfunction memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {\n  // Technically, WeakMap keys can *only* be objects, not primitives.\n  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {\n    return;\n  }\n  var leftHandMap = memoizeMap.get(leftHandOperand);\n  if (leftHandMap) {\n    leftHandMap.set(rightHandOperand, result);\n  } else {\n    leftHandMap = new MemoizeMap();\n    leftHandMap.set(rightHandOperand, result);\n    memoizeMap.set(leftHandOperand, leftHandMap);\n  }\n}\n\n/*!\n * Primary Export\n */\n\nmodule.exports = deepEqual;\nmodule.exports.MemoizeMap = MemoizeMap;\n\n/**\n * Assert deeply nested sameValue equality between two objects of any type.\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Object} [options] (optional) Additional options\n * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.\n * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of\n    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular\n    references to blow the stack.\n * @return {Boolean} equal match\n */\nfunction deepEqual(leftHandOperand, rightHandOperand, options) {\n  // If we have a comparator, we can't assume anything; so bail to its check first.\n  if (options && options.comparator) {\n    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);\n  }\n\n  var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);\n  if (simpleResult !== null) {\n    return simpleResult;\n  }\n\n  // Deeper comparisons are pushed through to a larger function\n  return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);\n}\n\n/**\n * Many comparisons can be canceled out early via simple equality or primitive checks.\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @return {Boolean|null} equal match\n */\nfunction simpleEqual(leftHandOperand, rightHandOperand) {\n  // Equal references (except for Numbers) can be returned early\n  if (leftHandOperand === rightHandOperand) {\n    // Handle +-0 cases\n    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;\n  }\n\n  // handle NaN cases\n  if (\n    leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare\n    rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare\n  ) {\n    return true;\n  }\n\n  // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,\n  // strings, and undefined, can be compared by reference.\n  if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {\n    // Easy out b/c it would have passed the first equality check\n    return false;\n  }\n  return null;\n}\n\n/*!\n * The main logic of the `deepEqual` function.\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Object} [options] (optional) Additional options\n * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.\n * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of\n    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular\n    references to blow the stack.\n * @return {Boolean} equal match\n*/\nfunction extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {\n  options = options || {};\n  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();\n  var comparator = options && options.comparator;\n\n  // Check if a memoized result exists.\n  var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);\n  if (memoizeResultLeft !== null) {\n    return memoizeResultLeft;\n  }\n  var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);\n  if (memoizeResultRight !== null) {\n    return memoizeResultRight;\n  }\n\n  // If a comparator is present, use it.\n  if (comparator) {\n    var comparatorResult = comparator(leftHandOperand, rightHandOperand);\n    // Comparators may return null, in which case we want to go back to default behavior.\n    if (comparatorResult === false || comparatorResult === true) {\n      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);\n      return comparatorResult;\n    }\n    // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide\n    // what to do, we need to make sure to return the basic tests first before we move on.\n    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);\n    if (simpleResult !== null) {\n      // Don't memoize this, it takes longer to set/retrieve than to just compare.\n      return simpleResult;\n    }\n  }\n\n  var leftHandType = type(leftHandOperand);\n  if (leftHandType !== type(rightHandOperand)) {\n    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);\n    return false;\n  }\n\n  // Temporarily set the operands in the memoize object to prevent blowing the stack\n  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);\n\n  var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);\n  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);\n  return result;\n}\n\nfunction extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {\n  switch (leftHandType) {\n    case 'String':\n    case 'Number':\n    case 'Boolean':\n    case 'Date':\n      // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values\n      return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());\n    case 'Promise':\n    case 'Symbol':\n    case 'function':\n    case 'WeakMap':\n    case 'WeakSet':\n    case 'Error':\n      return leftHandOperand === rightHandOperand;\n    case 'Arguments':\n    case 'Int8Array':\n    case 'Uint8Array':\n    case 'Uint8ClampedArray':\n    case 'Int16Array':\n    case 'Uint16Array':\n    case 'Int32Array':\n    case 'Uint32Array':\n    case 'Float32Array':\n    case 'Float64Array':\n    case 'Array':\n      return iterableEqual(leftHandOperand, rightHandOperand, options);\n    case 'RegExp':\n      return regexpEqual(leftHandOperand, rightHandOperand);\n    case 'Generator':\n      return generatorEqual(leftHandOperand, rightHandOperand, options);\n    case 'DataView':\n      return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);\n    case 'ArrayBuffer':\n      return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);\n    case 'Set':\n      return entriesEqual(leftHandOperand, rightHandOperand, options);\n    case 'Map':\n      return entriesEqual(leftHandOperand, rightHandOperand, options);\n    default:\n      return objectEqual(leftHandOperand, rightHandOperand, options);\n  }\n}\n\n/*!\n * Compare two Regular Expressions for equality.\n *\n * @param {RegExp} leftHandOperand\n * @param {RegExp} rightHandOperand\n * @return {Boolean} result\n */\n\nfunction regexpEqual(leftHandOperand, rightHandOperand) {\n  return leftHandOperand.toString() === rightHandOperand.toString();\n}\n\n/*!\n * Compare two Sets/Maps for equality. Faster than other equality functions.\n *\n * @param {Set} leftHandOperand\n * @param {Set} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\nfunction entriesEqual(leftHandOperand, rightHandOperand, options) {\n  // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach\n  if (leftHandOperand.size !== rightHandOperand.size) {\n    return false;\n  }\n  if (leftHandOperand.size === 0) {\n    return true;\n  }\n  var leftHandItems = [];\n  var rightHandItems = [];\n  leftHandOperand.forEach(function gatherEntries(key, value) {\n    leftHandItems.push([ key, value ]);\n  });\n  rightHandOperand.forEach(function gatherEntries(key, value) {\n    rightHandItems.push([ key, value ]);\n  });\n  return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);\n}\n\n/*!\n * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.\n *\n * @param {Iterable} leftHandOperand\n * @param {Iterable} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\nfunction iterableEqual(leftHandOperand, rightHandOperand, options) {\n  var length = leftHandOperand.length;\n  if (length !== rightHandOperand.length) {\n    return false;\n  }\n  if (length === 0) {\n    return true;\n  }\n  var index = -1;\n  while (++index < length) {\n    if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === false) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*!\n * Simple equality for generator objects such as those returned by generator functions.\n *\n * @param {Iterable} leftHandOperand\n * @param {Iterable} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\nfunction generatorEqual(leftHandOperand, rightHandOperand, options) {\n  return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);\n}\n\n/*!\n * Determine if the given object has an @@iterator function.\n *\n * @param {Object} target\n * @return {Boolean} `true` if the object has an @@iterator function.\n */\nfunction hasIteratorFunction(target) {\n  return typeof Symbol !== 'undefined' &&\n    typeof target === 'object' &&\n    typeof Symbol.iterator !== 'undefined' &&\n    typeof target[Symbol.iterator] === 'function';\n}\n\n/*!\n * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.\n * This will consume the iterator - which could have side effects depending on the @@iterator implementation.\n *\n * @param {Object} target\n * @returns {Array} an array of entries from the @@iterator function\n */\nfunction getIteratorEntries(target) {\n  if (hasIteratorFunction(target)) {\n    try {\n      return getGeneratorEntries(target[Symbol.iterator]());\n    } catch (iteratorError) {\n      return [];\n    }\n  }\n  return [];\n}\n\n/*!\n * Gets all entries from a Generator. This will consume the generator - which could have side effects.\n *\n * @param {Generator} target\n * @returns {Array} an array of entries from the Generator.\n */\nfunction getGeneratorEntries(generator) {\n  var generatorResult = generator.next();\n  var accumulator = [ generatorResult.value ];\n  while (generatorResult.done === false) {\n    generatorResult = generator.next();\n    accumulator.push(generatorResult.value);\n  }\n  return accumulator;\n}\n\n/*!\n * Gets all own and inherited enumerable keys from a target.\n *\n * @param {Object} target\n * @returns {Array} an array of own and inherited enumerable keys from the target.\n */\nfunction getEnumerableKeys(target) {\n  var keys = [];\n  for (var key in target) {\n    keys.push(key);\n  }\n  return keys;\n}\n\n/*!\n * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of\n * each key. If any value of the given key is not equal, the function will return false (early).\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\nfunction keysEqual(leftHandOperand, rightHandOperand, keys, options) {\n  var length = keys.length;\n  if (length === 0) {\n    return true;\n  }\n  for (var i = 0; i < length; i += 1) {\n    if (deepEqual(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*!\n * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`\n * for each enumerable key in the object.\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\nfunction objectEqual(leftHandOperand, rightHandOperand, options) {\n  var leftHandKeys = getEnumerableKeys(leftHandOperand);\n  var rightHandKeys = getEnumerableKeys(rightHandOperand);\n  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {\n    leftHandKeys.sort();\n    rightHandKeys.sort();\n    if (iterableEqual(leftHandKeys, rightHandKeys) === false) {\n      return false;\n    }\n    return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);\n  }\n\n  var leftHandEntries = getIteratorEntries(leftHandOperand);\n  var rightHandEntries = getIteratorEntries(rightHandOperand);\n  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {\n    leftHandEntries.sort();\n    rightHandEntries.sort();\n    return iterableEqual(leftHandEntries, rightHandEntries, options);\n  }\n\n  if (leftHandKeys.length === 0 &&\n      leftHandEntries.length === 0 &&\n      rightHandKeys.length === 0 &&\n      rightHandEntries.length === 0) {\n    return true;\n  }\n\n  return false;\n}\n\n/*!\n * Returns true if the argument is a primitive.\n *\n * This intentionally returns true for all objects that can be compared by reference,\n * including functions and symbols.\n *\n * @param {Mixed} value\n * @return {Boolean} result\n */\nfunction isPrimitive(value) {\n  return value === null || typeof value !== 'object';\n}\n\n\n//# sourceURL=webpack:///../node_modules/deep-eql/index.js?");

/***/ }),

/***/ "../node_modules/get-func-name/index.js":
/*!**********************************************!*\
  !*** ../node_modules/get-func-name/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* !\n * Chai - getFuncName utility\n * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getFuncName(constructorFn)\n *\n * Returns the name of a function.\n * When a non-function instance is passed, returns `null`.\n * This also includes a polyfill function if `aFunc.name` is not defined.\n *\n * @name getFuncName\n * @param {Function} funct\n * @namespace Utils\n * @api public\n */\n\nvar toString = Function.prototype.toString;\nvar functionNameMatch = /\\s*function(?:\\s|\\s*\\/\\*[^(?:*\\/)]+\\*\\/\\s*)*([^\\s\\(\\/]+)/;\nfunction getFuncName(aFunc) {\n  if (typeof aFunc !== 'function') {\n    return null;\n  }\n\n  var name = '';\n  if (typeof Function.prototype.name === 'undefined' && typeof aFunc.name === 'undefined') {\n    // Here we run a polyfill if Function does not support the `name` property and if aFunc.name is not defined\n    var match = toString.call(aFunc).match(functionNameMatch);\n    if (match) {\n      name = match[1];\n    }\n  } else {\n    // If we've got a `name` property we just use it\n    name = aFunc.name;\n  }\n\n  return name;\n}\n\nmodule.exports = getFuncName;\n\n\n//# sourceURL=webpack:///../node_modules/get-func-name/index.js?");

/***/ }),

/***/ "../node_modules/pathval/index.js":
/*!****************************************!*\
  !*** ../node_modules/pathval/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* !\n * Chai - pathval utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * @see https://github.com/logicalparadox/filtr\n * MIT Licensed\n */\n\n/**\n * ### .hasProperty(object, name)\n *\n * This allows checking whether an object has own\n * or inherited from prototype chain named property.\n *\n * Basically does the same thing as the `in`\n * operator but works properly with null/undefined values\n * and other primitives.\n *\n *     var obj = {\n *         arr: ['a', 'b', 'c']\n *       , str: 'Hello'\n *     }\n *\n * The following would be the results.\n *\n *     hasProperty(obj, 'str');  // true\n *     hasProperty(obj, 'constructor');  // true\n *     hasProperty(obj, 'bar');  // false\n *\n *     hasProperty(obj.str, 'length'); // true\n *     hasProperty(obj.str, 1);  // true\n *     hasProperty(obj.str, 5);  // false\n *\n *     hasProperty(obj.arr, 'length');  // true\n *     hasProperty(obj.arr, 2);  // true\n *     hasProperty(obj.arr, 3);  // false\n *\n * @param {Object} object\n * @param {String|Symbol} name\n * @returns {Boolean} whether it exists\n * @namespace Utils\n * @name hasProperty\n * @api public\n */\n\nfunction hasProperty(obj, name) {\n  if (typeof obj === 'undefined' || obj === null) {\n    return false;\n  }\n\n  // The `in` operator does not work with primitives.\n  return name in Object(obj);\n}\n\n/* !\n * ## parsePath(path)\n *\n * Helper function used to parse string object\n * paths. Use in conjunction with `internalGetPathValue`.\n *\n *      var parsed = parsePath('myobject.property.subprop');\n *\n * ### Paths:\n *\n * * Can be infinitely deep and nested.\n * * Arrays are also valid using the formal `myobject.document[3].property`.\n * * Literal dots and brackets (not delimiter) must be backslash-escaped.\n *\n * @param {String} path\n * @returns {Object} parsed\n * @api private\n */\n\nfunction parsePath(path) {\n  var str = path.replace(/([^\\\\])\\[/g, '$1.[');\n  var parts = str.match(/(\\\\\\.|[^.]+?)+/g);\n  return parts.map(function mapMatches(value) {\n    var regexp = /^\\[(\\d+)\\]$/;\n    var mArr = regexp.exec(value);\n    var parsed = null;\n    if (mArr) {\n      parsed = { i: parseFloat(mArr[1]) };\n    } else {\n      parsed = { p: value.replace(/\\\\([.\\[\\]])/g, '$1') };\n    }\n\n    return parsed;\n  });\n}\n\n/* !\n * ## internalGetPathValue(obj, parsed[, pathDepth])\n *\n * Helper companion function for `.parsePath` that returns\n * the value located at the parsed address.\n *\n *      var value = getPathValue(obj, parsed);\n *\n * @param {Object} object to search against\n * @param {Object} parsed definition from `parsePath`.\n * @param {Number} depth (nesting level) of the property we want to retrieve\n * @returns {Object|Undefined} value\n * @api private\n */\n\nfunction internalGetPathValue(obj, parsed, pathDepth) {\n  var temporaryValue = obj;\n  var res = null;\n  pathDepth = (typeof pathDepth === 'undefined' ? parsed.length : pathDepth);\n\n  for (var i = 0; i < pathDepth; i++) {\n    var part = parsed[i];\n    if (temporaryValue) {\n      if (typeof part.p === 'undefined') {\n        temporaryValue = temporaryValue[part.i];\n      } else {\n        temporaryValue = temporaryValue[part.p];\n      }\n\n      if (i === (pathDepth - 1)) {\n        res = temporaryValue;\n      }\n    }\n  }\n\n  return res;\n}\n\n/* !\n * ## internalSetPathValue(obj, value, parsed)\n *\n * Companion function for `parsePath` that sets\n * the value located at a parsed address.\n *\n *  internalSetPathValue(obj, 'value', parsed);\n *\n * @param {Object} object to search and define on\n * @param {*} value to use upon set\n * @param {Object} parsed definition from `parsePath`\n * @api private\n */\n\nfunction internalSetPathValue(obj, val, parsed) {\n  var tempObj = obj;\n  var pathDepth = parsed.length;\n  var part = null;\n  // Here we iterate through every part of the path\n  for (var i = 0; i < pathDepth; i++) {\n    var propName = null;\n    var propVal = null;\n    part = parsed[i];\n\n    // If it's the last part of the path, we set the 'propName' value with the property name\n    if (i === (pathDepth - 1)) {\n      propName = typeof part.p === 'undefined' ? part.i : part.p;\n      // Now we set the property with the name held by 'propName' on object with the desired val\n      tempObj[propName] = val;\n    } else if (typeof part.p !== 'undefined' && tempObj[part.p]) {\n      tempObj = tempObj[part.p];\n    } else if (typeof part.i !== 'undefined' && tempObj[part.i]) {\n      tempObj = tempObj[part.i];\n    } else {\n      // If the obj doesn't have the property we create one with that name to define it\n      var next = parsed[i + 1];\n      // Here we set the name of the property which will be defined\n      propName = typeof part.p === 'undefined' ? part.i : part.p;\n      // Here we decide if this property will be an array or a new object\n      propVal = typeof next.p === 'undefined' ? [] : {};\n      tempObj[propName] = propVal;\n      tempObj = tempObj[propName];\n    }\n  }\n}\n\n/**\n * ### .getPathInfo(object, path)\n *\n * This allows the retrieval of property info in an\n * object given a string path.\n *\n * The path info consists of an object with the\n * following properties:\n *\n * * parent - The parent object of the property referenced by `path`\n * * name - The name of the final property, a number if it was an array indexer\n * * value - The value of the property, if it exists, otherwise `undefined`\n * * exists - Whether the property exists or not\n *\n * @param {Object} object\n * @param {String} path\n * @returns {Object} info\n * @namespace Utils\n * @name getPathInfo\n * @api public\n */\n\nfunction getPathInfo(obj, path) {\n  var parsed = parsePath(path);\n  var last = parsed[parsed.length - 1];\n  var info = {\n    parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,\n    name: last.p || last.i,\n    value: internalGetPathValue(obj, parsed),\n  };\n  info.exists = hasProperty(info.parent, info.name);\n\n  return info;\n}\n\n/**\n * ### .getPathValue(object, path)\n *\n * This allows the retrieval of values in an\n * object given a string path.\n *\n *     var obj = {\n *         prop1: {\n *             arr: ['a', 'b', 'c']\n *           , str: 'Hello'\n *         }\n *       , prop2: {\n *             arr: [ { nested: 'Universe' } ]\n *           , str: 'Hello again!'\n *         }\n *     }\n *\n * The following would be the results.\n *\n *     getPathValue(obj, 'prop1.str'); // Hello\n *     getPathValue(obj, 'prop1.att[2]'); // b\n *     getPathValue(obj, 'prop2.arr[0].nested'); // Universe\n *\n * @param {Object} object\n * @param {String} path\n * @returns {Object} value or `undefined`\n * @namespace Utils\n * @name getPathValue\n * @api public\n */\n\nfunction getPathValue(obj, path) {\n  var info = getPathInfo(obj, path);\n  return info.value;\n}\n\n/**\n * ### .setPathValue(object, path, value)\n *\n * Define the value in an object at a given string path.\n *\n * ```js\n * var obj = {\n *     prop1: {\n *         arr: ['a', 'b', 'c']\n *       , str: 'Hello'\n *     }\n *   , prop2: {\n *         arr: [ { nested: 'Universe' } ]\n *       , str: 'Hello again!'\n *     }\n * };\n * ```\n *\n * The following would be acceptable.\n *\n * ```js\n * var properties = require('tea-properties');\n * properties.set(obj, 'prop1.str', 'Hello Universe!');\n * properties.set(obj, 'prop1.arr[2]', 'B');\n * properties.set(obj, 'prop2.arr[0].nested.value', { hello: 'universe' });\n * ```\n *\n * @param {Object} object\n * @param {String} path\n * @param {Mixed} value\n * @api private\n */\n\nfunction setPathValue(obj, path, val) {\n  var parsed = parsePath(path);\n  internalSetPathValue(obj, val, parsed);\n  return obj;\n}\n\nmodule.exports = {\n  hasProperty: hasProperty,\n  getPathInfo: getPathInfo,\n  getPathValue: getPathValue,\n  setPathValue: setPathValue,\n};\n\n\n//# sourceURL=webpack:///../node_modules/pathval/index.js?");

/***/ }),

/***/ "../node_modules/process/browser.js":
/*!******************************************!*\
  !*** ../node_modules/process/browser.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///../node_modules/process/browser.js?");

/***/ }),

/***/ "../node_modules/setimmediate/setImmediate.js":
/*!****************************************************!*\
  !*** ../node_modules/setimmediate/setImmediate.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"../node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"../node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///../node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "../node_modules/timers-browserify/main.js":
/*!*************************************************!*\
  !*** ../node_modules/timers-browserify/main.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"../node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"../node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///../node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "../node_modules/type-detect/type-detect.js":
/*!**************************************************!*\
  !*** ../node_modules/type-detect/type-detect.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {(function (global, factory) {\n\t true ? module.exports = factory() :\n\tundefined;\n}(this, (function () { 'use strict';\n\n/* !\n * type-detect\n * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\nvar promiseExists = typeof Promise === 'function';\n\n/* eslint-disable no-undef */\nvar globalObject = typeof self === 'object' ? self : global; // eslint-disable-line id-blacklist\n\nvar symbolExists = typeof Symbol !== 'undefined';\nvar mapExists = typeof Map !== 'undefined';\nvar setExists = typeof Set !== 'undefined';\nvar weakMapExists = typeof WeakMap !== 'undefined';\nvar weakSetExists = typeof WeakSet !== 'undefined';\nvar dataViewExists = typeof DataView !== 'undefined';\nvar symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';\nvar symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';\nvar setEntriesExists = setExists && typeof Set.prototype.entries === 'function';\nvar mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';\nvar setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());\nvar mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());\nvar arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';\nvar arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());\nvar stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === 'function';\nvar stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());\nvar toStringLeftSliceLength = 8;\nvar toStringRightSliceLength = -1;\n/**\n * ### typeOf (obj)\n *\n * Uses `Object.prototype.toString` to determine the type of an object,\n * normalising behaviour across engine versions & well optimised.\n *\n * @param {Mixed} object\n * @return {String} object type\n * @api public\n */\nfunction typeDetect(obj) {\n  /* ! Speed optimisation\n   * Pre:\n   *   string literal     x 3,039,035 ops/sec 1.62% (78 runs sampled)\n   *   boolean literal    x 1,424,138 ops/sec 4.54% (75 runs sampled)\n   *   number literal     x 1,653,153 ops/sec 1.91% (82 runs sampled)\n   *   undefined          x 9,978,660 ops/sec 1.92% (75 runs sampled)\n   *   function           x 2,556,769 ops/sec 1.73% (77 runs sampled)\n   * Post:\n   *   string literal     x 38,564,796 ops/sec 1.15% (79 runs sampled)\n   *   boolean literal    x 31,148,940 ops/sec 1.10% (79 runs sampled)\n   *   number literal     x 32,679,330 ops/sec 1.90% (78 runs sampled)\n   *   undefined          x 32,363,368 ops/sec 1.07% (82 runs sampled)\n   *   function           x 31,296,870 ops/sec 0.96% (83 runs sampled)\n   */\n  var typeofObj = typeof obj;\n  if (typeofObj !== 'object') {\n    return typeofObj;\n  }\n\n  /* ! Speed optimisation\n   * Pre:\n   *   null               x 28,645,765 ops/sec 1.17% (82 runs sampled)\n   * Post:\n   *   null               x 36,428,962 ops/sec 1.37% (84 runs sampled)\n   */\n  if (obj === null) {\n    return 'null';\n  }\n\n  /* ! Spec Conformance\n   * Test: `Object.prototype.toString.call(window)``\n   *  - Node === \"[object global]\"\n   *  - Chrome === \"[object global]\"\n   *  - Firefox === \"[object Window]\"\n   *  - PhantomJS === \"[object Window]\"\n   *  - Safari === \"[object Window]\"\n   *  - IE 11 === \"[object Window]\"\n   *  - IE Edge === \"[object Window]\"\n   * Test: `Object.prototype.toString.call(this)``\n   *  - Chrome Worker === \"[object global]\"\n   *  - Firefox Worker === \"[object DedicatedWorkerGlobalScope]\"\n   *  - Safari Worker === \"[object DedicatedWorkerGlobalScope]\"\n   *  - IE 11 Worker === \"[object WorkerGlobalScope]\"\n   *  - IE Edge Worker === \"[object WorkerGlobalScope]\"\n   */\n  if (obj === globalObject) {\n    return 'global';\n  }\n\n  /* ! Speed optimisation\n   * Pre:\n   *   array literal      x 2,888,352 ops/sec 0.67% (82 runs sampled)\n   * Post:\n   *   array literal      x 22,479,650 ops/sec 0.96% (81 runs sampled)\n   */\n  if (\n    Array.isArray(obj) &&\n    (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))\n  ) {\n    return 'Array';\n  }\n\n  // Not caching existence of `window` and related properties due to potential\n  // for `window` to be unset before tests in quasi-browser environments.\n  if (typeof window === 'object' && window !== null) {\n    /* ! Spec Conformance\n     * (https://html.spec.whatwg.org/multipage/browsers.html#location)\n     * WhatWG HTML$7.7.3 - The `Location` interface\n     * Test: `Object.prototype.toString.call(window.location)``\n     *  - IE <=11 === \"[object Object]\"\n     *  - IE Edge <=13 === \"[object Object]\"\n     */\n    if (typeof window.location === 'object' && obj === window.location) {\n      return 'Location';\n    }\n\n    /* ! Spec Conformance\n     * (https://html.spec.whatwg.org/#document)\n     * WhatWG HTML$3.1.1 - The `Document` object\n     * Note: Most browsers currently adher to the W3C DOM Level 2 spec\n     *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)\n     *       which suggests that browsers should use HTMLTableCellElement for\n     *       both TD and TH elements. WhatWG separates these.\n     *       WhatWG HTML states:\n     *         > For historical reasons, Window objects must also have a\n     *         > writable, configurable, non-enumerable property named\n     *         > HTMLDocument whose value is the Document interface object.\n     * Test: `Object.prototype.toString.call(document)``\n     *  - Chrome === \"[object HTMLDocument]\"\n     *  - Firefox === \"[object HTMLDocument]\"\n     *  - Safari === \"[object HTMLDocument]\"\n     *  - IE <=10 === \"[object Document]\"\n     *  - IE 11 === \"[object HTMLDocument]\"\n     *  - IE Edge <=13 === \"[object HTMLDocument]\"\n     */\n    if (typeof window.document === 'object' && obj === window.document) {\n      return 'Document';\n    }\n\n    if (typeof window.navigator === 'object') {\n      /* ! Spec Conformance\n       * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)\n       * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray\n       * Test: `Object.prototype.toString.call(navigator.mimeTypes)``\n       *  - IE <=10 === \"[object MSMimeTypesCollection]\"\n       */\n      if (typeof window.navigator.mimeTypes === 'object' &&\n          obj === window.navigator.mimeTypes) {\n        return 'MimeTypeArray';\n      }\n\n      /* ! Spec Conformance\n       * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)\n       * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray\n       * Test: `Object.prototype.toString.call(navigator.plugins)``\n       *  - IE <=10 === \"[object MSPluginsCollection]\"\n       */\n      if (typeof window.navigator.plugins === 'object' &&\n          obj === window.navigator.plugins) {\n        return 'PluginArray';\n      }\n    }\n\n    if ((typeof window.HTMLElement === 'function' ||\n        typeof window.HTMLElement === 'object') &&\n        obj instanceof window.HTMLElement) {\n      /* ! Spec Conformance\n      * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)\n      * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`\n      * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``\n      *  - IE <=10 === \"[object HTMLBlockElement]\"\n      */\n      if (obj.tagName === 'BLOCKQUOTE') {\n        return 'HTMLQuoteElement';\n      }\n\n      /* ! Spec Conformance\n       * (https://html.spec.whatwg.org/#htmltabledatacellelement)\n       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`\n       * Note: Most browsers currently adher to the W3C DOM Level 2 spec\n       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)\n       *       which suggests that browsers should use HTMLTableCellElement for\n       *       both TD and TH elements. WhatWG separates these.\n       * Test: Object.prototype.toString.call(document.createElement('td'))\n       *  - Chrome === \"[object HTMLTableCellElement]\"\n       *  - Firefox === \"[object HTMLTableCellElement]\"\n       *  - Safari === \"[object HTMLTableCellElement]\"\n       */\n      if (obj.tagName === 'TD') {\n        return 'HTMLTableDataCellElement';\n      }\n\n      /* ! Spec Conformance\n       * (https://html.spec.whatwg.org/#htmltableheadercellelement)\n       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`\n       * Note: Most browsers currently adher to the W3C DOM Level 2 spec\n       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)\n       *       which suggests that browsers should use HTMLTableCellElement for\n       *       both TD and TH elements. WhatWG separates these.\n       * Test: Object.prototype.toString.call(document.createElement('th'))\n       *  - Chrome === \"[object HTMLTableCellElement]\"\n       *  - Firefox === \"[object HTMLTableCellElement]\"\n       *  - Safari === \"[object HTMLTableCellElement]\"\n       */\n      if (obj.tagName === 'TH') {\n        return 'HTMLTableHeaderCellElement';\n      }\n    }\n  }\n\n  /* ! Speed optimisation\n  * Pre:\n  *   Float64Array       x 625,644 ops/sec 1.58% (80 runs sampled)\n  *   Float32Array       x 1,279,852 ops/sec 2.91% (77 runs sampled)\n  *   Uint32Array        x 1,178,185 ops/sec 1.95% (83 runs sampled)\n  *   Uint16Array        x 1,008,380 ops/sec 2.25% (80 runs sampled)\n  *   Uint8Array         x 1,128,040 ops/sec 2.11% (81 runs sampled)\n  *   Int32Array         x 1,170,119 ops/sec 2.88% (80 runs sampled)\n  *   Int16Array         x 1,176,348 ops/sec 5.79% (86 runs sampled)\n  *   Int8Array          x 1,058,707 ops/sec 4.94% (77 runs sampled)\n  *   Uint8ClampedArray  x 1,110,633 ops/sec 4.20% (80 runs sampled)\n  * Post:\n  *   Float64Array       x 7,105,671 ops/sec 13.47% (64 runs sampled)\n  *   Float32Array       x 5,887,912 ops/sec 1.46% (82 runs sampled)\n  *   Uint32Array        x 6,491,661 ops/sec 1.76% (79 runs sampled)\n  *   Uint16Array        x 6,559,795 ops/sec 1.67% (82 runs sampled)\n  *   Uint8Array         x 6,463,966 ops/sec 1.43% (85 runs sampled)\n  *   Int32Array         x 5,641,841 ops/sec 3.49% (81 runs sampled)\n  *   Int16Array         x 6,583,511 ops/sec 1.98% (80 runs sampled)\n  *   Int8Array          x 6,606,078 ops/sec 1.74% (81 runs sampled)\n  *   Uint8ClampedArray  x 6,602,224 ops/sec 1.77% (83 runs sampled)\n  */\n  var stringTag = (symbolToStringTagExists && obj[Symbol.toStringTag]);\n  if (typeof stringTag === 'string') {\n    return stringTag;\n  }\n\n  var objPrototype = Object.getPrototypeOf(obj);\n  /* ! Speed optimisation\n  * Pre:\n  *   regex literal      x 1,772,385 ops/sec 1.85% (77 runs sampled)\n  *   regex constructor  x 2,143,634 ops/sec 2.46% (78 runs sampled)\n  * Post:\n  *   regex literal      x 3,928,009 ops/sec 0.65% (78 runs sampled)\n  *   regex constructor  x 3,931,108 ops/sec 0.58% (84 runs sampled)\n  */\n  if (objPrototype === RegExp.prototype) {\n    return 'RegExp';\n  }\n\n  /* ! Speed optimisation\n  * Pre:\n  *   date               x 2,130,074 ops/sec 4.42% (68 runs sampled)\n  * Post:\n  *   date               x 3,953,779 ops/sec 1.35% (77 runs sampled)\n  */\n  if (objPrototype === Date.prototype) {\n    return 'Date';\n  }\n\n  /* ! Spec Conformance\n   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)\n   * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be \"Promise\":\n   * Test: `Object.prototype.toString.call(Promise.resolve())``\n   *  - Chrome <=47 === \"[object Object]\"\n   *  - Edge <=20 === \"[object Object]\"\n   *  - Firefox 29-Latest === \"[object Promise]\"\n   *  - Safari 7.1-Latest === \"[object Promise]\"\n   */\n  if (promiseExists && objPrototype === Promise.prototype) {\n    return 'Promise';\n  }\n\n  /* ! Speed optimisation\n  * Pre:\n  *   set                x 2,222,186 ops/sec 1.31% (82 runs sampled)\n  * Post:\n  *   set                x 4,545,879 ops/sec 1.13% (83 runs sampled)\n  */\n  if (setExists && objPrototype === Set.prototype) {\n    return 'Set';\n  }\n\n  /* ! Speed optimisation\n  * Pre:\n  *   map                x 2,396,842 ops/sec 1.59% (81 runs sampled)\n  * Post:\n  *   map                x 4,183,945 ops/sec 6.59% (82 runs sampled)\n  */\n  if (mapExists && objPrototype === Map.prototype) {\n    return 'Map';\n  }\n\n  /* ! Speed optimisation\n  * Pre:\n  *   weakset            x 1,323,220 ops/sec 2.17% (76 runs sampled)\n  * Post:\n  *   weakset            x 4,237,510 ops/sec 2.01% (77 runs sampled)\n  */\n  if (weakSetExists && objPrototype === WeakSet.prototype) {\n    return 'WeakSet';\n  }\n\n  /* ! Speed optimisation\n  * Pre:\n  *   weakmap            x 1,500,260 ops/sec 2.02% (78 runs sampled)\n  * Post:\n  *   weakmap            x 3,881,384 ops/sec 1.45% (82 runs sampled)\n  */\n  if (weakMapExists && objPrototype === WeakMap.prototype) {\n    return 'WeakMap';\n  }\n\n  /* ! Spec Conformance\n   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)\n   * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be \"DataView\":\n   * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``\n   *  - Edge <=13 === \"[object Object]\"\n   */\n  if (dataViewExists && objPrototype === DataView.prototype) {\n    return 'DataView';\n  }\n\n  /* ! Spec Conformance\n   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)\n   * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be \"Map Iterator\":\n   * Test: `Object.prototype.toString.call(new Map().entries())``\n   *  - Edge <=13 === \"[object Object]\"\n   */\n  if (mapExists && objPrototype === mapIteratorPrototype) {\n    return 'Map Iterator';\n  }\n\n  /* ! Spec Conformance\n   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)\n   * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be \"Set Iterator\":\n   * Test: `Object.prototype.toString.call(new Set().entries())``\n   *  - Edge <=13 === \"[object Object]\"\n   */\n  if (setExists && objPrototype === setIteratorPrototype) {\n    return 'Set Iterator';\n  }\n\n  /* ! Spec Conformance\n   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)\n   * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be \"Array Iterator\":\n   * Test: `Object.prototype.toString.call([][Symbol.iterator]())``\n   *  - Edge <=13 === \"[object Object]\"\n   */\n  if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {\n    return 'Array Iterator';\n  }\n\n  /* ! Spec Conformance\n   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)\n   * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be \"String Iterator\":\n   * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``\n   *  - Edge <=13 === \"[object Object]\"\n   */\n  if (stringIteratorExists && objPrototype === stringIteratorPrototype) {\n    return 'String Iterator';\n  }\n\n  /* ! Speed optimisation\n  * Pre:\n  *   object from null   x 2,424,320 ops/sec 1.67% (76 runs sampled)\n  * Post:\n  *   object from null   x 5,838,000 ops/sec 0.99% (84 runs sampled)\n  */\n  if (objPrototype === null) {\n    return 'Object';\n  }\n\n  return Object\n    .prototype\n    .toString\n    .call(obj)\n    .slice(toStringLeftSliceLength, toStringRightSliceLength);\n}\n\nreturn typeDetect;\n\n})));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"../node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///../node_modules/type-detect/type-detect.js?");

/***/ }),

/***/ "../node_modules/webpack/buildin/global.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///../node_modules/webpack/buildin/global.js?");

/***/ }),

/***/ "../types/std.types.json":
/*!*******************************!*\
  !*** ../types/std.types.json ***!
  \*******************************/
/*! exports provided: Type, Object, Function, null, Bool, Char, Int, UInt, Long, ULong, Float, Double, type_attribute, Array, String, Map, Tensor, Random, Ref, Geocode, Date, DurationUnit, Duration, Enum, Time, Ctx, Blob, Number, Console, Log, Math, Assert, Node, Graph, TimeWindow, FileMode, File, GeoCodeIndex, GeoShape, Benchmark, Json, CGOperator, CGOptimizer, CGInitializer, CalcGraph, CGTarget, CGHeap, Process, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"Type\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"of\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"exists\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"String\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Bool\\\"]}}}},\\\"Object\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":false,\\\"is_open\\\":true,\\\"is_enum\\\":false,\\\"properties\\\":{}},\\\"Function\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{}},\\\"null\\\":{\\\"is_primitive\\\":true,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{}},\\\"Bool\\\":{\\\"is_primitive\\\":true,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{}},\\\"Char\\\":{\\\"is_primitive\\\":true,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{}},\\\"Int\\\":{\\\"is_primitive\\\":true,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"min\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Int\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":-2147483648},\\\"max\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Int\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":2147483647}}},\\\"UInt\\\":{\\\"is_primitive\\\":true,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"min\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"UInt\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":0},\\\"max\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"UInt\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":4294967295}}},\\\"Long\\\":{\\\"is_primitive\\\":true,\\\"is_abstract\\\":false,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"min\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Long\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":-9223372036854776000},\\\"max\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Long\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":9223372036854776000}}},\\\"ULong\\\":{\\\"is_primitive\\\":true,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"min\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"ULong\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":0},\\\"max\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"ULong\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":18446744073709552000}}},\\\"Float\\\":{\\\"is_primitive\\\":true,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"min\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Float\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":-3.4028234663852886e+38},\\\"max\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Float\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":3.4028234663852886e+38}}},\\\"Double\\\":{\\\"is_primitive\\\":true,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"min\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Double\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":-1.7976931348623157e+308},\\\"max\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Double\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":1.7976931348623157e+308}}},\\\"type_attribute\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{}},\\\"Array\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":false,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"foreach\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"sub\\\",\\\"type\\\":[\\\"Function\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"add\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"set\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"i\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"resize\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"init\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"swap\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"i\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"j\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"sort\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}},\\\"size\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}}}},\\\"String\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":false,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"compare\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"String\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Int\\\"]}},\\\"startsWith\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"String\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"endsWith\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"String\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"add\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"get\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Char\\\"]}},\\\"trim\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}},\\\"slice\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"from\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"to\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"String\\\",\\\"null\\\"]}},\\\"indexOf\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"String\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Int\\\"]}},\\\"lowercase\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}},\\\"uppercase\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}},\\\"size\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}},\\\"clone\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}},\\\"clear\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}}}},\\\"Map\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":false,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"foreach\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"sub\\\",\\\"type\\\":[\\\"Function\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"put\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"key\\\",\\\"type\\\":[\\\"String\\\",\\\"Number\\\",\\\"Geocode\\\",\\\"Date\\\",\\\"Ref\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"set\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"key\\\",\\\"type\\\":[\\\"String\\\",\\\"Number\\\",\\\"Geocode\\\",\\\"Date\\\",\\\"Ref\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"get\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"key\\\",\\\"type\\\":[\\\"String\\\",\\\"Number\\\",\\\"Geocode\\\",\\\"Date\\\",\\\"Ref\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Any\\\"]}},\\\"mget\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"key\\\",\\\"type\\\":[\\\"String\\\",\\\"Number\\\",\\\"Geocode\\\",\\\"Date\\\",\\\"Ref\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"sub\\\",\\\"type\\\":[\\\"Function\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"remove\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"key\\\",\\\"type\\\":[\\\"String\\\",\\\"Number\\\",\\\"Geocode\\\",\\\"Date\\\",\\\"Ref\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Bool\\\"]}},\\\"keys\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"Array\\\"]}},\\\"size\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}}}},\\\"Tensor\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":false,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"set\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"offsets\\\",\\\"type\\\":[\\\"Array\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"random\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Random\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"addToElement\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"offsets\\\",\\\"type\\\":[\\\"Array\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"get\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"offsets\\\",\\\"type\\\":[\\\"Array\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Number\\\"]}},\\\"init\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"dim\\\",\\\"type\\\":[\\\"Array\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"type\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"allocate\\\",\\\"type\\\":[\\\"Bool\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"print\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}},\\\"ndim\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"Number\\\"]}},\\\"shape\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"Array\\\"]}},\\\"append\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"copyData\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"position\\\",\\\"type\\\":[\\\"Int\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Blob\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"size\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"incrementIndex\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"offsets\\\",\\\"type\\\":[\\\"Array\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Bool\\\"]}},\\\"clone\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"sin\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"cos\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"tan\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"sinh\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"cosh\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"tanh\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"sqrt\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"abs\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"lecun_tanh\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"exp\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"log\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"selu\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"sigmoid\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"hard_sigmoid\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"softplus\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"softsign\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"add\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"value2\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"sub\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"value2\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"hadamardProduct\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"value2\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"pow\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"alpha\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"relu\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"alpha\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"max\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"threshold\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"elu\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"alpha\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"scale\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"value2\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"matmul\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"value2\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"transposeA\\\",\\\"type\\\":[\\\"Bool\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"transposeB\\\",\\\"type\\\":[\\\"Bool\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"alpha\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"beta\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"transpose\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Tensor\\\"]}},\\\"sum\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"transpose\\\",\\\"type\\\":[\\\"Bool\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"rain\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"timespan\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"sumsq\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"transpose\\\",\\\"type\\\":[\\\"Bool\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"pearson\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"sumA\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"sumsqA\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"sumB\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"sumsqB\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"transpose\\\",\\\"type\\\":[\\\"Bool\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"AB\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"timepoint\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}}}},\\\"Random\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":false,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"seed\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Long\\\",\\\"is_static\\\":true,\\\"is_private\\\":false},\\\"value\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Double\\\",\\\"is_static\\\":true,\\\"is_private\\\":false},\\\"value2\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Float\\\",\\\"is_static\\\":true,\\\"is_private\\\":false},\\\"init\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"seed\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"nextDouble\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"min\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"max\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Double\\\"]}},\\\"nextGaussianDouble\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"mean\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"std\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Double\\\"]}},\\\"nextInt\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"min\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"max\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Int\\\"]}},\\\"nextLong\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"min\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"max\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Long\\\"]}},\\\"nextFloat\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"min\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"max\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Float\\\"]}},\\\"nextGaussianFloat\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"mean\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"std\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Float\\\"]}},\\\"shuffle\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Array\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Array\\\"]}}}},\\\"Ref\\\":{\\\"is_primitive\\\":true,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{}},\\\"Geocode\\\":{\\\"is_primitive\\\":true,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"from\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"String\\\",\\\"Object\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Geocode\\\"]}},\\\"root\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"values\\\",\\\"type\\\":[\\\"Array\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Geocode\\\"]}},\\\"north\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"Geocode\\\"]}},\\\"south\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"Geocode\\\"]}},\\\"east\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"Geocode\\\"]}},\\\"west\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"Geocode\\\"]}},\\\"toPosition\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"Object\\\"]}},\\\"distance\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Geocode\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Double\\\"]}}}},\\\"Date\\\":{\\\"is_primitive\\\":true,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"now\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"Date\\\"]}},\\\"beginOfTime\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"Date\\\"]}},\\\"endOfTime\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"Date\\\"]}},\\\"parse\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"String\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"format\\\",\\\"type\\\":[\\\"String\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Date\\\"]}},\\\"new\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Date\\\"],\\\"doc\\\":\\\"creates a Date from epoch timestamp in milliseconds\\\"}},\\\"toLocale\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"String\\\"]}},\\\"toTimestamp\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"Long\\\"]}},\\\"weeks\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"Long\\\"]}},\\\"months\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"Long\\\"]}}}},\\\"DurationUnit\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":false,\\\"is_open\\\":false,\\\"is_enum\\\":true,\\\"properties\\\":{\\\"fromValue\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"DurationUnit\\\",\\\"null\\\"]}},\\\"getValue\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"DurationUnit\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Any\\\",\\\"null\\\"]}},\\\"milliseconds\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Int\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":0},\\\"seconds\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Int\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":1},\\\"minutes\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Int\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":2},\\\"hours\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Int\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":3},\\\"days\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Int\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":4},\\\"weeks\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Int\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":5},\\\"months\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Int\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":6},\\\"years\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Int\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":7}}},\\\"Duration\\\":{\\\"is_primitive\\\":true,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"of\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"value2\\\",\\\"type\\\":[\\\"DurationUnit\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Duration\\\"],\\\"doc\\\":\\\"create Duration from duration and unit\\\"}}}},\\\"Enum\\\":{\\\"is_primitive\\\":true,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{}},\\\"Time\\\":{\\\"is_primitive\\\":true,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"get\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}}}},\\\"Ctx\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{}},\\\"Blob\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":false,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"size\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}},\\\"get\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"i\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Int\\\"]}},\\\"init\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}}}},\\\"Number\\\":{\\\"is_primitive\\\":true,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"parse\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"String\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Number\\\"]}}}},\\\"Console\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"print\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"println\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"flush\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}},\\\"readLine\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"String\\\"]}}}},\\\"Log\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"configure\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"path\\\",\\\"type\\\":[\\\"String\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"info\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"name\\\",\\\"type\\\":[\\\"String\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"error\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"name\\\",\\\"type\\\":[\\\"String\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"warn\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"name\\\",\\\"type\\\":[\\\"String\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"debug\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"name\\\",\\\"type\\\":[\\\"String\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"any\\\"]}}}},\\\"Math\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"cos\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"x\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"sin\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"x\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"tan\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"x\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"sqrt\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"x\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"floor\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"x\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"ceil\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"x\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"cosh\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"x\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"sinh\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"x\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"tanh\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"x\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"acos\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"x\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"asin\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"x\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"atan\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"x\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"log\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"x\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"log2\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"x\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"log10\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"x\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"pow\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"x\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"y\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"trunc\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"x\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"round\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"x\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"min\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"x\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"y\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"max\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"x\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"y\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"abs\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"x\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"E\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Double\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":2.718282},\\\"LOG2E\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Double\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":1.442695},\\\"LOG10E\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Double\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":0.434294},\\\"LN2\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Double\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":0.693147},\\\"LN10\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Double\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":2.302585},\\\"PI\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Double\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":3.141593},\\\"PI_2\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Double\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":1.570796},\\\"PI_4\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Double\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":0.785398},\\\"1_PI\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Double\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":0.31831},\\\"2_PI\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Double\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":0.63662},\\\"2_SQRTPI\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Double\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":1.128379},\\\"SQRT2\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Double\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":1.414214},\\\"SQRT1_2\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Double\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":0.707107}}},\\\"Assert\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"equals\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"value2\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"equalsd\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"value2\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"epsilon\\\",\\\"type\\\":[\\\"Double\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"isTrue\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Bool\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"isFalse\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Bool\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"isNull\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"isNotNull\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}}}},\\\"Node\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"resolvedTime\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Ref\\\",\\\"Object\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"debug\\\",\\\"type\\\":[\\\"Bool\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Date\\\",\\\"null\\\"]}},\\\"resolve\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Ref\\\",\\\"Object\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"newTime\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"src\\\",\\\"type\\\":[\\\"Ref\\\",\\\"Object\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"validity\\\",\\\"type\\\":[\\\"Duration\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"maxLevel\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Ref\\\",\\\"Object\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"foreachTime\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"src\\\",\\\"type\\\":[\\\"Ref\\\",\\\"Object\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"from\\\",\\\"type\\\":[\\\"Date\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"to\\\",\\\"type\\\":[\\\"Date\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"max\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"step\\\",\\\"type\\\":[\\\"Duration\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"sub\\\",\\\"type\\\":[\\\"Function\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"],\\\"doc\\\":\\\"iterates over all temporal values, boundaries and steps can be specified using optional parameters\\\"}}}},\\\"Graph\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":true,\\\"is_open\\\":true,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"root\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"Object\\\"]}},\\\"version\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"String\\\"]}},\\\"fullVersion\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"String\\\"]}},\\\"push\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}},\\\"save\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}},\\\"setAutoSync\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Bool\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"configureStore\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"store\\\",\\\"type\\\":[\\\"Int\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"path\\\",\\\"type\\\":[\\\"String\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"compression\\\",\\\"type\\\":[\\\"Bool\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"readOnly\\\",\\\"type\\\":[\\\"Bool\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"options\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"prefetch\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"from\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"String\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Any\\\"]}},\\\"newNode\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"store\\\",\\\"type\\\":[\\\"Int\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Ref\\\"]}},\\\"isNode\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Object\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Bool\\\"]}}}},\\\"TimeWindow\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":false,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"setWidth\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"add\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"timepoint\\\",\\\"type\\\":[\\\"Date\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"size\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}},\\\"sum\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}},\\\"avg\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}},\\\"clear\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}},\\\"min\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}},\\\"max\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}},\\\"std\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}}}},\\\"FileMode\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":false,\\\"is_open\\\":false,\\\"is_enum\\\":true,\\\"properties\\\":{\\\"fromValue\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"FileMode\\\",\\\"null\\\"]}},\\\"getValue\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"FileMode\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Any\\\",\\\"null\\\"]}},\\\"read\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Int\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":0},\\\"write\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Int\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":1},\\\"append\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Int\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":2}}},\\\"File\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"isDirectory\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"Bool\\\"]}},\\\"open\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"path\\\",\\\"type\\\":[\\\"String\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"sep\\\",\\\"type\\\":[\\\"String\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"decSep\\\",\\\"type\\\":[\\\"String\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"thSep\\\",\\\"type\\\":[\\\"String\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"mode\\\",\\\"type\\\":[\\\"FileMode\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"offsets\\\",\\\"type\\\":[\\\"Array\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"File\\\",\\\"null\\\"]}},\\\"readAll\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"String\\\"],\\\"doc\\\":\\\"returns the content of the file as a string\\\"}},\\\"delete\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}},\\\"foreach\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"sub\\\",\\\"type\\\":[\\\"Function\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"max\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"write\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"writeln\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}}}},\\\"GeoCodeIndex\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":false,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"add\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"key\\\",\\\"type\\\":[\\\"Geocode\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"get\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"key\\\",\\\"type\\\":[\\\"Geocode\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"size\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}},\\\"startsWith\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"key\\\",\\\"type\\\":[\\\"Geocode\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"searchWithin\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Geocode\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"value2\\\",\\\"type\\\":[\\\"Geocode\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}}}},\\\"GeoShape\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":false,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"overlap\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"GeoShape\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Bool\\\"],\\\"doc\\\":\\\"SQL function:\\\\tgeopoly_overlap(P1,P2)\\\\nDetermine whether or not P1 and P2 overlap.\\\\nReturn value:\\\\n  0     The two polygons are disjoint\\\\n  1     They overlap\\\\n  2     P1 is completely contained within P2\\\\n  3     P2 is completely contained within P1\\\\n  4     P1 and P2 are the same polygon\\\\n  NULL  Either P1 or P2 or both are not valid polygons\\\\n\\\"}},\\\"equal\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"GeoShape\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Bool\\\"]}},\\\"contains\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Object\\\",\\\"GeoShape\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Bool\\\"]}},\\\"containedBy\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"GeoShape\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Bool\\\"]}},\\\"on\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Object\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Bool\\\"]}},\\\"in\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Object\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Bool\\\"]}},\\\"size\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"Int\\\"]}}}},\\\"Benchmark\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":false,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"startTime\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Long\\\",\\\"is_static\\\":true,\\\"is_private\\\":false},\\\"stopTime\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Long\\\",\\\"is_static\\\":true,\\\"is_private\\\":false},\\\"iteration\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Long\\\",\\\"is_static\\\":true,\\\"is_private\\\":false},\\\"speed\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"iteration\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"cycleTime\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"iteration\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"start\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}},\\\"stop\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"maxIterations\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"reset\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"any\\\"]}},\\\"reportProgress\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"iteration\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"maxIterations\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"step\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}}}},\\\"Json\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":false,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"parse\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"String\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"withMeta\\\",\\\"type\\\":[\\\"Bool\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"Array\\\",\\\"Object\\\",\\\"Bool\\\",\\\"String\\\",\\\"null\\\",\\\"Number\\\"]}}}},\\\"CGOperator\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":false,\\\"is_open\\\":false,\\\"is_enum\\\":true,\\\"properties\\\":{\\\"fromValue\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"CGOperator\\\",\\\"null\\\"]}},\\\"getValue\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"CGOperator\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Any\\\",\\\"null\\\"]}},\\\"add\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Int\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":24},\\\"sub\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Int\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":25},\\\"matmul\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Int\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":31}}},\\\"CGOptimizer\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":false,\\\"is_open\\\":true,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"optimizerCode\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Int\\\",\\\"is_static\\\":true,\\\"is_private\\\":false},\\\"none\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"CGOptimizer\\\"]}},\\\"adadelta\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"rho\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"smoothEpsilon\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"CGOptimizer\\\"]}},\\\"adagrad\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"learningRate\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"initialAccumulator\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"smoothEpsilon\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"CGOptimizer\\\"]}},\\\"adam\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"learningRate\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"beta1\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"beta2\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"smoothEpsilon\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"CGOptimizer\\\"]}},\\\"adamax\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"learningRate\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"beta1\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"beta2\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"smoothEpsilon\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"CGOptimizer\\\"]}},\\\"ftrl\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"learningRate\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"lambda1\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"beta\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"CGOptimizer\\\"]}},\\\"nadam\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"learningRate\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"beta1\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"beta2\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"smoothEpsilon\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"CGOptimizer\\\"]}},\\\"rmsprop\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"learningRate\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"decayRate\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"smoothEpsilon\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"CGOptimizer\\\"]}},\\\"sgd\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"learningRate\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"CGOptimizer\\\"]}},\\\"momentum\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"learningRate\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"decayRate\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"CGOptimizer\\\"]}},\\\"nesterov\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"learningRate\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"decayRate\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"CGOptimizer\\\"]}}}},\\\"CGInitializer\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":false,\\\"is_open\\\":true,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"initializerCode\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Int\\\",\\\"is_static\\\":true,\\\"is_private\\\":false},\\\"none\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"CGInitializer\\\"]}},\\\"gaussian\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"mean\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"std\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"CGInitializer\\\"]}},\\\"zero\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"CGInitializer\\\"]}},\\\"one\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"CGInitializer\\\"]}},\\\"sigmoid_uniform\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"CGInitializer\\\"]}},\\\"normal\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"CGInitializer\\\"]}},\\\"uniform\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"min\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"max\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"CGInitializer\\\"]}},\\\"lecun_uniform\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"CGInitializer\\\"]}},\\\"xavier\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"CGInitializer\\\"]}},\\\"xavier_uniform\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"CGInitializer\\\"]}},\\\"relu\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"CGInitializer\\\"]}},\\\"relu_uniform\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"CGInitializer\\\"]}},\\\"identity\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"CGInitializer\\\"]}},\\\"normal_in\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"CGInitializer\\\"]}},\\\"normal_out\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"CGInitializer\\\"]}},\\\"normal_avg\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"CGInitializer\\\"]}},\\\"uniform_in\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"CGInitializer\\\"]}},\\\"uniform_out\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"CGInitializer\\\"]}},\\\"uniform_avg\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"CGInitializer\\\"]}}}},\\\"CalcGraph\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":false,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"newOp\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"code\\\",\\\"type\\\":[\\\"CGOperator\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"input2\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"output\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"newVar\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"name\\\",\\\"type\\\":[\\\"String\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Bool\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"newVaro\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"name\\\",\\\"type\\\":[\\\"String\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"l1\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"l2\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"init\\\",\\\"type\\\":[\\\"CGInitializer\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"configureVar\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"offset\\\",\\\"type\\\":[\\\"UInt\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"type\\\",\\\"type\\\":[\\\"Int\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"dim\\\",\\\"type\\\":[\\\"Array\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"newPath\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"name\\\",\\\"type\\\":[\\\"String\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"backward\\\",\\\"type\\\":[\\\"Bool\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"sin\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"output\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"cos\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"output\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"tan\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"output\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"sinh\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"output\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"cosh\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"output\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"tanh\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"output\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"sqrt\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"output\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"abs\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"output\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"lecun_tanh\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"output\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"exp\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"output\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"log\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"output\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"selu\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"output\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"sigmoid\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"output\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"hard_sigmoid\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"output\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"softplus\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"output\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"softsign\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"output\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"add\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"input2\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"output\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"addBias\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"input2\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"output\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"sub\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"input2\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"output\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"rmse\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"input2\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"output\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"cast\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"type\\\",\\\"type\\\":[\\\"Int\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"output\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"matmul\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"input2\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"output\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"transposeA\\\",\\\"type\\\":[\\\"Bool\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"transposeB\\\",\\\"type\\\":[\\\"Bool\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"relu\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"input\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"input2\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"output\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"alpha\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"threshold\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"max\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"setOptimizer\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"path\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"optimizer\\\",\\\"type\\\":[\\\"CGOptimizer\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"nbVars\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"UInt\\\"]}},\\\"prepare\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"size\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"forward\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"CGHeap\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"path\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"initialize\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"CGHeap\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"derive\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"CGHeap\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"path\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"backward\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"CGHeap\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"path\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"optimize\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"CGHeap\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"path\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"setSeed\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"endRound\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"path\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"resize\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"size\\\",\\\"type\\\":[\\\"Number\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}}}},\\\"CGTarget\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":false,\\\"is_open\\\":false,\\\"is_enum\\\":true,\\\"properties\\\":{\\\"fromValue\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"Any\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"CGTarget\\\",\\\"null\\\"]}},\\\"getValue\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"CGTarget\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"Any\\\",\\\"null\\\"]}},\\\"cpu\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Int\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":0},\\\"blas\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Int\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":1},\\\"cuda\\\":{\\\"nature\\\":\\\"attribute\\\",\\\"type\\\":\\\"Int\\\",\\\"is_static\\\":true,\\\"is_private\\\":false,\\\"value\\\":2}}},\\\"CGHeap\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":false,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"get\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"CalcGraph\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"offset\\\",\\\"type\\\":[\\\"UInt\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"allocate\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"CalcGraph\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"CGTarget\\\"],\\\"is_optional\\\":true},{\\\"name\\\":\\\"forwardOnly\\\",\\\"type\\\":[\\\"Bool\\\"],\\\"is_optional\\\":true}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"set\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"CalcGraph\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"offset\\\",\\\"type\\\":[\\\"UInt\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}},\\\"getGradient\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":false,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"CalcGraph\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"offset\\\",\\\"type\\\":[\\\"UInt\\\"],\\\"is_optional\\\":false},{\\\"name\\\":\\\"target\\\",\\\"type\\\":[\\\"Tensor\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"any\\\"]}}}},\\\"Process\\\":{\\\"is_primitive\\\":false,\\\"is_abstract\\\":true,\\\"is_open\\\":false,\\\"is_enum\\\":false,\\\"properties\\\":{\\\"cwd\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[],\\\"returnType\\\":[\\\"String\\\",\\\"null\\\"],\\\"doc\\\":\\\"get current working directory (no Windows support yet)\\\"}},\\\"getEnv\\\":{\\\"nature\\\":\\\"function\\\",\\\"is_static\\\":true,\\\"is_derived\\\":false,\\\"is_private\\\":false,\\\"value\\\":{\\\"params\\\":[{\\\"name\\\":\\\"key\\\",\\\"type\\\":[\\\"String\\\"],\\\"is_optional\\\":false}],\\\"returnType\\\":[\\\"String\\\",\\\"null\\\"],\\\"doc\\\":\\\"get an environment variable\\\"}}}}}\");\n\n//# sourceURL=webpack:///../types/std.types.json?");

/***/ }),

/***/ "../wasm/lib/Context.js":
/*!******************************!*\
  !*** ../wasm/lib/Context.js ***!
  \******************************/
/*! exports provided: Context */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Context\", function() { return Context; });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"../wasm/lib/common.js\");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! . */ \"../wasm/lib/index.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ \"../wasm/lib/types.js\");\n/* harmony import */ var _GString__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GString */ \"../wasm/lib/GString.js\");\n\n\n\n\nclass Context {\n    constructor(ptr) {\n        this.ptr = ptr;\n        this.errorHandler = (err) => {\n            console.error(`GreycatError\\n  reason: ${err.reason}\\n  stack:\\n    ${err.stack}`);\n        };\n        this._errorHandlerAdapter = (reason_ptr, gstack_ptr) => {\n            if (this.errorHandler) {\n                this.errorHandler(new _common__WEBPACK_IMPORTED_MODULE_0__[\"GreyCatError\"](___WEBPACK_IMPORTED_MODULE_1__[\"addon\"].UTF8ToString(___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gstring__get(reason_ptr), ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gstring__size(reason_ptr)), ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"].UTF8ToString(___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gstring__get(gstack_ptr), ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gstring__size(gstack_ptr))));\n            }\n        };\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._ctx__wrap(this.ptr);\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"].__pointers[this.ptr] = this;\n    }\n    onError(errorHandler) {\n        this.errorHandler = errorHandler;\n        return this;\n    }\n    get(key) {\n        return Object(_types__WEBPACK_IMPORTED_MODULE_2__[\"greycat_to_js\"])(ctx_get_handler(this.ptr, Object(_common__WEBPACK_IMPORTED_MODULE_0__[\"hash\"])(key)));\n    }\n    set(key, value) {\n        const g = this.graph();\n        if (!g.isMeta(key)) {\n            g.declareMeta(key);\n        }\n        Object(_types__WEBPACK_IMPORTED_MODULE_2__[\"js_to_greycat\"])(value, ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._object__graph(this.ptr), ctx_set_handler(this.ptr, Object(_common__WEBPACK_IMPORTED_MODULE_0__[\"hash\"])(key)));\n        return this;\n    }\n    setResult(value) {\n        Object(_types__WEBPACK_IMPORTED_MODULE_2__[\"js_to_greycat\"])(value, ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._object__graph(this.ptr), ctx_set_result_handler(this.ptr));\n        return this;\n    }\n    unmark() {\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gobject__un_mark(this.ptr);\n        delete ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"].__pointers[this.ptr];\n    }\n    graph() {\n        return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"].__pointers[___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._object__graph(this.ptr)];\n    }\n    toJSON() {\n        return JSON.parse(this.toString());\n    }\n    toString() {\n        const str = new _GString__WEBPACK_IMPORTED_MODULE_3__[\"GString\"](___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._object__to_json(this.ptr));\n        const json = str.value;\n        str.unmark();\n        return json;\n    }\n}\nfunction ctx_get_handler(ptr, key) {\n    return {\n        getValueType() {\n            return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._ctx__get_type(ptr, key);\n        },\n        getInt32() {\n            return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gctx__get_int(ptr, key);\n        },\n        getUint() {\n            return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gctx__get_uint(ptr, key);\n        },\n        getDouble() {\n            return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gctx__get_double(ptr, key);\n        },\n        getBool() {\n            return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gctx__get_bool(ptr, key);\n        },\n        getLong() {\n            return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gctx__get_long(ptr, key);\n        },\n        getULong() {\n            return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gctx__get_ulong(ptr, key);\n        },\n        getFloat() {\n            return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gctx__get_float(ptr, key);\n        },\n        getObject() {\n            return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gctx__get_object(ptr, key);\n        },\n    };\n}\nfunction ctx_set_handler(ptr, key) {\n    return {\n        isInt32: (value) => {\n            ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gctx__set_int(ptr, key, value);\n        },\n        isDouble: (value) => {\n            ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gctx__set_double(ptr, key, value);\n        },\n        isBoolean: (value) => {\n            ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gctx__set_bool(ptr, key, value);\n        },\n        isLong: (high, low) => {\n            ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._ctx__set_long(ptr, key, high, low);\n        },\n        isNull: () => {\n            ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gctx__set_null(ptr, key);\n        },\n        isObject: (obj_ptr) => {\n            ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gctx__set_object(ptr, key, obj_ptr);\n        },\n        isUndefined: () => {\n        },\n        isNotHandled: (value) => {\n            console.error(`Context can't set value '${value}' of type '${typeof value}'`);\n        },\n    };\n}\nfunction ctx_set_result_handler(_ptr) {\n    return {\n        isInt32: (_value) => {\n            console.warn(`ctx_set_result (isInt32): not implemented yet`);\n        },\n        isDouble: (_value) => {\n            console.warn(`ctx_set_result (isDouble): not implemented yet`);\n        },\n        isBoolean: (_value) => {\n            console.warn(`ctx_set_result (isBoolean): not implemented yet`);\n        },\n        isLong: (_high, _low) => {\n            console.warn(`ctx_set_result (isLong): not implemented yet`);\n        },\n        isNull: () => {\n            console.warn(`ctx_set_result (isNull): not implemented yet`);\n        },\n        isObject: (_obj_ptr) => {\n            console.warn(`ctx_set_result (isObject): not implemented yet`);\n        },\n        isUndefined: () => {\n        },\n        isNotHandled: (value) => {\n            console.error(`Context can't set result '${value}' of type '${typeof value}'`);\n        },\n    };\n}\n\n\n//# sourceURL=webpack:///../wasm/lib/Context.js?");

/***/ }),

/***/ "../wasm/lib/GArray.js":
/*!*****************************!*\
  !*** ../wasm/lib/GArray.js ***!
  \*****************************/
/*! exports provided: GArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GArray\", function() { return GArray; });\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! . */ \"../wasm/lib/index.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"../wasm/lib/types.js\");\n/* harmony import */ var _GString__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GString */ \"../wasm/lib/GString.js\");\n\n\n\nclass GArray {\n    constructor(ptr) {\n        Object.defineProperty(this, '$$_ptr', { enumerable: false, value: ptr });\n        return new Proxy(this, {\n            get(target, prop) {\n                const name = prop.toString();\n                const offset = parseInt(name, 10);\n                if (isNaN(offset)) {\n                    if (name === '$$_ptr') {\n                        return ptr;\n                    }\n                    if (typeof target[name] === 'function') {\n                        return target[name].bind(target);\n                    }\n                    else {\n                        return target[name];\n                    }\n                }\n                return Object(_types__WEBPACK_IMPORTED_MODULE_1__[\"greycat_to_js\"])(array_get_handler(ptr, offset));\n            },\n            set(target, prop, value) {\n                const name = prop.toString();\n                const offset = parseInt(name, 10);\n                if (isNaN(offset)) {\n                    target[name] = value;\n                }\n                else {\n                    Object(_types__WEBPACK_IMPORTED_MODULE_1__[\"js_to_greycat\"])(value, ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._array__graph(ptr), array_set_handler(ptr, offset));\n                }\n                return true;\n            },\n        });\n    }\n    resize(newSize) {\n        ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._garray__resize(this.$$_ptr, newSize);\n    }\n    add(elem) {\n        Object(_types__WEBPACK_IMPORTED_MODULE_1__[\"js_to_greycat\"])(elem, ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._array__graph(this.$$_ptr), array_add_handler(this.$$_ptr));\n    }\n    size() {\n        return ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._garray__size(this.$$_ptr);\n    }\n    toJSON() {\n        return JSON.parse(this.toString());\n    }\n    toString() {\n        const str = new _GString__WEBPACK_IMPORTED_MODULE_2__[\"GString\"](___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._object__to_json(this.$$_ptr));\n        const json = str.value;\n        str.unmark();\n        return json;\n    }\n    unmark() {\n        ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gobject__un_mark(this.$$_ptr);\n        delete ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"].__pointers[this.$$_ptr];\n    }\n}\nfunction array_set_handler(ptr, offset) {\n    return {\n        isInt32: (value) => {\n            ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._garray__set_int(ptr, offset, value);\n        },\n        isDouble: (value) => {\n            ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._garray__set_double(ptr, offset, value);\n        },\n        isBoolean: (value) => {\n            ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._garray__set_bool(ptr, offset, value);\n        },\n        isLong: (high, low) => {\n            ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._array__set_long(ptr, offset, high, low);\n        },\n        isNull: () => {\n            ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._garray__set_null(ptr, offset);\n        },\n        isObject: (obj_ptr) => {\n            ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._garray__set_object(ptr, offset, obj_ptr);\n        },\n        isUndefined: () => {\n        },\n        isNotHandled: (value) => {\n            console.error(`GArray can't set value '${value}' of type '${typeof value}'`);\n        },\n    };\n}\nfunction array_get_handler(ptr, offset) {\n    return {\n        getValueType() {\n            return ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._array__offset_type(ptr, offset);\n        },\n        getInt32() {\n            return ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._garray__get_int(ptr, offset);\n        },\n        getUint() {\n            return ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._garray__get_uint(ptr, offset);\n        },\n        getDouble() {\n            return ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._garray__get_double(ptr, offset);\n        },\n        getBool() {\n            return ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._garray__get_bool(ptr, offset);\n        },\n        getLong() {\n            return ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._garray__get_long(ptr, offset);\n        },\n        getULong() {\n            return ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._garray__get_ulong(ptr, offset);\n        },\n        getFloat() {\n            return ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._garray__get_float(ptr, offset);\n        },\n        getObject() {\n            return ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._garray__get_object(ptr, offset);\n        },\n    };\n}\nfunction array_add_handler(ptr) {\n    return {\n        isInt32: (value) => {\n            ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._garray__add_int(ptr, value);\n        },\n        isDouble: (value) => {\n            ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._garray__add_double(ptr, value);\n        },\n        isBoolean: (value) => {\n            ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._garray__add_bool(ptr, value);\n        },\n        isLong: (high, low) => {\n            ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._array__add_long(ptr, high, low);\n        },\n        isNull: () => {\n            ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._garray__add_null(ptr);\n        },\n        isObject: (obj_ptr) => {\n            ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._garray__add_object(ptr, obj_ptr);\n        },\n        isUndefined: () => {\n        },\n        isNotHandled: (value) => {\n            console.error(`GArray can't add value '${value}' of type '${typeof value}'`);\n        },\n    };\n}\n\n\n//# sourceURL=webpack:///../wasm/lib/GArray.js?");

/***/ }),

/***/ "../wasm/lib/GFunction.js":
/*!********************************!*\
  !*** ../wasm/lib/GFunction.js ***!
  \********************************/
/*! exports provided: GFunction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GFunction\", function() { return GFunction; });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"../wasm/lib/common.js\");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! . */ \"../wasm/lib/index.js\");\n/* harmony import */ var _Context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Context */ \"../wasm/lib/Context.js\");\n/* harmony import */ var _GString__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GString */ \"../wasm/lib/GString.js\");\n/* harmony import */ var _GArray__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GArray */ \"../wasm/lib/GArray.js\");\n\n\n\n\n\nlet function_count = 0;\nfunction isFunctionAndParams(value) {\n    return typeof value.params === 'object' && typeof value.body === 'function';\n}\nclass GFunction {\n    constructor(ptr) {\n        this.ptr = ptr;\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"].__pointers[this.ptr] = this;\n    }\n    then(arg, uri) {\n        switch (typeof arg) {\n            case 'string':\n                return this._thenParse(arg, uri);\n            case 'function':\n                return this._thenBody(arg);\n            case 'object':\n                if (isFunctionAndParams(arg)) {\n                    arg.params.forEach((p) => this.defineParam(p));\n                    return this._thenBody(arg.body);\n                }\n                if (arg instanceof GFunction) {\n                    return this._then(arg);\n                }\n                if (arg instanceof String) {\n                    return this._thenParse(arg.toString(), uri);\n                }\n                break;\n            default:\n                break;\n        }\n        throw new Error(`GFunction.then() expects a 'string', a 'function' or a '{ params: {}, body: function }' or a 'GFunction' (given: ${typeof arg})`);\n    }\n    execute(first, second) {\n        if (first instanceof _Context__WEBPACK_IMPORTED_MODULE_2__[\"Context\"] && !second) {\n            throw new Error('Function.execute() must be called with a Context and an ExecutionCallback, not just a Context');\n        }\n        if (first instanceof Function && !second) {\n            return this._executeWithCallback(first);\n        }\n        if (first instanceof _Context__WEBPACK_IMPORTED_MODULE_2__[\"Context\"] && second instanceof Function) {\n            return this._executeWithContextAndCallback(first, second);\n        }\n        return this._execute();\n    }\n    defineParam(param) {\n        const g = this.graph();\n        if (!g.isMeta(param.name)) {\n            g.declareMeta(param.name);\n        }\n        let types = [_common__WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_Any];\n        if (param.type) {\n            if (typeof param.type === 'number') {\n                types[0] = param.type;\n            }\n            else {\n                types = param.type;\n            }\n        }\n        if (types.length === 1) {\n            ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._function__add_param(this.ptr, Object(_common__WEBPACK_IMPORTED_MODULE_0__[\"hash\"])(param.name), types[0], !!param.optional);\n        }\n        else {\n            const garr = new _GArray__WEBPACK_IMPORTED_MODULE_4__[\"GArray\"](___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._ggraph__create_array(this.graph().ptr));\n            types.forEach((t) => garr.add(t));\n            ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._function__add_mparam(this.ptr, Object(_common__WEBPACK_IMPORTED_MODULE_0__[\"hash\"])(param.name), garr.ptr, !!param.optional);\n            garr.unmark();\n        }\n        return this;\n    }\n    unmark() {\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gobject__un_mark(this.ptr);\n        delete ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"].__pointers[this.ptr];\n    }\n    graph() {\n        return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"].__pointers[___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._object__graph(this.ptr)];\n    }\n    toJSON() {\n        return JSON.parse(this.toString());\n    }\n    toString() {\n        const str = new _GString__WEBPACK_IMPORTED_MODULE_3__[\"GString\"](___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._object__to_json(this.ptr));\n        const json = str.value;\n        str.unmark();\n        return json;\n    }\n    _execute() {\n        const ctx = new _Context__WEBPACK_IMPORTED_MODULE_2__[\"Context\"](___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._function__create_context(this.ptr));\n        const callback_ptr = Object(_common__WEBPACK_IMPORTED_MODULE_0__[\"hash\"])(`callback_${function_count++}`);\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"].__pointers[callback_ptr] = () => ctx.unmark();\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._function__execute(ctx.ptr, this.ptr, callback_ptr);\n        return this;\n    }\n    _executeWithCallback(cb) {\n        return this._executeWithContextAndCallback(new _Context__WEBPACK_IMPORTED_MODULE_2__[\"Context\"](___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._function__create_context(this.ptr)), cb);\n    }\n    _executeWithContextAndCallback(ctx, cb) {\n        const prevErrorHandler = ctx.errorHandler;\n        ctx.onError((err) => {\n            if (prevErrorHandler) {\n                prevErrorHandler(err);\n            }\n            cb(err, ctx);\n        });\n        const callback_ptr = Object(_common__WEBPACK_IMPORTED_MODULE_0__[\"hash\"])(`callback_${function_count++}`);\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"].__pointers[callback_ptr] = () => cb(undefined, ctx);\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._function__execute(ctx.ptr, this.ptr, callback_ptr);\n        return this;\n    }\n    _thenParse(script, uri) {\n        const str_ptr = ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"].allocateUTF8(script);\n        let uri_ptr = 0;\n        if (uri) {\n            uri_ptr = ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"].allocateUTF8(uri);\n        }\n        const success = ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._function__parse(this.ptr, str_ptr, uri_ptr);\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._free(str_ptr);\n        if (uri_ptr !== 0) {\n            ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._free(uri_ptr);\n        }\n        if (!success) {\n            throw new Error(`Unable to parse script${uri ? ` '${uri}'` : ''}`);\n        }\n        return this;\n    }\n    _thenBody(func) {\n        const fn_ptr = Object(_common__WEBPACK_IMPORTED_MODULE_0__[\"hash\"])(`func_${function_count++}`);\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"].__pointers[fn_ptr] = func;\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._function__pipe_external(this.ptr, fn_ptr);\n        return this;\n    }\n    _then(func) {\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._function__pipe(this.ptr, func.ptr);\n        return this;\n    }\n}\n\n\n//# sourceURL=webpack:///../wasm/lib/GFunction.js?");

/***/ }),

/***/ "../wasm/lib/GMap.js":
/*!***************************!*\
  !*** ../wasm/lib/GMap.js ***!
  \***************************/
/*! exports provided: GMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GMap\", function() { return GMap; });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"../wasm/lib/common.js\");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! . */ \"../wasm/lib/index.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ \"../wasm/lib/types.js\");\n/* harmony import */ var _GString__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GString */ \"../wasm/lib/GString.js\");\n\n\n\n\nlet iterators = 0;\nclass GMap {\n    constructor(ptr) {\n        this.ptr = ptr;\n    }\n    get(key) {\n        const graph_ptr = ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._map__graph(this.ptr);\n        const key_slot = Object(_types__WEBPACK_IMPORTED_MODULE_2__[\"js_to_slot\"])(key, graph_ptr);\n        if (!key_slot) {\n            throw new Error(`Unhandled key type '${typeof key}'`);\n        }\n    }\n    set(key, value) {\n        const graph_ptr = ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._map__graph(this.ptr);\n        const key_slot = Object(_types__WEBPACK_IMPORTED_MODULE_2__[\"js_to_slot\"])(key, graph_ptr);\n        if (!key_slot) {\n            throw new Error(`Unhandled key type '${typeof key}'`);\n        }\n        const value_slot = Object(_types__WEBPACK_IMPORTED_MODULE_2__[\"js_to_slot\"])(value, graph_ptr);\n        if (!value_slot) {\n            throw new Error(`Unhandled value type '${typeof key}'`);\n        }\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._map__set(this.ptr, key_slot.ptr, key_slot.type, value_slot.ptr, value_slot.type);\n    }\n    put(key, value) {\n        const graph_ptr = ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._map__graph(this.ptr);\n        const key_slot = Object(_types__WEBPACK_IMPORTED_MODULE_2__[\"js_to_slot\"])(key, graph_ptr);\n        if (!key_slot) {\n            throw new Error(`Unhandled key type '${typeof key}'`);\n        }\n        const value_slot = Object(_types__WEBPACK_IMPORTED_MODULE_2__[\"js_to_slot\"])(value, graph_ptr);\n        if (!value_slot) {\n            throw new Error(`Unhandled value type '${typeof key}'`);\n        }\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._map__put(this.ptr, key_slot.ptr, key_slot.type, value_slot.ptr, value_slot.type);\n    }\n    remove(key) {\n        const graph_ptr = ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._map__graph(this.ptr);\n        const key_slot = Object(_types__WEBPACK_IMPORTED_MODULE_2__[\"js_to_slot\"])(key, graph_ptr);\n        if (!key_slot) {\n            throw new Error(`Unhandled key type '${typeof key}'`);\n        }\n        return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._map__remove(this.ptr, key_slot.ptr, key_slot.type);\n    }\n    size() {\n        return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._map__size(this.ptr);\n    }\n    foreach(_it) {\n        const iterator_ptr = Object(_common__WEBPACK_IMPORTED_MODULE_0__[\"hash\"])(`iterator_${iterators++}`);\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"].__pointers[iterator_ptr] = it;\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._map__foreach(this.ptr, iterator_ptr);\n    }\n    unmark() {\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gobject__un_mark(this.ptr);\n    }\n    toJSON() {\n        return JSON.parse(this.toString());\n    }\n    toString() {\n        const str = new _GString__WEBPACK_IMPORTED_MODULE_3__[\"GString\"](___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._object__to_json(this.ptr));\n        const json = str.value;\n        str.unmark();\n        return json;\n    }\n}\n\n\n//# sourceURL=webpack:///../wasm/lib/GMap.js?");

/***/ }),

/***/ "../wasm/lib/GObject.js":
/*!******************************!*\
  !*** ../wasm/lib/GObject.js ***!
  \******************************/
/*! exports provided: GObject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GObject\", function() { return GObject; });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"../wasm/lib/common.js\");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! . */ \"../wasm/lib/index.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ \"../wasm/lib/types.js\");\n/* harmony import */ var _GString__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GString */ \"../wasm/lib/GString.js\");\n\n\n\n\nclass GObject {\n    constructor(ptr) {\n        Object.defineProperty(this, '$$_ptr', { enumerable: false, writable: false, configurable: false, value: ptr });\n        return new Proxy(this, {\n            get(target, prop) {\n                const name = prop.toString();\n                if (name === '$$_ptr') {\n                    return ptr;\n                }\n                if (name === 'toJSON' || name === 'toString') {\n                    if (typeof target[name] === 'function') {\n                        return target[name].bind(target);\n                    }\n                    else {\n                        return target[name];\n                    }\n                }\n                return Object(_types__WEBPACK_IMPORTED_MODULE_2__[\"greycat_to_js\"])(object_get_handler(ptr, Object(_common__WEBPACK_IMPORTED_MODULE_0__[\"hash\"])(name)));\n            },\n            set(_, prop, value) {\n                const name = prop.toString();\n                const offset = parseInt(name, 10);\n                if (isNaN(offset)) {\n                    const graph_ptr = ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._object__graph(ptr);\n                    Object(_types__WEBPACK_IMPORTED_MODULE_2__[\"js_to_greycat\"])(value, graph_ptr, object_set_handler(ptr, graph_ptr, name));\n                    return true;\n                }\n                throw new Error('GObject cannot set value using number offset');\n            },\n        });\n    }\n    toJSON() {\n        return JSON.parse(this.toString());\n    }\n    toString() {\n        const str = new _GString__WEBPACK_IMPORTED_MODULE_3__[\"GString\"](___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._object__to_json(this.$$_ptr));\n        const json = str.value;\n        str.unmark();\n        return json;\n    }\n}\nfunction object_get_handler(ptr, key) {\n    return {\n        getValueType() {\n            return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._object__key_type(ptr, key);\n        },\n        getInt32() {\n            return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gobject__get_int(ptr, key);\n        },\n        getUint() {\n            return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gobject__get_uint(ptr, key);\n        },\n        getDouble() {\n            return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gobject__get_double(ptr, key);\n        },\n        getBool() {\n            return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gobject__get_bool(ptr, key);\n        },\n        getLong() {\n            return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gobject__get_long(ptr, key);\n        },\n        getULong() {\n            return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gobject__get_ulong(ptr, key);\n        },\n        getFloat() {\n            return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gobject__get_float(ptr, key);\n        },\n        getObject() {\n            return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gobject__get_object(ptr, key);\n        },\n    };\n}\nfunction object_set_handler(ptr, graph_ptr, name) {\n    const key = Object(_common__WEBPACK_IMPORTED_MODULE_0__[\"hash\"])(name);\n    if (___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._ggraph__is_meta(graph_ptr, key) === 0) {\n        const name_ptr = ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"].allocateUTF8(name);\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._ggraph__declare_meta(graph_ptr, key, name_ptr);\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._free(name_ptr);\n    }\n    return {\n        isInt32: (value) => {\n            ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gobject__set_int(ptr, key, value);\n        },\n        isDouble: (value) => {\n            ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gobject__set_double(ptr, key, value);\n        },\n        isBoolean: (value) => {\n            ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gobject__set_bool(ptr, key, value);\n        },\n        isLong: (high, low) => {\n            ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._object__set_long(ptr, key, high, low);\n        },\n        isNull: () => {\n            ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gobject__set_null(ptr, key);\n        },\n        isObject: (obj_ptr) => {\n            ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gobject__set_object(ptr, key, obj_ptr);\n        },\n        isUndefined: () => {\n        },\n        isNotHandled: (value) => {\n            console.error(`GObject can't set value '${value}' of type '${typeof value}'`);\n        },\n    };\n}\n\n\n//# sourceURL=webpack:///../wasm/lib/GObject.js?");

/***/ }),

/***/ "../wasm/lib/GRef.js":
/*!***************************!*\
  !*** ../wasm/lib/GRef.js ***!
  \***************************/
/*! exports provided: GRef */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GRef\", function() { return GRef; });\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! . */ \"../wasm/lib/index.js\");\n/* harmony import */ var _GString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GString */ \"../wasm/lib/GString.js\");\n\n\nclass GRef {\n    constructor(ptr) {\n        this.ptr = ptr;\n    }\n    toJSON() {\n        return JSON.parse(this.toString());\n    }\n    toString() {\n        const str = new _GString__WEBPACK_IMPORTED_MODULE_1__[\"GString\"](___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._object__to_json(this.ptr));\n        const json = str.value;\n        str.unmark();\n        return json;\n    }\n}\n\n\n//# sourceURL=webpack:///../wasm/lib/GRef.js?");

/***/ }),

/***/ "../wasm/lib/GString.js":
/*!******************************!*\
  !*** ../wasm/lib/GString.js ***!
  \******************************/
/*! exports provided: GString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GString\", function() { return GString; });\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! . */ \"../wasm/lib/index.js\");\n\nclass GString {\n    constructor(ptr) {\n        this.ptr = ptr;\n    }\n    get value() {\n        return ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"].UTF8ToString(___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gstring__get(this.ptr), ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gstring__size(this.ptr));\n    }\n    set value(value) {\n        this.reset();\n        const str_ptr = ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"].allocateUTF8(value);\n        ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gstring__add_raw_string(this.ptr, str_ptr);\n        this.close();\n        ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._free(str_ptr);\n    }\n    prepare(needed) {\n        ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gstring__prepare(this.ptr, needed);\n    }\n    reset() {\n        ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gstring__reset(this.ptr);\n    }\n    close() {\n        ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gstring__close(this.ptr);\n    }\n    size() {\n        return ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gstring__size(this.ptr);\n    }\n    unmark() {\n        ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gobject__un_mark(this.ptr);\n    }\n    toJSON() {\n        return this.toString();\n    }\n    toString() {\n        return this.value;\n    }\n}\n\n\n//# sourceURL=webpack:///../wasm/lib/GString.js?");

/***/ }),

/***/ "../wasm/lib/GType.js":
/*!****************************!*\
  !*** ../wasm/lib/GType.js ***!
  \****************************/
/*! exports provided: GType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GType\", function() { return GType; });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"../wasm/lib/common.js\");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! . */ \"../wasm/lib/index.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ \"../wasm/lib/types.js\");\n/* harmony import */ var _GString__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GString */ \"../wasm/lib/GString.js\");\n\n\n\n\nclass GType {\n    constructor(graph, name, isOpen = false) {\n        if (!graph.isMeta(name)) {\n            graph.declareMeta(name);\n        }\n        this.ptr = ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._type__create(graph.ptr, Object(_common__WEBPACK_IMPORTED_MODULE_0__[\"hash\"])(name), isOpen);\n    }\n    declareAttribute(name, type) {\n        const hashed_type = typeof type === 'number' ? type : Object(_common__WEBPACK_IMPORTED_MODULE_0__[\"hash\"])(type);\n        const name_ptr = ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"].allocateUTF8(name);\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._type__declare_attribute(this.ptr, name_ptr, hashed_type);\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._free(name_ptr);\n        return this;\n    }\n    declareStaticAttribute(name, value) {\n        const name_ptr = ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"].allocateUTF8(name);\n        Object(_types__WEBPACK_IMPORTED_MODULE_2__[\"js_to_greycat\"])(value, ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._type__graph(this.ptr), type_static_set_handler(this.ptr, name_ptr));\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._free(name_ptr);\n        return this;\n    }\n    declareFunction(name, func) {\n        const name_ptr = ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"].allocateUTF8(name);\n        const fn = this.graph().newFunction().then(func);\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._type__declare_function(this.ptr, name_ptr, fn.ptr, false);\n        fn.unmark();\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._free(name_ptr);\n        return this;\n    }\n    declareStaticFunction(name, func) {\n        const name_ptr = ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"].allocateUTF8(name);\n        const fn = this.graph().newFunction().then(func);\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._type__declare_function(this.ptr, name_ptr, fn.ptr, true);\n        fn.unmark();\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._free(name_ptr);\n        return this;\n    }\n    setClass(_clazz) {\n        throw new Error('Method not implemented.');\n    }\n    seal() {\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._type__seal(this.ptr);\n        return this;\n    }\n    unmark() {\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._gobject__un_mark(this.ptr);\n    }\n    graph() {\n        return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"].__pointers[___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._type__graph(this.ptr)];\n    }\n    toJSON() {\n        return JSON.parse(this.toString());\n    }\n    toString() {\n        const str = new _GString__WEBPACK_IMPORTED_MODULE_3__[\"GString\"](___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._object__to_json(this.ptr));\n        const json = str.value;\n        str.unmark();\n        return json;\n    }\n    get name() {\n        const str = new _GString__WEBPACK_IMPORTED_MODULE_3__[\"GString\"](___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._type__name(this.ptr));\n        const typeName = str.value;\n        str.unmark();\n        return typeName;\n    }\n    get key() {\n        return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._type__key(this.ptr);\n    }\n    get open() {\n        return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._type__is_open(this.ptr) === 1;\n    }\n}\nfunction type_static_set_handler(ptr, name_ptr) {\n    return {\n        isInt32: (value) => {\n            ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._type__declare_static_int(ptr, name_ptr, value);\n        },\n        isDouble: (value) => {\n            ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._type__declare_static_double(ptr, name_ptr, value);\n        },\n        isBoolean: (value) => {\n            ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._type__declare_static_bool(ptr, name_ptr, value);\n        },\n        isLong: (high, low) => {\n            ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._type__declare_static_long(ptr, name_ptr, high, low);\n        },\n        isNull: () => {\n            ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._type__declare_static_null(ptr, name_ptr);\n        },\n        isObject: (obj_ptr) => {\n            ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._type__declare_static_object(ptr, name_ptr, obj_ptr);\n        },\n        isUndefined: () => {\n        },\n        isNotHandled: (value) => {\n            console.error(`GObject can't set value '${value}' of type '${typeof value}'`);\n        },\n    };\n}\n\n\n//# sourceURL=webpack:///../wasm/lib/GType.js?");

/***/ }),

/***/ "../wasm/lib/Graph.js":
/*!****************************!*\
  !*** ../wasm/lib/Graph.js ***!
  \****************************/
/*! exports provided: Graph */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Graph\", function() { return Graph; });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"../wasm/lib/common.js\");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! . */ \"../wasm/lib/index.js\");\n/* harmony import */ var _GFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GFunction */ \"../wasm/lib/GFunction.js\");\n/* harmony import */ var _Context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Context */ \"../wasm/lib/Context.js\");\n/* harmony import */ var _GType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GType */ \"../wasm/lib/GType.js\");\n\n\n\n\n\nclass Graph {\n    constructor(cacheSize = 10, bufferSize = 10) {\n        this.ptr = ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._graph__create(cacheSize, bufferSize);\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"].__pointers[this.ptr] = this;\n    }\n    declareType(name, isOpen = false) {\n        return new _GType__WEBPACK_IMPORTED_MODULE_4__[\"GType\"](this, name, isOpen);\n    }\n    declareMeta(name) {\n        const key = Object(_common__WEBPACK_IMPORTED_MODULE_0__[\"hash\"])(name);\n        const name_ptr = ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"].allocateUTF8(name);\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._ggraph__declare_meta(this.ptr, key, name_ptr);\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._free(name_ptr);\n        return key;\n    }\n    getType(_name) {\n        throw new Error('Method not implemented.');\n    }\n    newContext() {\n        return new _Context__WEBPACK_IMPORTED_MODULE_3__[\"Context\"](___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._ggraph__create_context(this.ptr));\n    }\n    newFunction() {\n        return new _GFunction__WEBPACK_IMPORTED_MODULE_2__[\"GFunction\"](___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._ggraph__create_function(this.ptr));\n    }\n    exportTypes() {\n        return _common__WEBPACK_IMPORTED_MODULE_0__[\"stdLib\"];\n    }\n    isMeta(name) {\n        return ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._ggraph__is_meta(this.ptr, Object(_common__WEBPACK_IMPORTED_MODULE_0__[\"hash\"])(name)) === 1;\n    }\n    destroy() {\n        ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"]._ggraph__destroy(this.ptr);\n        delete ___WEBPACK_IMPORTED_MODULE_1__[\"addon\"].__pointers[this.ptr];\n    }\n}\n\n\n//# sourceURL=webpack:///../wasm/lib/Graph.js?");

/***/ }),

/***/ "../wasm/lib/common.js":
/*!*****************************!*\
  !*** ../wasm/lib/common.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _greycat_core_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @greycat/core-common */ \"../common/lib/index.js\");\n/* harmony import */ var _greycat_core_common__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_greycat_core_common__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _greycat_core_common__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _greycat_core_common__WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n\n\n\n//# sourceURL=webpack:///../wasm/lib/common.js?");

/***/ }),

/***/ "../wasm/lib/greycat.js":
/*!******************************!*\
  !*** ../wasm/lib/greycat.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(setImmediate) {\n      function getAbsoluteUrl(relativeUrl) {\n        const publicPath = __webpack_require__.p;\n\n        let url = '';\n\n        if (!publicPath || publicPath.indexOf('://') < 0) {\n          url += window.location.protocol + '//' + window.location.host;\n        }\n\n        if (publicPath) {\n          url += publicPath;\n        } else {\n          url += '//';\n        }\n\n        return url + relativeUrl;\n      }\n\nvar Module = (function() {\n  var _scriptDir = ({ url: getAbsoluteUrl('lib/greycat.js') }).url;\n  \n  return (\nfunction(Module) {\n  Module = Module || {};\n\n// Copyright 2010 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n\n// The Module object: Our interface to the outside world. We import\n// and export values on it. There are various ways Module can be used:\n// 1. Not defined. We create it here\n// 2. A function parameter, function(Module) { ..generated code.. }\n// 3. pre-run appended it, var Module = {}; ..generated code..\n// 4. External script tag defines var Module.\n// We need to check if Module already exists (e.g. case 3 above).\n// Substitution will be replaced with actual code on later stage of the build,\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\n// Note that if you want to run closure, and also to use Module\n// after the generated code, you will need to define   var Module = {};\n// before the code. Then that object will be used in the code, and you\n// can continue to use Module afterwards as well.\nvar Module = typeof Module !== 'undefined' ? Module : {};\n\n// --pre-jses are emitted after the Module integration code, so that they can\n// refer to Module (if they choose; they can also define Module)\n// {{PRE_JSES}}\n\n// Sometimes an existing Module object exists with properties\n// meant to overwrite the default module functionality. Here\n// we collect those properties and reapply _after_ we configure\n// the current environment's defaults to avoid having to be so\n// defensive during initialization.\nvar moduleOverrides = {};\nvar key;\nfor (key in Module) {\n  if (Module.hasOwnProperty(key)) {\n    moduleOverrides[key] = Module[key];\n  }\n}\n\nvar arguments_ = [];\nvar thisProgram = './this.program';\nvar quit_ = function(status, toThrow) {\n  throw toThrow;\n};\n\n// Determine the runtime environment we are in. You can customize this by\n// setting the ENVIRONMENT setting at compile time (see settings.js).\n\nvar ENVIRONMENT_IS_WEB = true;\nvar ENVIRONMENT_IS_WORKER = false;\nvar ENVIRONMENT_IS_NODE = false;\nvar ENVIRONMENT_HAS_NODE = ENVIRONMENT_IS_NODE;\nvar ENVIRONMENT_IS_SHELL = false;\n\nif (Module['ENVIRONMENT']) {\n  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)');\n}\n\n\n\n// `/` should be present at the end if `scriptDirectory` is not empty\nvar scriptDirectory = '';\nfunction locateFile(path) {\n  if (Module['locateFile']) {\n    return Module['locateFile'](path, scriptDirectory);\n  }\n  return scriptDirectory + path;\n}\n\n// Hooks that are implemented differently in different runtime environments.\nvar read_,\n    readAsync,\n    readBinary,\n    setWindowTitle;\n\n\n// Note that this includes Node.js workers when relevant (pthreads is enabled).\n// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\n// ENVIRONMENT_HAS_NODE.\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled\n    scriptDirectory = self.location.href;\n  } else if (document.currentScript) { // web\n    scriptDirectory = document.currentScript.src;\n  }\n  // When MODULARIZE (and not _INSTANCE), this JS may be executed later, after document.currentScript\n  // is gone, so we saved it, and we use it here instead of any other info.\n  if (_scriptDir) {\n    scriptDirectory = _scriptDir;\n  }\n  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n  // otherwise, slice off the final part of the url to find the script directory.\n  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\n  // and scriptDirectory will correctly be replaced with an empty string.\n  if (scriptDirectory.indexOf('blob:') !== 0) {\n    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/')+1);\n  } else {\n    scriptDirectory = '';\n  }\n\n  if (!(typeof window === 'object' || typeof importScripts === 'function')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\n\n  // Differentiate the Web Worker from the Node Worker case, as reading must\n  // be done differently.\n  {\n\n\n  read_ = function shell_read(url) {\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, false);\n      xhr.send(null);\n      return xhr.responseText;\n  };\n\n  if (ENVIRONMENT_IS_WORKER) {\n    readBinary = function readBinary(url) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, false);\n        xhr.responseType = 'arraybuffer';\n        xhr.send(null);\n        return new Uint8Array(xhr.response);\n    };\n  }\n\n  readAsync = function readAsync(url, onload, onerror) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'arraybuffer';\n    xhr.onload = function xhr_onload() {\n      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\n        onload(xhr.response);\n        return;\n      }\n      onerror();\n    };\n    xhr.onerror = onerror;\n    xhr.send(null);\n  };\n\n\n\n\n  }\n\n  setWindowTitle = function(title) { document.title = title };\n} else\n{\n  throw new Error('environment detection error');\n}\n\n\n// Set up the out() and err() hooks, which are how we can print to stdout or\n// stderr, respectively.\nvar out = Module['print'] || console.log.bind(console);\nvar err = Module['printErr'] || console.warn.bind(console);\n\n// Merge back in the overrides\nfor (key in moduleOverrides) {\n  if (moduleOverrides.hasOwnProperty(key)) {\n    Module[key] = moduleOverrides[key];\n  }\n}\n// Free the object hierarchy contained in the overrides, this lets the GC\n// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\nmoduleOverrides = null;\n\n// Emit code to handle expected values on the Module object. This applies Module.x\n// to the proper local x. This has two benefits: first, we only emit it if it is\n// expected to arrive, and second, by using a local everywhere else that can be\n// minified.\nif (Module['arguments']) arguments_ = Module['arguments'];if (!Object.getOwnPropertyDescriptor(Module, 'arguments')) Object.defineProperty(Module, 'arguments', { configurable: true, get: function() { abort('Module.arguments has been replaced with plain arguments_') } });\nif (Module['thisProgram']) thisProgram = Module['thisProgram'];if (!Object.getOwnPropertyDescriptor(Module, 'thisProgram')) Object.defineProperty(Module, 'thisProgram', { configurable: true, get: function() { abort('Module.thisProgram has been replaced with plain thisProgram') } });\nif (Module['quit']) quit_ = Module['quit'];if (!Object.getOwnPropertyDescriptor(Module, 'quit')) Object.defineProperty(Module, 'quit', { configurable: true, get: function() { abort('Module.quit has been replaced with plain quit_') } });\n\n// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\n// Assertions on removed incoming Module JS APIs.\nassert(typeof Module['memoryInitializerPrefixURL'] === 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['pthreadMainPrefixURL'] === 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['cdInitializerPrefixURL'] === 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['filePackagePrefixURL'] === 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['read'] === 'undefined', 'Module.read option was removed (modify read_ in JS)');\nassert(typeof Module['readAsync'] === 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');\nassert(typeof Module['readBinary'] === 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');\nassert(typeof Module['setWindowTitle'] === 'undefined', 'Module.setWindowTitle option was removed (modify setWindowTitle in JS)');\nif (!Object.getOwnPropertyDescriptor(Module, 'read')) Object.defineProperty(Module, 'read', { configurable: true, get: function() { abort('Module.read has been replaced with plain read_') } });\nif (!Object.getOwnPropertyDescriptor(Module, 'readAsync')) Object.defineProperty(Module, 'readAsync', { configurable: true, get: function() { abort('Module.readAsync has been replaced with plain readAsync') } });\nif (!Object.getOwnPropertyDescriptor(Module, 'readBinary')) Object.defineProperty(Module, 'readBinary', { configurable: true, get: function() { abort('Module.readBinary has been replaced with plain readBinary') } });\n// TODO: add when SDL2 is fixed if (!Object.getOwnPropertyDescriptor(Module, 'setWindowTitle')) Object.defineProperty(Module, 'setWindowTitle', { configurable: true, get: function() { abort('Module.setWindowTitle has been replaced with plain setWindowTitle') } });\nvar IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';\nvar PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';\nvar WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';\nvar NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';\n\n\n// TODO remove when SDL2 is fixed (also see above)\n\n\n\n// Copyright 2017 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n\n// {{PREAMBLE_ADDITIONS}}\n\nvar STACK_ALIGN = 16;\n\n// stack management, and other functionality that is provided by the compiled code,\n// should not be used before it is ready\nstackSave = stackRestore = stackAlloc = function() {\n  abort('cannot use the stack before compiled code is ready to run, and has provided stack access');\n};\n\nfunction staticAlloc(size) {\n  abort('staticAlloc is no longer available at runtime; instead, perform static allocations at compile time (using makeStaticAlloc)');\n}\n\nfunction dynamicAlloc(size) {\n  assert(DYNAMICTOP_PTR);\n  var ret = HEAP32[DYNAMICTOP_PTR>>2];\n  var end = (ret + size + 15) & -16;\n  if (end > _emscripten_get_heap_size()) {\n    abort('failure to dynamicAlloc - memory growth etc. is not supported there, call malloc/sbrk directly');\n  }\n  HEAP32[DYNAMICTOP_PTR>>2] = end;\n  return ret;\n}\n\nfunction alignMemory(size, factor) {\n  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default\n  return Math.ceil(size / factor) * factor;\n}\n\nfunction getNativeTypeSize(type) {\n  switch (type) {\n    case 'i1': case 'i8': return 1;\n    case 'i16': return 2;\n    case 'i32': return 4;\n    case 'i64': return 8;\n    case 'float': return 4;\n    case 'double': return 8;\n    default: {\n      if (type[type.length-1] === '*') {\n        return 4; // A pointer\n      } else if (type[0] === 'i') {\n        var bits = parseInt(type.substr(1));\n        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);\n        return bits / 8;\n      } else {\n        return 0;\n      }\n    }\n  }\n}\n\nfunction warnOnce(text) {\n  if (!warnOnce.shown) warnOnce.shown = {};\n  if (!warnOnce.shown[text]) {\n    warnOnce.shown[text] = 1;\n    err(text);\n  }\n}\n\n\n\n\n\n// Wraps a JS function as a wasm function with a given signature.\nfunction convertJsFunctionToWasm(func, sig) {\n\n  // If the type reflection proposal is available, use the new\n  // \"WebAssembly.Function\" constructor.\n  // Otherwise, construct a minimal wasm module importing the JS function and\n  // re-exporting it.\n  if (typeof WebAssembly.Function === \"function\") {\n    var typeNames = {\n      'i': 'i32',\n      'j': 'i64',\n      'f': 'f32',\n      'd': 'f64'\n    };\n    var type = {\n      parameters: [],\n      results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]\n    };\n    for (var i = 1; i < sig.length; ++i) {\n      type.parameters.push(typeNames[sig[i]]);\n    }\n    return new WebAssembly.Function(type, func);\n  }\n\n  // The module is static, with the exception of the type section, which is\n  // generated based on the signature passed in.\n  var typeSection = [\n    0x01, // id: section,\n    0x00, // length: 0 (placeholder)\n    0x01, // count: 1\n    0x60, // form: func\n  ];\n  var sigRet = sig.slice(0, 1);\n  var sigParam = sig.slice(1);\n  var typeCodes = {\n    'i': 0x7f, // i32\n    'j': 0x7e, // i64\n    'f': 0x7d, // f32\n    'd': 0x7c, // f64\n  };\n\n  // Parameters, length + signatures\n  typeSection.push(sigParam.length);\n  for (var i = 0; i < sigParam.length; ++i) {\n    typeSection.push(typeCodes[sigParam[i]]);\n  }\n\n  // Return values, length + signatures\n  // With no multi-return in MVP, either 0 (void) or 1 (anything else)\n  if (sigRet == 'v') {\n    typeSection.push(0x00);\n  } else {\n    typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);\n  }\n\n  // Write the overall length of the type section back into the section header\n  // (excepting the 2 bytes for the section id and length)\n  typeSection[1] = typeSection.length - 2;\n\n  // Rest of the module is static\n  var bytes = new Uint8Array([\n    0x00, 0x61, 0x73, 0x6d, // magic (\"\\0asm\")\n    0x01, 0x00, 0x00, 0x00, // version: 1\n  ].concat(typeSection, [\n    0x02, 0x07, // import section\n      // (import \"e\" \"f\" (func 0 (type 0)))\n      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,\n    0x07, 0x05, // export section\n      // (export \"f\" (func 0 (type 0)))\n      0x01, 0x01, 0x66, 0x00, 0x00,\n  ]));\n\n   // We can compile this wasm module synchronously because it is very small.\n  // This accepts an import (at \"e.f\"), that it reroutes to an export (at \"f\")\n  var module = new WebAssembly.Module(bytes);\n  var instance = new WebAssembly.Instance(module, {\n    'e': {\n      'f': func\n    }\n  });\n  var wrappedFunc = instance.exports['f'];\n  return wrappedFunc;\n}\n\n// Add a wasm function to the table.\nfunction addFunctionWasm(func, sig) {\n  var table = wasmTable;\n  var ret = table.length;\n\n  // Grow the table\n  try {\n    table.grow(1);\n  } catch (err) {\n    if (!(err instanceof RangeError)) {\n      throw err;\n    }\n    throw 'Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH.';\n  }\n\n  // Insert new element\n  try {\n    // Attempting to call this with JS function will cause of table.set() to fail\n    table.set(ret, func);\n  } catch (err) {\n    if (!(err instanceof TypeError)) {\n      throw err;\n    }\n    assert(typeof sig !== 'undefined', 'Missing signature argument to addFunction');\n    var wrapped = convertJsFunctionToWasm(func, sig);\n    table.set(ret, wrapped);\n  }\n\n  return ret;\n}\n\nfunction removeFunctionWasm(index) {\n  // TODO(sbc): Look into implementing this to allow re-using of table slots\n}\n\n// 'sig' parameter is required for the llvm backend but only when func is not\n// already a WebAssembly function.\nfunction addFunction(func, sig) {\n  assert(typeof func !== 'undefined');\n  if (typeof sig === 'undefined') {\n    err('warning: addFunction(): You should provide a wasm function signature string as a second argument. This is not necessary for asm.js and asm2wasm, but can be required for the LLVM wasm backend, so it is recommended for full portability.');\n  }\n\n  return addFunctionWasm(func, sig);\n}\n\nfunction removeFunction(index) {\n  removeFunctionWasm(index);\n}\n\nvar funcWrappers = {};\n\nfunction getFuncWrapper(func, sig) {\n  if (!func) return; // on null pointer, return undefined\n  assert(sig);\n  if (!funcWrappers[sig]) {\n    funcWrappers[sig] = {};\n  }\n  var sigCache = funcWrappers[sig];\n  if (!sigCache[func]) {\n    // optimize away arguments usage in common cases\n    if (sig.length === 1) {\n      sigCache[func] = function dynCall_wrapper() {\n        return dynCall(sig, func);\n      };\n    } else if (sig.length === 2) {\n      sigCache[func] = function dynCall_wrapper(arg) {\n        return dynCall(sig, func, [arg]);\n      };\n    } else {\n      // general case\n      sigCache[func] = function dynCall_wrapper() {\n        return dynCall(sig, func, Array.prototype.slice.call(arguments));\n      };\n    }\n  }\n  return sigCache[func];\n}\n\n\nfunction makeBigInt(low, high, unsigned) {\n  return unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0));\n}\n\nfunction dynCall(sig, ptr, args) {\n  if (args && args.length) {\n    assert(args.length == sig.length-1);\n    assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n    return Module['dynCall_' + sig].apply(null, [ptr].concat(args));\n  } else {\n    assert(sig.length == 1);\n    assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n    return Module['dynCall_' + sig].call(null, ptr);\n  }\n}\n\nvar tempRet0 = 0;\n\nvar setTempRet0 = function(value) {\n  tempRet0 = value;\n};\n\nvar getTempRet0 = function() {\n  return tempRet0;\n};\n\nfunction getCompilerSetting(name) {\n  throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work';\n}\n\nvar Runtime = {\n  // helpful errors\n  getTempRet0: function() { abort('getTempRet0() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"') },\n  staticAlloc: function() { abort('staticAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"') },\n  stackAlloc: function() { abort('stackAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"') },\n};\n\n// The address globals begin at. Very low in memory, for code size and optimization opportunities.\n// Above 0 is static memory, starting with globals.\n// Then the stack.\n// Then 'dynamic' memory for sbrk.\nvar GLOBAL_BASE = 1024;\n\n\n\n\n// === Preamble library stuff ===\n\n// Documentation for the public APIs defined in this file must be updated in:\n//    site/source/docs/api_reference/preamble.js.rst\n// A prebuilt local version of the documentation is available at:\n//    site/build/text/docs/api_reference/preamble.js.txt\n// You can also build docs locally as HTML or other formats in site/\n// An online HTML version (which may be of a different version of Emscripten)\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\n\nvar wasmBinary;if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];if (!Object.getOwnPropertyDescriptor(Module, 'wasmBinary')) Object.defineProperty(Module, 'wasmBinary', { configurable: true, get: function() { abort('Module.wasmBinary has been replaced with plain wasmBinary') } });\nvar noExitRuntime;if (Module['noExitRuntime']) noExitRuntime = Module['noExitRuntime'];if (!Object.getOwnPropertyDescriptor(Module, 'noExitRuntime')) Object.defineProperty(Module, 'noExitRuntime', { configurable: true, get: function() { abort('Module.noExitRuntime has been replaced with plain noExitRuntime') } });\n\n\nif (typeof WebAssembly !== 'object') {\n  abort('No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.');\n}\n\n\n// In MINIMAL_RUNTIME, setValue() and getValue() are only available when building with safe heap enabled, for heap safety checking.\n// In traditional runtime, setValue() and getValue() are always available (although their use is highly discouraged due to perf penalties)\n\n/** @type {function(number, number, string, boolean=)} */\nfunction setValue(ptr, value, type, noSafe) {\n  type = type || 'i8';\n  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit\n  if (noSafe) {\n    switch(type) {\n      case 'i1': HEAP8[((ptr)>>0)]=value; break;\n      case 'i8': HEAP8[((ptr)>>0)]=value; break;\n      case 'i16': HEAP16[((ptr)>>1)]=value; break;\n      case 'i32': HEAP32[((ptr)>>2)]=value; break;\n      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;\n      case 'float': HEAPF32[((ptr)>>2)]=value; break;\n      case 'double': HEAPF64[((ptr)>>3)]=value; break;\n      default: abort('invalid type for setValue: ' + type);\n    }\n  } else {\n    switch(type) {\n      case 'i1': SAFE_HEAP_STORE(((ptr)|0), ((value)|0), 1); break;\n      case 'i8': SAFE_HEAP_STORE(((ptr)|0), ((value)|0), 1); break;\n      case 'i16': SAFE_HEAP_STORE(((ptr)|0), ((value)|0), 2); break;\n      case 'i32': SAFE_HEAP_STORE(((ptr)|0), ((value)|0), 4); break;\n      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],SAFE_HEAP_STORE(((ptr)|0), ((tempI64[0])|0), 4),SAFE_HEAP_STORE((((ptr)+(4))|0), ((tempI64[1])|0), 4)); break;\n      case 'float': SAFE_HEAP_STORE_D(((ptr)|0), Math_fround(value), 4); break;\n      case 'double': SAFE_HEAP_STORE_D(((ptr)|0), (+(value)), 8); break;\n      default: abort('invalid type for setValue: ' + type);\n    }\n  }\n}\n\n/** @type {function(number, string, boolean=)} */\nfunction getValue(ptr, type, noSafe) {\n  type = type || 'i8';\n  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit\n  if (noSafe) {\n    switch(type) {\n      case 'i1': return HEAP8[((ptr)>>0)];\n      case 'i8': return HEAP8[((ptr)>>0)];\n      case 'i16': return HEAP16[((ptr)>>1)];\n      case 'i32': return HEAP32[((ptr)>>2)];\n      case 'i64': return HEAP32[((ptr)>>2)];\n      case 'float': return HEAPF32[((ptr)>>2)];\n      case 'double': return HEAPF64[((ptr)>>3)];\n      default: abort('invalid type for getValue: ' + type);\n    }\n  } else {\n    switch(type) {\n      case 'i1': return ((SAFE_HEAP_LOAD(((ptr)|0), 1, 0))|0);\n      case 'i8': return ((SAFE_HEAP_LOAD(((ptr)|0), 1, 0))|0);\n      case 'i16': return ((SAFE_HEAP_LOAD(((ptr)|0), 2, 0))|0);\n      case 'i32': return ((SAFE_HEAP_LOAD(((ptr)|0), 4, 0))|0);\n      case 'i64': return ((SAFE_HEAP_LOAD(((ptr)|0), 8, 0))|0);\n      case 'float': return Math_fround(SAFE_HEAP_LOAD_D(((ptr)|0), 4, 0));\n      case 'double': return (+(SAFE_HEAP_LOAD_D(((ptr)|0), 8, 0)));\n      default: abort('invalid type for getValue: ' + type);\n    }\n  }\n  return null;\n}\n\n\nfunction getSafeHeapType(bytes, isFloat) {\n  switch (bytes) {\n    case 1: return 'i8';\n    case 2: return 'i16';\n    case 4: return isFloat ? 'float' : 'i32';\n    case 8: return 'double';\n    default: assert(0);\n  }\n}\n\n\nfunction SAFE_HEAP_STORE(dest, value, bytes, isFloat) {\n  if (dest <= 0) abort('segmentation fault storing ' + bytes + ' bytes to address ' + dest);\n  if (dest % bytes !== 0) abort('alignment error storing to address ' + dest + ', which was expected to be aligned to a multiple of ' + bytes);\n  if (dest + bytes > HEAP32[DYNAMICTOP_PTR>>2]) abort('segmentation fault, exceeded the top of the available dynamic heap when storing ' + bytes + ' bytes to address ' + dest + '. DYNAMICTOP=' + HEAP32[DYNAMICTOP_PTR>>2]);\n  assert(DYNAMICTOP_PTR);\n  assert(HEAP32[DYNAMICTOP_PTR>>2] <= HEAP8.length);\n  setValue(dest, value, getSafeHeapType(bytes, isFloat), 1);\n}\nfunction SAFE_HEAP_STORE_D(dest, value, bytes) {\n  SAFE_HEAP_STORE(dest, value, bytes, true);\n}\n\nfunction SAFE_HEAP_LOAD(dest, bytes, unsigned, isFloat) {\n  if (dest <= 0) abort('segmentation fault loading ' + bytes + ' bytes from address ' + dest);\n  if (dest % bytes !== 0) abort('alignment error loading from address ' + dest + ', which was expected to be aligned to a multiple of ' + bytes);\n  if (dest + bytes > HEAP32[DYNAMICTOP_PTR>>2]) abort('segmentation fault, exceeded the top of the available dynamic heap when loading ' + bytes + ' bytes from address ' + dest + '. DYNAMICTOP=' + HEAP32[DYNAMICTOP_PTR>>2]);\n  assert(DYNAMICTOP_PTR);\n  assert(HEAP32[DYNAMICTOP_PTR>>2] <= HEAP8.length);\n  var type = getSafeHeapType(bytes, isFloat);\n  var ret = getValue(dest, type, 1);\n  if (unsigned) ret = unSign(ret, parseInt(type.substr(1)), 1);\n  return ret;\n}\nfunction SAFE_HEAP_LOAD_D(dest, bytes, unsigned) {\n  return SAFE_HEAP_LOAD(dest, bytes, unsigned, true);\n}\n\nfunction SAFE_FT_MASK(value, mask) {\n  var ret = value & mask;\n  if (ret !== value) {\n    abort('Function table mask error: function pointer is ' + value + ' which is masked by ' + mask + ', the likely cause of this is that the function pointer is being called by the wrong type.');\n  }\n  return ret;\n}\n\nfunction segfault() {\n  abort('segmentation fault');\n}\nfunction alignfault() {\n  abort('alignment fault');\n}\nfunction ftfault() {\n  abort('Function table mask error');\n}\n\n\n\n// Wasm globals\n\nvar wasmMemory;\n\n// In fastcomp asm.js, we don't need a wasm Table at all.\n// In the wasm backend, we polyfill the WebAssembly object,\n// so this creates a (non-native-wasm) table for us.\nvar wasmTable = new WebAssembly.Table({\n  'initial': 401,\n  'maximum': 401 + 0,\n  'element': 'anyfunc'\n});\n\n\n//========================================\n// Runtime essentials\n//========================================\n\n// whether we are quitting the application. no code should run after this.\n// set in exit() and abort()\nvar ABORT = false;\n\n// set by exit() and abort().  Passed to 'onExit' handler.\n// NOTE: This is also used as the process return code code in shell environments\n// but only when noExitRuntime is false.\nvar EXITSTATUS = 0;\n\n/** @type {function(*, string=)} */\nfunction assert(condition, text) {\n  if (!condition) {\n    abort('Assertion failed: ' + text);\n  }\n}\n\n// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\nfunction getCFunc(ident) {\n  var func = Module['_' + ident]; // closure exported function\n  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\n  return func;\n}\n\n// C calling interface.\nfunction ccall(ident, returnType, argTypes, args, opts) {\n  // For fast lookup of conversion functions\n  var toC = {\n    'string': function(str) {\n      var ret = 0;\n      if (str !== null && str !== undefined && str !== 0) { // null string\n        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n        var len = (str.length << 2) + 1;\n        ret = stackAlloc(len);\n        stringToUTF8(str, ret, len);\n      }\n      return ret;\n    },\n    'array': function(arr) {\n      var ret = stackAlloc(arr.length);\n      writeArrayToMemory(arr, ret);\n      return ret;\n    }\n  };\n\n  function convertReturnValue(ret) {\n    if (returnType === 'string') return UTF8ToString(ret);\n    if (returnType === 'boolean') return Boolean(ret);\n    return ret;\n  }\n\n  var func = getCFunc(ident);\n  var cArgs = [];\n  var stack = 0;\n  assert(returnType !== 'array', 'Return type should not be \"array\".');\n  if (args) {\n    for (var i = 0; i < args.length; i++) {\n      var converter = toC[argTypes[i]];\n      if (converter) {\n        if (stack === 0) stack = stackSave();\n        cArgs[i] = converter(args[i]);\n      } else {\n        cArgs[i] = args[i];\n      }\n    }\n  }\n  var ret = func.apply(null, cArgs);\n\n  ret = convertReturnValue(ret);\n  if (stack !== 0) stackRestore(stack);\n  return ret;\n}\n\nfunction cwrap(ident, returnType, argTypes, opts) {\n  return function() {\n    return ccall(ident, returnType, argTypes, arguments, opts);\n  }\n}\n\nvar ALLOC_NORMAL = 0; // Tries to use _malloc()\nvar ALLOC_STACK = 1; // Lives for the duration of the current function call\nvar ALLOC_DYNAMIC = 2; // Cannot be freed except through sbrk\nvar ALLOC_NONE = 3; // Do not allocate\n\n// allocate(): This is for internal use. You can use it yourself as well, but the interface\n//             is a little tricky (see docs right below). The reason is that it is optimized\n//             for multiple syntaxes to save space in generated code. So you should\n//             normally not use allocate(), and instead allocate memory using _malloc(),\n//             initialize it with setValue(), and so forth.\n// @slab: An array of data, or a number. If a number, then the size of the block to allocate,\n//        in *bytes* (note that this is sometimes confusing: the next parameter does not\n//        affect this!)\n// @types: Either an array of types, one for each byte (or 0 if no type at that position),\n//         or a single type which is used for the entire block. This only matters if there\n//         is initial data - if @slab is a number, then this does not matter at all and is\n//         ignored.\n// @allocator: How to allocate memory, see ALLOC_*\n/** @type {function((TypedArray|Array<number>|number), string, number, number=)} */\nfunction allocate(slab, types, allocator, ptr) {\n  var zeroinit, size;\n  if (typeof slab === 'number') {\n    zeroinit = true;\n    size = slab;\n  } else {\n    zeroinit = false;\n    size = slab.length;\n  }\n\n  var singleType = typeof types === 'string' ? types : null;\n\n  var ret;\n  if (allocator == ALLOC_NONE) {\n    ret = ptr;\n  } else {\n    ret = [_malloc,\n    stackAlloc,\n    dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));\n  }\n\n  if (zeroinit) {\n    var stop;\n    ptr = ret;\n    assert((ret & 3) == 0);\n    stop = ret + (size & ~3);\n    for (; ptr < stop; ptr += 4) {\n      HEAP32[((ptr)>>2)]=0;\n    }\n    stop = ret + size;\n    while (ptr < stop) {\n      HEAP8[((ptr++)>>0)]=0;\n    }\n    return ret;\n  }\n\n  if (singleType === 'i8') {\n    if (slab.subarray || slab.slice) {\n      HEAPU8.set(/** @type {!Uint8Array} */ (slab), ret);\n    } else {\n      HEAPU8.set(new Uint8Array(slab), ret);\n    }\n    return ret;\n  }\n\n  var i = 0, type, typeSize, previousType;\n  while (i < size) {\n    var curr = slab[i];\n\n    type = singleType || types[i];\n    if (type === 0) {\n      i++;\n      continue;\n    }\n    assert(type, 'Must know what type to store in allocate!');\n\n    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later\n\n    setValue(ret+i, curr, type);\n\n    // no need to look up size unless type changes, so cache it\n    if (previousType !== type) {\n      typeSize = getNativeTypeSize(type);\n      previousType = type;\n    }\n    i += typeSize;\n  }\n\n  return ret;\n}\n\n// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready\nfunction getMemory(size) {\n  if (!runtimeInitialized) return dynamicAlloc(size);\n  return _malloc(size);\n}\n\n\n\n\n// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nfunction AsciiToString(ptr) {\n  var str = '';\n  while (1) {\n    var ch = ((SAFE_HEAP_LOAD(((ptr++)|0), 1, 1))|0);\n    if (!ch) return str;\n    str += String.fromCharCode(ch);\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\n\nfunction stringToAscii(str, outPtr) {\n  return writeAsciiToMemory(str, outPtr, false);\n}\n\n\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\n// a copy of that string as a Javascript String object.\n\nvar UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;\n\n/**\n * @param {number} idx\n * @param {number=} maxBytesToRead\n * @return {string}\n */\nfunction UTF8ArrayToString(u8Array, idx, maxBytesToRead) {\n  var endIdx = idx + maxBytesToRead;\n  var endPtr = idx;\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)\n  while (u8Array[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n\n  if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\n    return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\n  } else {\n    var str = '';\n    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that\n    while (idx < endPtr) {\n      // For UTF8 byte structure, see:\n      // http://en.wikipedia.org/wiki/UTF-8#Description\n      // https://www.ietf.org/rfc/rfc2279.txt\n      // https://tools.ietf.org/html/rfc3629\n      var u0 = u8Array[idx++];\n      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\n      var u1 = u8Array[idx++] & 63;\n      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\n      var u2 = u8Array[idx++] & 63;\n      if ((u0 & 0xF0) == 0xE0) {\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n      } else {\n        if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte 0x' + u0.toString(16) + ' encountered when deserializing a UTF-8 string on the asm.js/wasm heap to a JS string!');\n        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (u8Array[idx++] & 63);\n      }\n\n      if (u0 < 0x10000) {\n        str += String.fromCharCode(u0);\n      } else {\n        var ch = u0 - 0x10000;\n        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n      }\n    }\n  }\n  return str;\n}\n\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a\n// copy of that string as a Javascript String object.\n// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit\n//                 this parameter to scan the string until the first \\0 byte. If maxBytesToRead is\n//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the\n//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will\n//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)\n//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may\n//                 throw JS JIT optimizations off, so it is worth to consider consistently using one\n//                 style or the other.\n/**\n * @param {number} ptr\n * @param {number=} maxBytesToRead\n * @return {string}\n */\nfunction UTF8ToString(ptr, maxBytesToRead) {\n  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\n}\n\n// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\n// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.\n//   outIdx: The starting offset in the array to begin the copying.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array.\n//                    This count should include the null terminator,\n//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\n  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\n    return 0;\n\n  var startIdx = outIdx;\n  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n    if (u >= 0xD800 && u <= 0xDFFF) {\n      var u1 = str.charCodeAt(++i);\n      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);\n    }\n    if (u <= 0x7F) {\n      if (outIdx >= endIdx) break;\n      outU8Array[outIdx++] = u;\n    } else if (u <= 0x7FF) {\n      if (outIdx + 1 >= endIdx) break;\n      outU8Array[outIdx++] = 0xC0 | (u >> 6);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else if (u <= 0xFFFF) {\n      if (outIdx + 2 >= endIdx) break;\n      outU8Array[outIdx++] = 0xE0 | (u >> 12);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else {\n      if (outIdx + 3 >= endIdx) break;\n      if (u >= 0x200000) warnOnce('Invalid Unicode code point 0x' + u.toString(16) + ' encountered when serializing a JS string to an UTF-8 string on the asm.js/wasm heap! (Valid unicode code points should be in range 0-0x1FFFFF).');\n      outU8Array[outIdx++] = 0xF0 | (u >> 18);\n      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    }\n  }\n  // Null-terminate the pointer to the buffer.\n  outU8Array[outIdx] = 0;\n  return outIdx - startIdx;\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\nfunction lengthBytesUTF8(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\n    if (u <= 0x7F) ++len;\n    else if (u <= 0x7FF) len += 2;\n    else if (u <= 0xFFFF) len += 3;\n    else len += 4;\n  }\n  return len;\n}\n\n\n// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nvar UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;\nfunction UTF16ToString(ptr) {\n  assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');\n  var endPtr = ptr;\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n  var idx = endPtr >> 1;\n  while (HEAP16[idx]) ++idx;\n  endPtr = idx << 1;\n\n  if (endPtr - ptr > 32 && UTF16Decoder) {\n    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n  } else {\n    var i = 0;\n\n    var str = '';\n    while (1) {\n      var codeUnit = ((SAFE_HEAP_LOAD((((ptr)+(i*2))|0), 2, 0))|0);\n      if (codeUnit == 0) return str;\n      ++i;\n      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\n      str += String.fromCharCode(codeUnit);\n    }\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\n// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\n  assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n  if (maxBytesToWrite === undefined) {\n    maxBytesToWrite = 0x7FFFFFFF;\n  }\n  if (maxBytesToWrite < 2) return 0;\n  maxBytesToWrite -= 2; // Null terminator.\n  var startPtr = outPtr;\n  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;\n  for (var i = 0; i < numCharsToWrite; ++i) {\n    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n    SAFE_HEAP_STORE(((outPtr)|0), ((codeUnit)|0), 2);\n    outPtr += 2;\n  }\n  // Null-terminate the pointer to the HEAP.\n  SAFE_HEAP_STORE(((outPtr)|0), ((0)|0), 2);\n  return outPtr - startPtr;\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF16(str) {\n  return str.length*2;\n}\n\nfunction UTF32ToString(ptr) {\n  assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');\n  var i = 0;\n\n  var str = '';\n  while (1) {\n    var utf32 = ((SAFE_HEAP_LOAD((((ptr)+(i*4))|0), 4, 0))|0);\n    if (utf32 == 0)\n      return str;\n    ++i;\n    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    if (utf32 >= 0x10000) {\n      var ch = utf32 - 0x10000;\n      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n    } else {\n      str += String.fromCharCode(utf32);\n    }\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\n// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\n  assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n  if (maxBytesToWrite === undefined) {\n    maxBytesToWrite = 0x7FFFFFFF;\n  }\n  if (maxBytesToWrite < 4) return 0;\n  var startPtr = outPtr;\n  var endPtr = startPtr + maxBytesToWrite - 4;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\n      var trailSurrogate = str.charCodeAt(++i);\n      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);\n    }\n    SAFE_HEAP_STORE(((outPtr)|0), ((codeUnit)|0), 4);\n    outPtr += 4;\n    if (outPtr + 4 > endPtr) break;\n  }\n  // Null-terminate the pointer to the HEAP.\n  SAFE_HEAP_STORE(((outPtr)|0), ((0)|0), 4);\n  return outPtr - startPtr;\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF32(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var codeUnit = str.charCodeAt(i);\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\n    len += 4;\n  }\n\n  return len;\n}\n\n// Allocate heap space for a JS string, and write it there.\n// It is the responsibility of the caller to free() that memory.\nfunction allocateUTF8(str) {\n  var size = lengthBytesUTF8(str) + 1;\n  var ret = _malloc(size);\n  if (ret) stringToUTF8Array(str, HEAP8, ret, size);\n  return ret;\n}\n\n// Allocate stack space for a JS string, and write it there.\nfunction allocateUTF8OnStack(str) {\n  var size = lengthBytesUTF8(str) + 1;\n  var ret = stackAlloc(size);\n  stringToUTF8Array(str, HEAP8, ret, size);\n  return ret;\n}\n\n// Deprecated: This function should not be called because it is unsafe and does not provide\n// a maximum length limit of how many bytes it is allowed to write. Prefer calling the\n// function stringToUTF8Array() instead, which takes in a maximum length that can be used\n// to be secure from out of bounds writes.\n/** @deprecated */\nfunction writeStringToMemory(string, buffer, dontAddNull) {\n  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');\n\n  var /** @type {number} */ lastChar, /** @type {number} */ end;\n  if (dontAddNull) {\n    // stringToUTF8Array always appends null. If we don't want to do that, remember the\n    // character that existed at the location where the null will be placed, and restore\n    // that after the write (below).\n    end = buffer + lengthBytesUTF8(string);\n    lastChar = HEAP8[end];\n  }\n  stringToUTF8(string, buffer, Infinity);\n  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\n}\n\nfunction writeArrayToMemory(array, buffer) {\n  assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)')\n  HEAP8.set(array, buffer);\n}\n\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\n  for (var i = 0; i < str.length; ++i) {\n    assert(str.charCodeAt(i) === str.charCodeAt(i)&0xff);\n    SAFE_HEAP_STORE(((buffer++)|0), ((str.charCodeAt(i))|0), 1);\n  }\n  // Null-terminate the pointer to the HEAP.\n  if (!dontAddNull) SAFE_HEAP_STORE(((buffer)|0), ((0)|0), 1);\n}\n\n\n\n\n// Memory management\n\nvar PAGE_SIZE = 16384;\nvar WASM_PAGE_SIZE = 65536;\nvar ASMJS_PAGE_SIZE = 16777216;\n\nfunction alignUp(x, multiple) {\n  if (x % multiple > 0) {\n    x += multiple - (x % multiple);\n  }\n  return x;\n}\n\nvar HEAP,\n/** @type {ArrayBuffer} */\n  buffer,\n/** @type {Int8Array} */\n  HEAP8,\n/** @type {Uint8Array} */\n  HEAPU8,\n/** @type {Int16Array} */\n  HEAP16,\n/** @type {Uint16Array} */\n  HEAPU16,\n/** @type {Int32Array} */\n  HEAP32,\n/** @type {Uint32Array} */\n  HEAPU32,\n/** @type {Float32Array} */\n  HEAPF32,\n/** @type {Float64Array} */\n  HEAPF64;\n\nfunction updateGlobalBufferAndViews(buf) {\n  buffer = buf;\n  Module['HEAP8'] = HEAP8 = new Int8Array(buf);\n  Module['HEAP16'] = HEAP16 = new Int16Array(buf);\n  Module['HEAP32'] = HEAP32 = new Int32Array(buf);\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);\n}\n\nvar STATIC_BASE = 1024,\n    STACK_BASE = 5291696,\n    STACKTOP = STACK_BASE,\n    STACK_MAX = 48816,\n    DYNAMIC_BASE = 5291696,\n    DYNAMICTOP_PTR = 48656;\n\nassert(STACK_BASE % 16 === 0, 'stack must start aligned');\nassert(DYNAMIC_BASE % 16 === 0, 'heap must start aligned');\n\n\n\nvar TOTAL_STACK = 5242880;\nif (Module['TOTAL_STACK']) assert(TOTAL_STACK === Module['TOTAL_STACK'], 'the stack size can no longer be determined at runtime')\n\nvar INITIAL_TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;if (!Object.getOwnPropertyDescriptor(Module, 'TOTAL_MEMORY')) Object.defineProperty(Module, 'TOTAL_MEMORY', { configurable: true, get: function() { abort('Module.TOTAL_MEMORY has been replaced with plain INITIAL_TOTAL_MEMORY') } });\n\nassert(INITIAL_TOTAL_MEMORY >= TOTAL_STACK, 'TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + INITIAL_TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');\n\n// check for full engine support (use string 'subarray' to avoid closure compiler confusion)\nassert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined,\n       'JS engine does not provide full typed array support');\n\n\n\n\n\n\n// In standalone mode, the wasm creates the memory, and the user can't provide it.\n// In non-standalone/normal mode, we create the memory here.\n\n// Create the main memory. (Note: this isn't used in STANDALONE_WASM mode since the wasm\n// memory is created in the wasm, not in JS.)\n\n  if (Module['wasmMemory']) {\n    wasmMemory = Module['wasmMemory'];\n  } else\n  {\n    wasmMemory = new WebAssembly.Memory({\n      'initial': INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE\n    });\n  }\n\n\nif (wasmMemory) {\n  buffer = wasmMemory.buffer;\n}\n\n// If the user provides an incorrect length, just use that length instead rather than providing the user to\n// specifically provide the memory length with Module['TOTAL_MEMORY'].\nINITIAL_TOTAL_MEMORY = buffer.byteLength;\nassert(INITIAL_TOTAL_MEMORY % WASM_PAGE_SIZE === 0);\nupdateGlobalBufferAndViews(buffer);\n\nHEAP32[DYNAMICTOP_PTR>>2] = DYNAMIC_BASE;\n\n\n\n\n// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\nfunction writeStackCookie() {\n  assert((STACK_MAX & 3) == 0);\n  // The stack grows downwards\n  HEAPU32[(STACK_MAX >> 2)+1] = 0x2135467;\n  HEAPU32[(STACK_MAX >> 2)+2] = 0x89BACDFE;\n  // Also test the global address 0 for integrity.\n  // We don't do this with ASan because ASan does its own checks for this.\n  HEAP32[0] = 0x63736d65; /* 'emsc' */\n}\n\nfunction checkStackCookie() {\n  var cookie1 = HEAPU32[(STACK_MAX >> 2)+1];\n  var cookie2 = HEAPU32[(STACK_MAX >> 2)+2];\n  if (cookie1 != 0x2135467 || cookie2 != 0x89BACDFE) {\n    abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x2135467, but received 0x' + cookie2.toString(16) + ' ' + cookie1.toString(16));\n  }\n  // Also test the global address 0 for integrity.\n  // We don't do this with ASan because ASan does its own checks for this.\n  if (HEAP32[0] !== 0x63736d65 /* 'emsc' */) abort('Runtime error: The application has corrupted its heap memory area (address zero)!');\n}\n\nfunction abortStackOverflow(allocSize) {\n  abort('Stack overflow! Attempted to allocate ' + allocSize + ' bytes on the stack, but stack has only ' + (STACK_MAX - stackSave() + allocSize) + ' bytes available!');\n}\n\n\n\n\n// Endianness check (note: assumes compiler arch was little-endian)\n(function() {\n  var h16 = new Int16Array(1);\n  var h8 = new Int8Array(h16.buffer);\n  h16[0] = 0x6373;\n  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';\n})();\n\nfunction abortFnPtrError(ptr, sig) {\n\tvar possibleSig = '';\n\tfor(var x in debug_tables) {\n\t\tvar tbl = debug_tables[x];\n\t\tif (tbl[ptr]) {\n\t\t\tpossibleSig += 'as sig \"' + x + '\" pointing to function ' + tbl[ptr] + ', ';\n\t\t}\n\t}\n\tabort(\"Invalid function pointer \" + ptr + \" called with signature '\" + sig + \"'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this). This pointer might make sense in another type signature: \" + possibleSig);\n}\n\n\n\nfunction callRuntimeCallbacks(callbacks) {\n  while(callbacks.length > 0) {\n    var callback = callbacks.shift();\n    if (typeof callback == 'function') {\n      callback();\n      continue;\n    }\n    var func = callback.func;\n    if (typeof func === 'number') {\n      if (callback.arg === undefined) {\n        Module['dynCall_v'](func);\n      } else {\n        Module['dynCall_vi'](func, callback.arg);\n      }\n    } else {\n      func(callback.arg === undefined ? null : callback.arg);\n    }\n  }\n}\n\nvar __ATPRERUN__  = []; // functions called before the runtime is initialized\nvar __ATINIT__    = []; // functions called during startup\nvar __ATMAIN__    = []; // functions called when main() is to be run\nvar __ATEXIT__    = []; // functions called during shutdown\nvar __ATPOSTRUN__ = []; // functions called after the main() is called\n\nvar runtimeInitialized = false;\nvar runtimeExited = false;\n\n\nfunction preRun() {\n\n  if (Module['preRun']) {\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n    while (Module['preRun'].length) {\n      addOnPreRun(Module['preRun'].shift());\n    }\n  }\n\n  callRuntimeCallbacks(__ATPRERUN__);\n}\n\nfunction initRuntime() {\n  checkStackCookie();\n  assert(!runtimeInitialized);\n  runtimeInitialized = true;\n  \n  callRuntimeCallbacks(__ATINIT__);\n}\n\nfunction preMain() {\n  checkStackCookie();\n  \n  callRuntimeCallbacks(__ATMAIN__);\n}\n\nfunction exitRuntime() {\n  checkStackCookie();\n  runtimeExited = true;\n}\n\nfunction postRun() {\n  checkStackCookie();\n\n  if (Module['postRun']) {\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n    while (Module['postRun'].length) {\n      addOnPostRun(Module['postRun'].shift());\n    }\n  }\n\n  callRuntimeCallbacks(__ATPOSTRUN__);\n}\n\nfunction addOnPreRun(cb) {\n  __ATPRERUN__.unshift(cb);\n}\n\nfunction addOnInit(cb) {\n  __ATINIT__.unshift(cb);\n}\n\nfunction addOnPreMain(cb) {\n  __ATMAIN__.unshift(cb);\n}\n\nfunction addOnExit(cb) {\n}\n\nfunction addOnPostRun(cb) {\n  __ATPOSTRUN__.unshift(cb);\n}\n\nfunction unSign(value, bits, ignore) {\n  if (value >= 0) {\n    return value;\n  }\n  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts\n                    : Math.pow(2, bits)         + value;\n}\nfunction reSign(value, bits, ignore) {\n  if (value <= 0) {\n    return value;\n  }\n  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32\n                        : Math.pow(2, bits-1);\n  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that\n                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors\n                                                       // TODO: In i64 mode 1, resign the two parts separately and safely\n    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts\n  }\n  return value;\n}\n\n\nassert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nassert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nassert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nassert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n\nvar Math_abs = Math.abs;\nvar Math_cos = Math.cos;\nvar Math_sin = Math.sin;\nvar Math_tan = Math.tan;\nvar Math_acos = Math.acos;\nvar Math_asin = Math.asin;\nvar Math_atan = Math.atan;\nvar Math_atan2 = Math.atan2;\nvar Math_exp = Math.exp;\nvar Math_log = Math.log;\nvar Math_sqrt = Math.sqrt;\nvar Math_ceil = Math.ceil;\nvar Math_floor = Math.floor;\nvar Math_pow = Math.pow;\nvar Math_imul = Math.imul;\nvar Math_fround = Math.fround;\nvar Math_round = Math.round;\nvar Math_min = Math.min;\nvar Math_max = Math.max;\nvar Math_clz32 = Math.clz32;\nvar Math_trunc = Math.trunc;\n\n\n\n// A counter of dependencies for calling run(). If we need to\n// do asynchronous work before running, increment this and\n// decrement it. Incrementing must happen in a place like\n// Module.preRun (used by emcc to add file preloading).\n// Note that you can add dependencies in preRun, even though\n// it happens right before run - run will be postponed until\n// the dependencies are met.\nvar runDependencies = 0;\nvar runDependencyWatcher = null;\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\nvar runDependencyTracking = {};\n\nfunction getUniqueRunDependency(id) {\n  var orig = id;\n  while (1) {\n    if (!runDependencyTracking[id]) return id;\n    id = orig + Math.random();\n  }\n  return id;\n}\n\nfunction addRunDependency(id) {\n  runDependencies++;\n\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n\n  if (id) {\n    assert(!runDependencyTracking[id]);\n    runDependencyTracking[id] = 1;\n    if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {\n      // Check for missing dependencies every few seconds\n      runDependencyWatcher = setInterval(function() {\n        if (ABORT) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n          return;\n        }\n        var shown = false;\n        for (var dep in runDependencyTracking) {\n          if (!shown) {\n            shown = true;\n            err('still waiting on run dependencies:');\n          }\n          err('dependency: ' + dep);\n        }\n        if (shown) {\n          err('(end of list)');\n        }\n      }, 10000);\n    }\n  } else {\n    err('warning: run dependency added without ID');\n  }\n}\n\nfunction removeRunDependency(id) {\n  runDependencies--;\n\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n\n  if (id) {\n    assert(runDependencyTracking[id]);\n    delete runDependencyTracking[id];\n  } else {\n    err('warning: run dependency removed without ID');\n  }\n  if (runDependencies == 0) {\n    if (runDependencyWatcher !== null) {\n      clearInterval(runDependencyWatcher);\n      runDependencyWatcher = null;\n    }\n    if (dependenciesFulfilled) {\n      var callback = dependenciesFulfilled;\n      dependenciesFulfilled = null;\n      callback(); // can add another dependenciesFulfilled\n    }\n  }\n}\n\nModule[\"preloadedImages\"] = {}; // maps url to image data\nModule[\"preloadedAudios\"] = {}; // maps url to audio data\n\n\nfunction abort(what) {\n  if (Module['onAbort']) {\n    Module['onAbort'](what);\n  }\n\n  what += '';\n  out(what);\n  err(what);\n\n  ABORT = true;\n  EXITSTATUS = 1;\n\n  var output = 'abort(' + what + ') at ' + stackTrace();\n  what = output;\n\n  // Throw a wasm runtime error, because a JS error might be seen as a foreign\n  // exception, which means we'd run destructors on it. We need the error to\n  // simply make the program stop.\n  throw new WebAssembly.RuntimeError(what);\n}\n\n\nvar memoryInitializer = null;\n\n\n\n// show errors on likely calls to FS when it was not included\nvar FS = {\n  error: function() {\n    abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1');\n  },\n  init: function() { FS.error() },\n  createDataFile: function() { FS.error() },\n  createPreloadedFile: function() { FS.error() },\n  createLazyFile: function() { FS.error() },\n  open: function() { FS.error() },\n  mkdev: function() { FS.error() },\n  registerDevice: function() { FS.error() },\n  analyzePath: function() { FS.error() },\n  loadFilesFromDB: function() { FS.error() },\n\n  ErrnoError: function ErrnoError() { FS.error() },\n};\nModule['FS_createDataFile'] = FS.createDataFile;\nModule['FS_createPreloadedFile'] = FS.createPreloadedFile;\n\n\n\n// Copyright 2017 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n\n// Prefix of data URIs emitted by SINGLE_FILE and related options.\nvar dataURIPrefix = 'data:application/octet-stream;base64,';\n\n// Indicates whether filename is a base64 data URI.\nfunction isDataURI(filename) {\n  return String.prototype.startsWith ?\n      filename.startsWith(dataURIPrefix) :\n      filename.indexOf(dataURIPrefix) === 0;\n}\n\n\n\n\nvar wasmBinaryFile = 'greycat.wasm';\nif (!isDataURI(wasmBinaryFile)) {\n  wasmBinaryFile = locateFile(wasmBinaryFile);\n}\n\nfunction getBinary() {\n  try {\n    if (wasmBinary) {\n      return new Uint8Array(wasmBinary);\n    }\n\n    if (readBinary) {\n      return readBinary(wasmBinaryFile);\n    } else {\n      throw \"both async and sync fetching of the wasm failed\";\n    }\n  }\n  catch (err) {\n    abort(err);\n  }\n}\n\nfunction getBinaryPromise() {\n  // if we don't have the binary yet, and have the Fetch api, use that\n  // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web\n  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {\n    return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {\n      if (!response['ok']) {\n        throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n      }\n      return response['arrayBuffer']();\n    }).catch(function () {\n      return getBinary();\n    });\n  }\n  // Otherwise, getBinary should be able to get it synchronously\n  return new Promise(function(resolve, reject) {\n    resolve(getBinary());\n  });\n}\n\n\n\n// Create the wasm instance.\n// Receives the wasm imports, returns the exports.\nfunction createWasm() {\n  // prepare imports\n  var info = {\n    'env': asmLibraryArg,\n    'wasi_snapshot_preview1': asmLibraryArg\n  };\n  // Load the wasm module and create an instance of using native support in the JS engine.\n  // handle a generated wasm instance, receiving its exports and\n  // performing other necessary setup\n  function receiveInstance(instance, module) {\n    var exports = instance.exports;\n    Module['asm'] = exports;\n    removeRunDependency('wasm-instantiate');\n  }\n   // we can't run yet (except in a pthread, where we have a custom sync instantiator)\n  addRunDependency('wasm-instantiate');\n\n\n  // Async compilation can be confusing when an error on the page overwrites Module\n  // (for example, if the order of elements is wrong, and the one defining Module is\n  // later), so we save Module and check it later.\n  var trueModule = Module;\n  function receiveInstantiatedSource(output) {\n    // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.\n    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\n    trueModule = null;\n      // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n      // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.\n    receiveInstance(output['instance']);\n  }\n\n\n  function instantiateArrayBuffer(receiver) {\n    return getBinaryPromise().then(function(binary) {\n      return WebAssembly.instantiate(binary, info);\n    }).then(receiver, function(reason) {\n      err('failed to asynchronously prepare wasm: ' + reason);\n      abort(reason);\n    });\n  }\n\n  // Prefer streaming instantiation if available.\n  function instantiateAsync() {\n    if (!wasmBinary &&\n        typeof WebAssembly.instantiateStreaming === 'function' &&\n        !isDataURI(wasmBinaryFile) &&\n        typeof fetch === 'function') {\n      fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) {\n        var result = WebAssembly.instantiateStreaming(response, info);\n        return result.then(receiveInstantiatedSource, function(reason) {\n            // We expect the most common failure cause to be a bad MIME type for the binary,\n            // in which case falling back to ArrayBuffer instantiation should work.\n            err('wasm streaming compile failed: ' + reason);\n            err('falling back to ArrayBuffer instantiation');\n            instantiateArrayBuffer(receiveInstantiatedSource);\n          });\n      });\n    } else {\n      return instantiateArrayBuffer(receiveInstantiatedSource);\n    }\n  }\n  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\n  // to any other async startup actions they are performing.\n  if (Module['instantiateWasm']) {\n    try {\n      var exports = Module['instantiateWasm'](info, receiveInstance);\n      return exports;\n    } catch(e) {\n      err('Module.instantiateWasm callback failed with error: ' + e);\n      return false;\n    }\n  }\n\n  instantiateAsync();\n  return {}; // no exports yet; we'll fill them in later\n}\n\n\n// Globals used by JS i64 conversions\nvar tempDouble;\nvar tempI64;\n\n// === Body ===\n\nvar ASM_CONSTS = {\n  23246: function($0, $1, $2) {Module.__pointers[$0]['_errorHandlerAdapter']($1, $2)},  \n 23300: function($0, $1) {Module.Logger.debug(Module.UTF8ToString($0, $1))},  \n 23349: function($0, $1) {Module.Logger.info(Module.UTF8ToString($0, $1))},  \n 23397: function($0, $1) {Module.Logger.error(Module.UTF8ToString($0, $1))},  \n 23446: function($0, $1) {Module.Logger.warn(Module.UTF8ToString($0, $1))},  \n 23494: function($0, $1) {Module.Logger.log(Module.UTF8ToString($0, $1))},  \n 23620: function($0, $1) {Module.__pointers[$0](Module.__pointers[$1])},  \n 23665: function($0) {delete Module.__pointers[$0]},  \n 23694: function() {Module.__pointers = {}}\n};\n\n// Avoid creating a new array\nvar _readAsmConstArgsArray = [];\n\nfunction readAsmConstArgs(sigPtr, buf) {\n  var args = _readAsmConstArgsArray;\n  args.length = 0;\n  var ch;\n  while (ch = HEAPU8[sigPtr++]) {\n    if (ch === 100/*'d'*/ || ch === 102/*'f'*/) {\n      buf = (buf + 7) & ~7;\n      args.push(HEAPF64[(buf >> 3)]);\n      buf += 8;\n    } else if (ch === 105 /*'i'*/) {\n      buf = (buf + 3) & ~3;\n      args.push(HEAP32[(buf >> 2)]);\n      buf += 4;\n    } else abort(\"unexpected char in asm const signature \" + ch);\n  }\n  return args;\n}\n\n\nfunction _emscripten_asm_const_iii(code, sigPtr, argbuf) {\n  var args = readAsmConstArgs(sigPtr, argbuf);\n  return ASM_CONSTS[code].apply(null, args);\n}\n\n\n\n// STATICTOP = STATIC_BASE + 47792;\n/* global initializers */  __ATINIT__.push({ func: function() { ___wasm_call_ctors() } });\n\n\n\n\n/* no memory initializer */\n// {{PRE_LIBRARY}}\n\n\n  function demangle(func) {\n      warnOnce('warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');\n      return func;\n    }\n\n  function demangleAll(text) {\n      var regex =\n        /\\b_Z[\\w\\d_]+/g;\n      return text.replace(regex,\n        function(x) {\n          var y = demangle(x);\n          return x === y ? x : (y + ' [' + x + ']');\n        });\n    }\n\n  function jsStackTrace() {\n      var err = new Error();\n      if (!err.stack) {\n        // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,\n        // so try that as a special-case.\n        try {\n          throw new Error(0);\n        } catch(e) {\n          err = e;\n        }\n        if (!err.stack) {\n          return '(no stack trace available)';\n        }\n      }\n      return err.stack.toString();\n    }\n\n  function stackTrace() {\n      var js = jsStackTrace();\n      if (Module['extraStackTrace']) js += '\\n' + Module['extraStackTrace']();\n      return demangleAll(js);\n    }\n\n  function ___assert_fail(condition, filename, line, func) {\n      abort('Assertion failed: ' + UTF8ToString(condition) + ', at: ' + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);\n    }\n\n  function ___handle_stack_overflow() {\n      abort('stack overflow')\n    }\n\n  function ___lock() {}\n\n  \n  function ___setErrNo(value) {\n      if (Module['___errno_location']) SAFE_HEAP_STORE(((Module['___errno_location']())|0), ((value)|0), 4);\n      else err('failed to set errno from JS');\n      return value;\n    }function ___map_file(pathname, size) {\n      ___setErrNo(63);\n      return -1;\n    }\n\n  \n  \n  var PATH={splitPath:function(filename) {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },normalizeArray:function(parts, allowAboveRoot) {\n        // if the path tries to go above the root, `up` ends up > 0\n        var up = 0;\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n          if (last === '.') {\n            parts.splice(i, 1);\n          } else if (last === '..') {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        }\n        // if the path is allowed to go above the root, restore leading ..s\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift('..');\n          }\n        }\n        return parts;\n      },normalize:function(path) {\n        var isAbsolute = path.charAt(0) === '/',\n            trailingSlash = path.substr(-1) === '/';\n        // Normalize the path\n        path = PATH.normalizeArray(path.split('/').filter(function(p) {\n          return !!p;\n        }), !isAbsolute).join('/');\n        if (!path && !isAbsolute) {\n          path = '.';\n        }\n        if (path && trailingSlash) {\n          path += '/';\n        }\n        return (isAbsolute ? '/' : '') + path;\n      },dirname:function(path) {\n        var result = PATH.splitPath(path),\n            root = result[0],\n            dir = result[1];\n        if (!root && !dir) {\n          // No dirname whatsoever\n          return '.';\n        }\n        if (dir) {\n          // It has a dirname, strip trailing slash\n          dir = dir.substr(0, dir.length - 1);\n        }\n        return root + dir;\n      },basename:function(path) {\n        // EMSCRIPTEN return '/'' for '/', not an empty string\n        if (path === '/') return '/';\n        var lastSlash = path.lastIndexOf('/');\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash+1);\n      },extname:function(path) {\n        return PATH.splitPath(path)[3];\n      },join:function() {\n        var paths = Array.prototype.slice.call(arguments, 0);\n        return PATH.normalize(paths.join('/'));\n      },join2:function(l, r) {\n        return PATH.normalize(l + '/' + r);\n      }};var SYSCALLS={buffers:[null,[],[]],printChar:function(stream, curr) {\n        var buffer = SYSCALLS.buffers[stream];\n        assert(buffer);\n        if (curr === 0 || curr === 10) {\n          (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n          buffer.length = 0;\n        } else {\n          buffer.push(curr);\n        }\n      },varargs:0,get:function(varargs) {\n        SYSCALLS.varargs += 4;\n        var ret = ((SAFE_HEAP_LOAD((((SYSCALLS.varargs)-(4))|0), 4, 0))|0);\n        return ret;\n      },getStr:function() {\n        var ret = UTF8ToString(SYSCALLS.get());\n        return ret;\n      },get64:function() {\n        var low = SYSCALLS.get(), high = SYSCALLS.get();\n        if (low >= 0) assert(high === 0);\n        else assert(high === -1);\n        return low;\n      },getZero:function() {\n        assert(SYSCALLS.get() === 0);\n      }};function ___syscall10(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // unlink\n      var path = SYSCALLS.getStr();\n      FS.unlink(path);\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall144(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // msync\n      var addr = SYSCALLS.get(), len = SYSCALLS.get(), flags = SYSCALLS.get();\n      var info = SYSCALLS.mappings[addr];\n      if (!info) return 0;\n      SYSCALLS.doMsync(addr, FS.getStream(info.fd), len, info.flags, 0);\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall148(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // fdatasync\n      var stream = SYSCALLS.getStreamFromFD();\n      return 0; // we can't do anything synchronously; the in-memory FS is already synced to\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall180(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // pread64\n      var stream = SYSCALLS.getStreamFromFD(), buf = SYSCALLS.get(), count = SYSCALLS.get(), zero = SYSCALLS.getZero(), offset = SYSCALLS.get64();\n      return FS.read(stream, HEAP8,buf, count, offset);\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall181(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // pwrite64\n      var stream = SYSCALLS.getStreamFromFD(), buf = SYSCALLS.get(), count = SYSCALLS.get(), zero = SYSCALLS.getZero(), offset = SYSCALLS.get64();\n      return FS.write(stream, HEAP8,buf, count, offset);\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall183(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // getcwd\n      var buf = SYSCALLS.get(), size = SYSCALLS.get();\n      if (size === 0) return -28;\n      var cwd = FS.cwd();\n      var cwdLengthInBytes = lengthBytesUTF8(cwd);\n      if (size < cwdLengthInBytes + 1) return -68;\n      stringToUTF8(cwd, buf, size);\n      return buf;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  \n  \n  \n  function _memset(ptr, value, num) {\n      ptr = ptr|0; value = value|0; num = num|0;\n      var end = 0, aligned_end = 0, block_aligned_end = 0, value4 = 0;\n      end = (ptr + num)|0;\n  \n      value = value & 0xff;\n      if ((num|0) >= 67 /* 64 bytes for an unrolled loop + 3 bytes for unaligned head*/) {\n        while ((ptr&3) != 0) {\n          SAFE_HEAP_STORE(((ptr)|0), ((value)|0), 1);\n          ptr = (ptr+1)|0;\n        }\n  \n        aligned_end = (end & -4)|0;\n        value4 = value | (value << 8) | (value << 16) | (value << 24);\n  \n        block_aligned_end = (aligned_end - 64)|0;\n  \n        while((ptr|0) <= (block_aligned_end|0)) {\n          SAFE_HEAP_STORE(((ptr)|0), ((value4)|0), 4);\n          SAFE_HEAP_STORE((((ptr)+(4))|0), ((value4)|0), 4);\n          SAFE_HEAP_STORE((((ptr)+(8))|0), ((value4)|0), 4);\n          SAFE_HEAP_STORE((((ptr)+(12))|0), ((value4)|0), 4);\n          SAFE_HEAP_STORE((((ptr)+(16))|0), ((value4)|0), 4);\n          SAFE_HEAP_STORE((((ptr)+(20))|0), ((value4)|0), 4);\n          SAFE_HEAP_STORE((((ptr)+(24))|0), ((value4)|0), 4);\n          SAFE_HEAP_STORE((((ptr)+(28))|0), ((value4)|0), 4);\n          SAFE_HEAP_STORE((((ptr)+(32))|0), ((value4)|0), 4);\n          SAFE_HEAP_STORE((((ptr)+(36))|0), ((value4)|0), 4);\n          SAFE_HEAP_STORE((((ptr)+(40))|0), ((value4)|0), 4);\n          SAFE_HEAP_STORE((((ptr)+(44))|0), ((value4)|0), 4);\n          SAFE_HEAP_STORE((((ptr)+(48))|0), ((value4)|0), 4);\n          SAFE_HEAP_STORE((((ptr)+(52))|0), ((value4)|0), 4);\n          SAFE_HEAP_STORE((((ptr)+(56))|0), ((value4)|0), 4);\n          SAFE_HEAP_STORE((((ptr)+(60))|0), ((value4)|0), 4);\n          ptr = (ptr + 64)|0;\n        }\n  \n        while ((ptr|0) < (aligned_end|0) ) {\n          SAFE_HEAP_STORE(((ptr)|0), ((value4)|0), 4);\n          ptr = (ptr+4)|0;\n        }\n      }\n      // The remaining bytes.\n      while ((ptr|0) < (end|0)) {\n        SAFE_HEAP_STORE(((ptr)|0), ((value)|0), 1);\n        ptr = (ptr+1)|0;\n      }\n      return (end-num)|0;\n    }function __emscripten_syscall_mmap2(addr, len, prot, flags, fd, off) {\n      off <<= 12; // undo pgoffset\n      var ptr;\n      var allocated = false;\n  \n      // addr argument must be page aligned if MAP_FIXED flag is set.\n      if ((flags & 16) !== 0 && (addr % PAGE_SIZE) !== 0) {\n        return -28;\n      }\n  \n      // MAP_ANONYMOUS (aka MAP_ANON) isn't actually defined by POSIX spec,\n      // but it is widely used way to allocate memory pages on Linux, BSD and Mac.\n      // In this case fd argument is ignored.\n      if ((flags & 32) !== 0) {\n        ptr = _memalign(PAGE_SIZE, len);\n        if (!ptr) return -48;\n        _memset(ptr, 0, len);\n        allocated = true;\n      } else {\n        var info = FS.getStream(fd);\n        if (!info) return -8;\n        var res = FS.mmap(info, HEAPU8, addr, len, off, prot, flags);\n        ptr = res.ptr;\n        allocated = res.allocated;\n      }\n      SYSCALLS.mappings[ptr] = { malloc: ptr, len: len, allocated: allocated, fd: fd, flags: flags, offset: off };\n      return ptr;\n    }function ___syscall192(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // mmap2\n      var addr = SYSCALLS.get(), len = SYSCALLS.get(), prot = SYSCALLS.get(), flags = SYSCALLS.get(), fd = SYSCALLS.get(), off = SYSCALLS.get()\n      return __emscripten_syscall_mmap2(addr, len, prot, flags, fd, off);\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall194(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // ftruncate64\n      var fd = SYSCALLS.get(), zero = SYSCALLS.getZero(), length = SYSCALLS.get64();\n      FS.ftruncate(fd, length);\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall195(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // SYS_stat64\n      var path = SYSCALLS.getStr(), buf = SYSCALLS.get();\n      return SYSCALLS.doStat(FS.stat, path, buf);\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  \n  var PROCINFO={ppid:1,pid:42,sid:42,pgid:42};function ___syscall20(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // getpid\n      return PROCINFO.pid;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall219(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // madvise\n      return 0; // advice is welcome, but ignored\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall220(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // SYS_getdents64\n      var stream = SYSCALLS.getStreamFromFD(), dirp = SYSCALLS.get(), count = SYSCALLS.get();\n      if (!stream.getdents) {\n        stream.getdents = FS.readdir(stream.path);\n      }\n  \n      var struct_size = 280;\n      var pos = 0;\n      var off = FS.llseek(stream, 0, 1);\n  \n      var idx = Math.floor(off / struct_size);\n  \n      while (idx < stream.getdents.length && pos + struct_size <= count) {\n        var id;\n        var type;\n        var name = stream.getdents[idx];\n        if (name[0] === '.') {\n          id = 1;\n          type = 4; // DT_DIR\n        } else {\n          var child = FS.lookupNode(stream.node, name);\n          id = child.id;\n          type = FS.isChrdev(child.mode) ? 2 :  // DT_CHR, character device.\n                 FS.isDir(child.mode) ? 4 :     // DT_DIR, directory.\n                 FS.isLink(child.mode) ? 10 :   // DT_LNK, symbolic link.\n                 8;                             // DT_REG, regular file.\n        }\n        (tempI64 = [id>>>0,(tempDouble=id,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],SAFE_HEAP_STORE(((dirp + pos)|0), ((tempI64[0])|0), 4),SAFE_HEAP_STORE((((dirp + pos)+(4))|0), ((tempI64[1])|0), 4));\n        (tempI64 = [(idx + 1) * struct_size>>>0,(tempDouble=(idx + 1) * struct_size,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],SAFE_HEAP_STORE((((dirp + pos)+(8))|0), ((tempI64[0])|0), 4),SAFE_HEAP_STORE((((dirp + pos)+(12))|0), ((tempI64[1])|0), 4));\n        SAFE_HEAP_STORE((((dirp + pos)+(16))|0), ((280)|0), 2);\n        SAFE_HEAP_STORE((((dirp + pos)+(18))|0), ((type)|0), 1);\n        stringToUTF8(name, dirp + pos + 19, 256);\n        pos += struct_size;\n        idx += 1;\n      }\n      FS.llseek(stream, idx * struct_size, 0);\n      return pos;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall221(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // fcntl64\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall40(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // rmdir\n      var path = SYSCALLS.getStr();\n      FS.rmdir(path);\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall5(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // open\n      var pathname = SYSCALLS.getStr(), flags = SYSCALLS.get(), mode = SYSCALLS.get(); // optional TODO\n      var stream = FS.open(pathname, flags, mode);\n      return stream.fd;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___syscall54(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // ioctl\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  \n  function __emscripten_syscall_munmap(addr, len) {\n      if (addr === -1 || len === 0) {\n        return -28;\n      }\n      // TODO: support unmmap'ing parts of allocations\n      var info = SYSCALLS.mappings[addr];\n      if (!info) return 0;\n      if (len === info.len) {\n        var stream = FS.getStream(info.fd);\n        SYSCALLS.doMsync(addr, stream, len, info.flags, info.offset);\n        FS.munmap(stream);\n        SYSCALLS.mappings[addr] = null;\n        if (info.allocated) {\n          _free(info.malloc);\n        }\n      }\n      return 0;\n    }function ___syscall91(which, varargs) {SYSCALLS.varargs = varargs;\n  try {\n   // munmap\n      var addr = SYSCALLS.get(), len = SYSCALLS.get();\n      return __emscripten_syscall_munmap(addr, len);\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return -e.errno;\n  }\n  }\n\n  function ___unlock() {}\n\n  function _abort() {\n      abort();\n    }\n\n  var _abs=Math_abs;\n\n  \n  var ___tm_formatted=48736;\n  \n  \n  function _tzset() {\n      // TODO: Use (malleable) environment variables instead of system settings.\n      if (_tzset.called) return;\n      _tzset.called = true;\n  \n      // timezone is specified as seconds west of UTC (\"The external variable\n      // `timezone` shall be set to the difference, in seconds, between\n      // Coordinated Universal Time (UTC) and local standard time.\"), the same\n      // as returned by getTimezoneOffset().\n      // See http://pubs.opengroup.org/onlinepubs/009695399/functions/tzset.html\n      SAFE_HEAP_STORE(((__get_timezone())|0), (((new Date()).getTimezoneOffset() * 60)|0), 4);\n  \n      var currentYear = new Date().getFullYear();\n      var winter = new Date(currentYear, 0, 1);\n      var summer = new Date(currentYear, 6, 1);\n      SAFE_HEAP_STORE(((__get_daylight())|0), ((Number(winter.getTimezoneOffset() != summer.getTimezoneOffset()))|0), 4);\n  \n      function extractZone(date) {\n        var match = date.toTimeString().match(/\\(([A-Za-z ]+)\\)$/);\n        return match ? match[1] : \"GMT\";\n      };\n      var winterName = extractZone(winter);\n      var summerName = extractZone(summer);\n      var winterNamePtr = allocate(intArrayFromString(winterName), 'i8', ALLOC_NORMAL);\n      var summerNamePtr = allocate(intArrayFromString(summerName), 'i8', ALLOC_NORMAL);\n      if (summer.getTimezoneOffset() < winter.getTimezoneOffset()) {\n        // Northern hemisphere\n        SAFE_HEAP_STORE(((__get_tzname())|0), ((winterNamePtr)|0), 4);\n        SAFE_HEAP_STORE((((__get_tzname())+(4))|0), ((summerNamePtr)|0), 4);\n      } else {\n        SAFE_HEAP_STORE(((__get_tzname())|0), ((summerNamePtr)|0), 4);\n        SAFE_HEAP_STORE((((__get_tzname())+(4))|0), ((winterNamePtr)|0), 4);\n      }\n    }function _mktime(tmPtr) {\n      _tzset();\n      var date = new Date(((SAFE_HEAP_LOAD((((tmPtr)+(20))|0), 4, 0))|0) + 1900,\n                          ((SAFE_HEAP_LOAD((((tmPtr)+(16))|0), 4, 0))|0),\n                          ((SAFE_HEAP_LOAD((((tmPtr)+(12))|0), 4, 0))|0),\n                          ((SAFE_HEAP_LOAD((((tmPtr)+(8))|0), 4, 0))|0),\n                          ((SAFE_HEAP_LOAD((((tmPtr)+(4))|0), 4, 0))|0),\n                          ((SAFE_HEAP_LOAD(((tmPtr)|0), 4, 0))|0),\n                          0);\n  \n      // There's an ambiguous hour when the time goes back; the tm_isdst field is\n      // used to disambiguate it.  Date() basically guesses, so we fix it up if it\n      // guessed wrong, or fill in tm_isdst with the guess if it's -1.\n      var dst = ((SAFE_HEAP_LOAD((((tmPtr)+(32))|0), 4, 0))|0);\n      var guessedOffset = date.getTimezoneOffset();\n      var start = new Date(date.getFullYear(), 0, 1);\n      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();\n      var winterOffset = start.getTimezoneOffset();\n      var dstOffset = Math.min(winterOffset, summerOffset); // DST is in December in South\n      if (dst < 0) {\n        // Attention: some regions don't have DST at all.\n        SAFE_HEAP_STORE((((tmPtr)+(32))|0), ((Number(summerOffset != winterOffset && dstOffset == guessedOffset))|0), 4);\n      } else if ((dst > 0) != (dstOffset == guessedOffset)) {\n        var nonDstOffset = Math.max(winterOffset, summerOffset);\n        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;\n        // Don't try setMinutes(date.getMinutes() + ...) -- it's messed up.\n        date.setTime(date.getTime() + (trueOffset - guessedOffset)*60000);\n      }\n  \n      SAFE_HEAP_STORE((((tmPtr)+(24))|0), ((date.getDay())|0), 4);\n      var yday = ((date.getTime() - start.getTime()) / (1000 * 60 * 60 * 24))|0;\n      SAFE_HEAP_STORE((((tmPtr)+(28))|0), ((yday)|0), 4);\n  \n      return (date.getTime() / 1000)|0;\n    }function _asctime_r(tmPtr, buf) {\n      var date = {\n        tm_sec: ((SAFE_HEAP_LOAD(((tmPtr)|0), 4, 0))|0),\n        tm_min: ((SAFE_HEAP_LOAD((((tmPtr)+(4))|0), 4, 0))|0),\n        tm_hour: ((SAFE_HEAP_LOAD((((tmPtr)+(8))|0), 4, 0))|0),\n        tm_mday: ((SAFE_HEAP_LOAD((((tmPtr)+(12))|0), 4, 0))|0),\n        tm_mon: ((SAFE_HEAP_LOAD((((tmPtr)+(16))|0), 4, 0))|0),\n        tm_year: ((SAFE_HEAP_LOAD((((tmPtr)+(20))|0), 4, 0))|0),\n        tm_wday: ((SAFE_HEAP_LOAD((((tmPtr)+(24))|0), 4, 0))|0)\n      };\n      var days = [ \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\" ];\n      var months = [ \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                     \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" ];\n      var s = days[date.tm_wday] + ' ' + months[date.tm_mon] +\n          (date.tm_mday < 10 ? '  ' : ' ') + date.tm_mday +\n          (date.tm_hour < 10 ? ' 0' : ' ') + date.tm_hour +\n          (date.tm_min < 10 ? ':0' : ':') + date.tm_min +\n          (date.tm_sec < 10 ? ':0' : ':') + date.tm_sec +\n          ' ' + (1900 + date.tm_year) + \"\\n\";\n  \n      // asctime_r is specced to behave in an undefined manner if the algorithm would attempt\n      // to write out more than 26 bytes (including the null terminator).\n      // See http://pubs.opengroup.org/onlinepubs/9699919799/functions/asctime.html\n      // Our undefined behavior is to truncate the write to at most 26 bytes, including null terminator.\n      stringToUTF8(s, buf, 26);\n      return buf;\n    }\n\n  \n  \n  \n  function _emscripten_set_main_loop_timing(mode, value) {\n      Browser.mainLoop.timingMode = mode;\n      Browser.mainLoop.timingValue = value;\n  \n      if (!Browser.mainLoop.func) {\n        console.error('emscripten_set_main_loop_timing: Cannot set timing mode for main loop since a main loop does not exist! Call emscripten_set_main_loop first to set one up.');\n        return 1; // Return non-zero on failure, can't set timing mode when there is no main loop.\n      }\n  \n      if (mode == 0 /*EM_TIMING_SETTIMEOUT*/) {\n        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setTimeout() {\n          var timeUntilNextTick = Math.max(0, Browser.mainLoop.tickStartTime + value - _emscripten_get_now())|0;\n          setTimeout(Browser.mainLoop.runner, timeUntilNextTick); // doing this each time means that on exception, we stop\n        };\n        Browser.mainLoop.method = 'timeout';\n      } else if (mode == 1 /*EM_TIMING_RAF*/) {\n        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_rAF() {\n          Browser.requestAnimationFrame(Browser.mainLoop.runner);\n        };\n        Browser.mainLoop.method = 'rAF';\n      } else if (mode == 2 /*EM_TIMING_SETIMMEDIATE*/) {\n        if (typeof setImmediate === 'undefined') {\n          // Emulate setImmediate. (note: not a complete polyfill, we don't emulate clearImmediate() to keep code size to minimum, since not needed)\n          var setImmediates = [];\n          var emscriptenMainLoopMessageId = 'setimmediate';\n          var Browser_setImmediate_messageHandler = function(event) {\n            // When called in current thread or Worker, the main loop ID is structured slightly different to accommodate for --proxy-to-worker runtime listening to Worker events,\n            // so check for both cases.\n            if (event.data === emscriptenMainLoopMessageId || event.data.target === emscriptenMainLoopMessageId) {\n              event.stopPropagation();\n              setImmediates.shift()();\n            }\n          }\n          addEventListener(\"message\", Browser_setImmediate_messageHandler, true);\n          setImmediate = function Browser_emulated_setImmediate(func) {\n            setImmediates.push(func);\n            if (ENVIRONMENT_IS_WORKER) {\n              if (Module['setImmediates'] === undefined) Module['setImmediates'] = [];\n              Module['setImmediates'].push(func);\n              postMessage({target: emscriptenMainLoopMessageId}); // In --proxy-to-worker, route the message via proxyClient.js\n            } else postMessage(emscriptenMainLoopMessageId, \"*\"); // On the main thread, can just send the message to itself.\n          }\n        }\n        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setImmediate() {\n          setImmediate(Browser.mainLoop.runner);\n        };\n        Browser.mainLoop.method = 'immediate';\n      }\n      return 0;\n    }\n  \n  function _emscripten_get_now() { abort() }function _emscripten_set_main_loop(func, fps, simulateInfiniteLoop, arg, noSetTiming) {\n      noExitRuntime = true;\n  \n      assert(!Browser.mainLoop.func, 'emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters.');\n  \n      Browser.mainLoop.func = func;\n      Browser.mainLoop.arg = arg;\n  \n      var browserIterationFunc;\n      if (typeof arg !== 'undefined') {\n        browserIterationFunc = function() {\n          Module['dynCall_vi'](func, arg);\n        };\n      } else {\n        browserIterationFunc = function() {\n          Module['dynCall_v'](func);\n        };\n      }\n  \n      var thisMainLoopId = Browser.mainLoop.currentlyRunningMainloop;\n  \n      Browser.mainLoop.runner = function Browser_mainLoop_runner() {\n        if (ABORT) return;\n        if (Browser.mainLoop.queue.length > 0) {\n          var start = Date.now();\n          var blocker = Browser.mainLoop.queue.shift();\n          blocker.func(blocker.arg);\n          if (Browser.mainLoop.remainingBlockers) {\n            var remaining = Browser.mainLoop.remainingBlockers;\n            var next = remaining%1 == 0 ? remaining-1 : Math.floor(remaining);\n            if (blocker.counted) {\n              Browser.mainLoop.remainingBlockers = next;\n            } else {\n              // not counted, but move the progress along a tiny bit\n              next = next + 0.5; // do not steal all the next one's progress\n              Browser.mainLoop.remainingBlockers = (8*remaining + next)/9;\n            }\n          }\n          console.log('main loop blocker \"' + blocker.name + '\" took ' + (Date.now() - start) + ' ms'); //, left: ' + Browser.mainLoop.remainingBlockers);\n          Browser.mainLoop.updateStatus();\n  \n          // catches pause/resume main loop from blocker execution\n          if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) return;\n  \n          setTimeout(Browser.mainLoop.runner, 0);\n          return;\n        }\n  \n        // catch pauses from non-main loop sources\n        if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) return;\n  \n        // Implement very basic swap interval control\n        Browser.mainLoop.currentFrameNumber = Browser.mainLoop.currentFrameNumber + 1 | 0;\n        if (Browser.mainLoop.timingMode == 1/*EM_TIMING_RAF*/ && Browser.mainLoop.timingValue > 1 && Browser.mainLoop.currentFrameNumber % Browser.mainLoop.timingValue != 0) {\n          // Not the scheduled time to render this frame - skip.\n          Browser.mainLoop.scheduler();\n          return;\n        } else if (Browser.mainLoop.timingMode == 0/*EM_TIMING_SETTIMEOUT*/) {\n          Browser.mainLoop.tickStartTime = _emscripten_get_now();\n        }\n  \n        // Signal GL rendering layer that processing of a new frame is about to start. This helps it optimize\n        // VBO double-buffering and reduce GPU stalls.\n  \n  \n  \n        if (Browser.mainLoop.method === 'timeout' && Module.ctx) {\n          warnOnce('Looks like you are rendering without using requestAnimationFrame for the main loop. You should use 0 for the frame rate in emscripten_set_main_loop in order to use requestAnimationFrame, as that can greatly improve your frame rates!');\n          Browser.mainLoop.method = ''; // just warn once per call to set main loop\n        }\n  \n        Browser.mainLoop.runIter(browserIterationFunc);\n  \n        checkStackCookie();\n  \n        // catch pauses from the main loop itself\n        if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) return;\n  \n        // Queue new audio data. This is important to be right after the main loop invocation, so that we will immediately be able\n        // to queue the newest produced audio samples.\n        // TODO: Consider adding pre- and post- rAF callbacks so that GL.newRenderingFrameStarted() and SDL.audio.queueNewAudioData()\n        //       do not need to be hardcoded into this function, but can be more generic.\n        if (typeof SDL === 'object' && SDL.audio && SDL.audio.queueNewAudioData) SDL.audio.queueNewAudioData();\n  \n        Browser.mainLoop.scheduler();\n      }\n  \n      if (!noSetTiming) {\n        if (fps && fps > 0) _emscripten_set_main_loop_timing(0/*EM_TIMING_SETTIMEOUT*/, 1000.0 / fps);\n        else _emscripten_set_main_loop_timing(1/*EM_TIMING_RAF*/, 1); // Do rAF by rendering each frame (no decimating)\n  \n        Browser.mainLoop.scheduler();\n      }\n  \n      if (simulateInfiniteLoop) {\n        throw 'unwind';\n      }\n    }var Browser={mainLoop:{scheduler:null,method:\"\",currentlyRunningMainloop:0,func:null,arg:0,timingMode:0,timingValue:0,currentFrameNumber:0,queue:[],pause:function() {\n          Browser.mainLoop.scheduler = null;\n          Browser.mainLoop.currentlyRunningMainloop++; // Incrementing this signals the previous main loop that it's now become old, and it must return.\n        },resume:function() {\n          Browser.mainLoop.currentlyRunningMainloop++;\n          var timingMode = Browser.mainLoop.timingMode;\n          var timingValue = Browser.mainLoop.timingValue;\n          var func = Browser.mainLoop.func;\n          Browser.mainLoop.func = null;\n          _emscripten_set_main_loop(func, 0, false, Browser.mainLoop.arg, true /* do not set timing and call scheduler, we will do it on the next lines */);\n          _emscripten_set_main_loop_timing(timingMode, timingValue);\n          Browser.mainLoop.scheduler();\n        },updateStatus:function() {\n          if (Module['setStatus']) {\n            var message = Module['statusMessage'] || 'Please wait...';\n            var remaining = Browser.mainLoop.remainingBlockers;\n            var expected = Browser.mainLoop.expectedBlockers;\n            if (remaining) {\n              if (remaining < expected) {\n                Module['setStatus'](message + ' (' + (expected - remaining) + '/' + expected + ')');\n              } else {\n                Module['setStatus'](message);\n              }\n            } else {\n              Module['setStatus']('');\n            }\n          }\n        },runIter:function(func) {\n          if (ABORT) return;\n          if (Module['preMainLoop']) {\n            var preRet = Module['preMainLoop']();\n            if (preRet === false) {\n              return; // |return false| skips a frame\n            }\n          }\n          try {\n            func();\n          } catch (e) {\n            if (e instanceof ExitStatus) {\n              return;\n            } else {\n              if (e && typeof e === 'object' && e.stack) err('exception thrown: ' + [e, e.stack]);\n              throw e;\n            }\n          }\n          if (Module['postMainLoop']) Module['postMainLoop']();\n        }},isFullscreen:false,pointerLock:false,moduleContextCreatedCallbacks:[],workers:[],init:function() {\n        if (!Module[\"preloadPlugins\"]) Module[\"preloadPlugins\"] = []; // needs to exist even in workers\n  \n        if (Browser.initted) return;\n        Browser.initted = true;\n  \n        try {\n          new Blob();\n          Browser.hasBlobConstructor = true;\n        } catch(e) {\n          Browser.hasBlobConstructor = false;\n          console.log(\"warning: no blob constructor, cannot create blobs with mimetypes\");\n        }\n        Browser.BlobBuilder = typeof MozBlobBuilder != \"undefined\" ? MozBlobBuilder : (typeof WebKitBlobBuilder != \"undefined\" ? WebKitBlobBuilder : (!Browser.hasBlobConstructor ? console.log(\"warning: no BlobBuilder\") : null));\n        Browser.URLObject = typeof window != \"undefined\" ? (window.URL ? window.URL : window.webkitURL) : undefined;\n        if (!Module.noImageDecoding && typeof Browser.URLObject === 'undefined') {\n          console.log(\"warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available.\");\n          Module.noImageDecoding = true;\n        }\n  \n        // Support for plugins that can process preloaded files. You can add more of these to\n        // your app by creating and appending to Module.preloadPlugins.\n        //\n        // Each plugin is asked if it can handle a file based on the file's name. If it can,\n        // it is given the file's raw data. When it is done, it calls a callback with the file's\n        // (possibly modified) data. For example, a plugin might decompress a file, or it\n        // might create some side data structure for use later (like an Image element, etc.).\n  \n        var imagePlugin = {};\n        imagePlugin['canHandle'] = function imagePlugin_canHandle(name) {\n          return !Module.noImageDecoding && /\\.(jpg|jpeg|png|bmp)$/i.test(name);\n        };\n        imagePlugin['handle'] = function imagePlugin_handle(byteArray, name, onload, onerror) {\n          var b = null;\n          if (Browser.hasBlobConstructor) {\n            try {\n              b = new Blob([byteArray], { type: Browser.getMimetype(name) });\n              if (b.size !== byteArray.length) { // Safari bug #118630\n                // Safari's Blob can only take an ArrayBuffer\n                b = new Blob([(new Uint8Array(byteArray)).buffer], { type: Browser.getMimetype(name) });\n              }\n            } catch(e) {\n              warnOnce('Blob constructor present but fails: ' + e + '; falling back to blob builder');\n            }\n          }\n          if (!b) {\n            var bb = new Browser.BlobBuilder();\n            bb.append((new Uint8Array(byteArray)).buffer); // we need to pass a buffer, and must copy the array to get the right data range\n            b = bb.getBlob();\n          }\n          var url = Browser.URLObject.createObjectURL(b);\n          assert(typeof url == 'string', 'createObjectURL must return a url as a string');\n          var img = new Image();\n          img.onload = function img_onload() {\n            assert(img.complete, 'Image ' + name + ' could not be decoded');\n            var canvas = document.createElement('canvas');\n            canvas.width = img.width;\n            canvas.height = img.height;\n            var ctx = canvas.getContext('2d');\n            ctx.drawImage(img, 0, 0);\n            Module[\"preloadedImages\"][name] = canvas;\n            Browser.URLObject.revokeObjectURL(url);\n            if (onload) onload(byteArray);\n          };\n          img.onerror = function img_onerror(event) {\n            console.log('Image ' + url + ' could not be decoded');\n            if (onerror) onerror();\n          };\n          img.src = url;\n        };\n        Module['preloadPlugins'].push(imagePlugin);\n  \n        var audioPlugin = {};\n        audioPlugin['canHandle'] = function audioPlugin_canHandle(name) {\n          return !Module.noAudioDecoding && name.substr(-4) in { '.ogg': 1, '.wav': 1, '.mp3': 1 };\n        };\n        audioPlugin['handle'] = function audioPlugin_handle(byteArray, name, onload, onerror) {\n          var done = false;\n          function finish(audio) {\n            if (done) return;\n            done = true;\n            Module[\"preloadedAudios\"][name] = audio;\n            if (onload) onload(byteArray);\n          }\n          function fail() {\n            if (done) return;\n            done = true;\n            Module[\"preloadedAudios\"][name] = new Audio(); // empty shim\n            if (onerror) onerror();\n          }\n          if (Browser.hasBlobConstructor) {\n            try {\n              var b = new Blob([byteArray], { type: Browser.getMimetype(name) });\n            } catch(e) {\n              return fail();\n            }\n            var url = Browser.URLObject.createObjectURL(b); // XXX we never revoke this!\n            assert(typeof url == 'string', 'createObjectURL must return a url as a string');\n            var audio = new Audio();\n            audio.addEventListener('canplaythrough', function() { finish(audio) }, false); // use addEventListener due to chromium bug 124926\n            audio.onerror = function audio_onerror(event) {\n              if (done) return;\n              console.log('warning: browser could not fully decode audio ' + name + ', trying slower base64 approach');\n              function encode64(data) {\n                var BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n                var PAD = '=';\n                var ret = '';\n                var leftchar = 0;\n                var leftbits = 0;\n                for (var i = 0; i < data.length; i++) {\n                  leftchar = (leftchar << 8) | data[i];\n                  leftbits += 8;\n                  while (leftbits >= 6) {\n                    var curr = (leftchar >> (leftbits-6)) & 0x3f;\n                    leftbits -= 6;\n                    ret += BASE[curr];\n                  }\n                }\n                if (leftbits == 2) {\n                  ret += BASE[(leftchar&3) << 4];\n                  ret += PAD + PAD;\n                } else if (leftbits == 4) {\n                  ret += BASE[(leftchar&0xf) << 2];\n                  ret += PAD;\n                }\n                return ret;\n              }\n              audio.src = 'data:audio/x-' + name.substr(-3) + ';base64,' + encode64(byteArray);\n              finish(audio); // we don't wait for confirmation this worked - but it's worth trying\n            };\n            audio.src = url;\n            // workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror\n            Browser.safeSetTimeout(function() {\n              finish(audio); // try to use it even though it is not necessarily ready to play\n            }, 10000);\n          } else {\n            return fail();\n          }\n        };\n        Module['preloadPlugins'].push(audioPlugin);\n  \n  \n        // Canvas event setup\n  \n        function pointerLockChange() {\n          Browser.pointerLock = document['pointerLockElement'] === Module['canvas'] ||\n                                document['mozPointerLockElement'] === Module['canvas'] ||\n                                document['webkitPointerLockElement'] === Module['canvas'] ||\n                                document['msPointerLockElement'] === Module['canvas'];\n        }\n        var canvas = Module['canvas'];\n        if (canvas) {\n          // forced aspect ratio can be enabled by defining 'forcedAspectRatio' on Module\n          // Module['forcedAspectRatio'] = 4 / 3;\n  \n          canvas.requestPointerLock = canvas['requestPointerLock'] ||\n                                      canvas['mozRequestPointerLock'] ||\n                                      canvas['webkitRequestPointerLock'] ||\n                                      canvas['msRequestPointerLock'] ||\n                                      function(){};\n          canvas.exitPointerLock = document['exitPointerLock'] ||\n                                   document['mozExitPointerLock'] ||\n                                   document['webkitExitPointerLock'] ||\n                                   document['msExitPointerLock'] ||\n                                   function(){}; // no-op if function does not exist\n          canvas.exitPointerLock = canvas.exitPointerLock.bind(document);\n  \n          document.addEventListener('pointerlockchange', pointerLockChange, false);\n          document.addEventListener('mozpointerlockchange', pointerLockChange, false);\n          document.addEventListener('webkitpointerlockchange', pointerLockChange, false);\n          document.addEventListener('mspointerlockchange', pointerLockChange, false);\n  \n          if (Module['elementPointerLock']) {\n            canvas.addEventListener(\"click\", function(ev) {\n              if (!Browser.pointerLock && Module['canvas'].requestPointerLock) {\n                Module['canvas'].requestPointerLock();\n                ev.preventDefault();\n              }\n            }, false);\n          }\n        }\n      },createContext:function(canvas, useWebGL, setInModule, webGLContextAttributes) {\n        if (useWebGL && Module.ctx && canvas == Module.canvas) return Module.ctx; // no need to recreate GL context if it's already been created for this canvas.\n  \n        var ctx;\n        var contextHandle;\n        if (useWebGL) {\n          // For GLES2/desktop GL compatibility, adjust a few defaults to be different to WebGL defaults, so that they align better with the desktop defaults.\n          var contextAttributes = {\n            antialias: false,\n            alpha: false,\n            majorVersion: 1,\n          };\n  \n          if (webGLContextAttributes) {\n            for (var attribute in webGLContextAttributes) {\n              contextAttributes[attribute] = webGLContextAttributes[attribute];\n            }\n          }\n  \n          // This check of existence of GL is here to satisfy Closure compiler, which yells if variable GL is referenced below but GL object is not\n          // actually compiled in because application is not doing any GL operations. TODO: Ideally if GL is not being used, this function\n          // Browser.createContext() should not even be emitted.\n          if (typeof GL !== 'undefined') {\n            contextHandle = GL.createContext(canvas, contextAttributes);\n            if (contextHandle) {\n              ctx = GL.getContext(contextHandle).GLctx;\n            }\n          }\n        } else {\n          ctx = canvas.getContext('2d');\n        }\n  \n        if (!ctx) return null;\n  \n        if (setInModule) {\n          if (!useWebGL) assert(typeof GLctx === 'undefined', 'cannot set in module if GLctx is used, but we are a non-GL context that would replace it');\n  \n          Module.ctx = ctx;\n          if (useWebGL) GL.makeContextCurrent(contextHandle);\n          Module.useWebGL = useWebGL;\n          Browser.moduleContextCreatedCallbacks.forEach(function(callback) { callback() });\n          Browser.init();\n        }\n        return ctx;\n      },destroyContext:function(canvas, useWebGL, setInModule) {},fullscreenHandlersInstalled:false,lockPointer:undefined,resizeCanvas:undefined,requestFullscreen:function(lockPointer, resizeCanvas, vrDevice) {\n        Browser.lockPointer = lockPointer;\n        Browser.resizeCanvas = resizeCanvas;\n        Browser.vrDevice = vrDevice;\n        if (typeof Browser.lockPointer === 'undefined') Browser.lockPointer = true;\n        if (typeof Browser.resizeCanvas === 'undefined') Browser.resizeCanvas = false;\n        if (typeof Browser.vrDevice === 'undefined') Browser.vrDevice = null;\n  \n        var canvas = Module['canvas'];\n        function fullscreenChange() {\n          Browser.isFullscreen = false;\n          var canvasContainer = canvas.parentNode;\n          if ((document['fullscreenElement'] || document['mozFullScreenElement'] ||\n               document['msFullscreenElement'] || document['webkitFullscreenElement'] ||\n               document['webkitCurrentFullScreenElement']) === canvasContainer) {\n            canvas.exitFullscreen = Browser.exitFullscreen;\n            if (Browser.lockPointer) canvas.requestPointerLock();\n            Browser.isFullscreen = true;\n            if (Browser.resizeCanvas) {\n              Browser.setFullscreenCanvasSize();\n            } else {\n              Browser.updateCanvasDimensions(canvas);\n            }\n          } else {\n            // remove the full screen specific parent of the canvas again to restore the HTML structure from before going full screen\n            canvasContainer.parentNode.insertBefore(canvas, canvasContainer);\n            canvasContainer.parentNode.removeChild(canvasContainer);\n  \n            if (Browser.resizeCanvas) {\n              Browser.setWindowedCanvasSize();\n            } else {\n              Browser.updateCanvasDimensions(canvas);\n            }\n          }\n          if (Module['onFullScreen']) Module['onFullScreen'](Browser.isFullscreen);\n          if (Module['onFullscreen']) Module['onFullscreen'](Browser.isFullscreen);\n        }\n  \n        if (!Browser.fullscreenHandlersInstalled) {\n          Browser.fullscreenHandlersInstalled = true;\n          document.addEventListener('fullscreenchange', fullscreenChange, false);\n          document.addEventListener('mozfullscreenchange', fullscreenChange, false);\n          document.addEventListener('webkitfullscreenchange', fullscreenChange, false);\n          document.addEventListener('MSFullscreenChange', fullscreenChange, false);\n        }\n  \n        // create a new parent to ensure the canvas has no siblings. this allows browsers to optimize full screen performance when its parent is the full screen root\n        var canvasContainer = document.createElement(\"div\");\n        canvas.parentNode.insertBefore(canvasContainer, canvas);\n        canvasContainer.appendChild(canvas);\n  \n        // use parent of canvas as full screen root to allow aspect ratio correction (Firefox stretches the root to screen size)\n        canvasContainer.requestFullscreen = canvasContainer['requestFullscreen'] ||\n                                            canvasContainer['mozRequestFullScreen'] ||\n                                            canvasContainer['msRequestFullscreen'] ||\n                                           (canvasContainer['webkitRequestFullscreen'] ? function() { canvasContainer['webkitRequestFullscreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null) ||\n                                           (canvasContainer['webkitRequestFullScreen'] ? function() { canvasContainer['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null);\n  \n        if (vrDevice) {\n          canvasContainer.requestFullscreen({ vrDisplay: vrDevice });\n        } else {\n          canvasContainer.requestFullscreen();\n        }\n      },requestFullScreen:function() {\n        abort('Module.requestFullScreen has been replaced by Module.requestFullscreen (without a capital S)');\n      },exitFullscreen:function() {\n        // This is workaround for chrome. Trying to exit from fullscreen\n        // not in fullscreen state will cause \"TypeError: Document not active\"\n        // in chrome. See https://github.com/emscripten-core/emscripten/pull/8236\n        if (!Browser.isFullscreen) {\n          return false;\n        }\n  \n        var CFS = document['exitFullscreen'] ||\n                  document['cancelFullScreen'] ||\n                  document['mozCancelFullScreen'] ||\n                  document['msExitFullscreen'] ||\n                  document['webkitCancelFullScreen'] ||\n            (function() {});\n        CFS.apply(document, []);\n        return true;\n      },nextRAF:0,fakeRequestAnimationFrame:function(func) {\n        // try to keep 60fps between calls to here\n        var now = Date.now();\n        if (Browser.nextRAF === 0) {\n          Browser.nextRAF = now + 1000/60;\n        } else {\n          while (now + 2 >= Browser.nextRAF) { // fudge a little, to avoid timer jitter causing us to do lots of delay:0\n            Browser.nextRAF += 1000/60;\n          }\n        }\n        var delay = Math.max(Browser.nextRAF - now, 0);\n        setTimeout(func, delay);\n      },requestAnimationFrame:function(func) {\n        if (typeof requestAnimationFrame === 'function') {\n          requestAnimationFrame(func);\n          return;\n        }\n        var RAF = Browser.fakeRequestAnimationFrame;\n        RAF(func);\n      },safeCallback:function(func) {\n        return function() {\n          if (!ABORT) return func.apply(null, arguments);\n        };\n      },allowAsyncCallbacks:true,queuedAsyncCallbacks:[],pauseAsyncCallbacks:function() {\n        Browser.allowAsyncCallbacks = false;\n      },resumeAsyncCallbacks:function() { // marks future callbacks as ok to execute, and synchronously runs any remaining ones right now\n        Browser.allowAsyncCallbacks = true;\n        if (Browser.queuedAsyncCallbacks.length > 0) {\n          var callbacks = Browser.queuedAsyncCallbacks;\n          Browser.queuedAsyncCallbacks = [];\n          callbacks.forEach(function(func) {\n            func();\n          });\n        }\n      },safeRequestAnimationFrame:function(func) {\n        return Browser.requestAnimationFrame(function() {\n          if (ABORT) return;\n          if (Browser.allowAsyncCallbacks) {\n            func();\n          } else {\n            Browser.queuedAsyncCallbacks.push(func);\n          }\n        });\n      },safeSetTimeout:function(func, timeout) {\n        noExitRuntime = true;\n        return setTimeout(function() {\n          if (ABORT) return;\n          if (Browser.allowAsyncCallbacks) {\n            func();\n          } else {\n            Browser.queuedAsyncCallbacks.push(func);\n          }\n        }, timeout);\n      },safeSetInterval:function(func, timeout) {\n        noExitRuntime = true;\n        return setInterval(function() {\n          if (ABORT) return;\n          if (Browser.allowAsyncCallbacks) {\n            func();\n          } // drop it on the floor otherwise, next interval will kick in\n        }, timeout);\n      },getMimetype:function(name) {\n        return {\n          'jpg': 'image/jpeg',\n          'jpeg': 'image/jpeg',\n          'png': 'image/png',\n          'bmp': 'image/bmp',\n          'ogg': 'audio/ogg',\n          'wav': 'audio/wav',\n          'mp3': 'audio/mpeg'\n        }[name.substr(name.lastIndexOf('.')+1)];\n      },getUserMedia:function(func) {\n        if(!window.getUserMedia) {\n          window.getUserMedia = navigator['getUserMedia'] ||\n                                navigator['mozGetUserMedia'];\n        }\n        window.getUserMedia(func);\n      },getMovementX:function(event) {\n        return event['movementX'] ||\n               event['mozMovementX'] ||\n               event['webkitMovementX'] ||\n               0;\n      },getMovementY:function(event) {\n        return event['movementY'] ||\n               event['mozMovementY'] ||\n               event['webkitMovementY'] ||\n               0;\n      },getMouseWheelDelta:function(event) {\n        var delta = 0;\n        switch (event.type) {\n          case 'DOMMouseScroll':\n            // 3 lines make up a step\n            delta = event.detail / 3;\n            break;\n          case 'mousewheel':\n            // 120 units make up a step\n            delta = event.wheelDelta / 120;\n            break;\n          case 'wheel':\n            delta = event.deltaY\n            switch(event.deltaMode) {\n              case 0:\n                // DOM_DELTA_PIXEL: 100 pixels make up a step\n                delta /= 100;\n                break;\n              case 1:\n                // DOM_DELTA_LINE: 3 lines make up a step\n                delta /= 3;\n                break;\n              case 2:\n                // DOM_DELTA_PAGE: A page makes up 80 steps\n                delta *= 80;\n                break;\n              default:\n                throw 'unrecognized mouse wheel delta mode: ' + event.deltaMode;\n            }\n            break;\n          default:\n            throw 'unrecognized mouse wheel event: ' + event.type;\n        }\n        return delta;\n      },mouseX:0,mouseY:0,mouseMovementX:0,mouseMovementY:0,touches:{},lastTouches:{},calculateMouseEvent:function(event) { // event should be mousemove, mousedown or mouseup\n        if (Browser.pointerLock) {\n          // When the pointer is locked, calculate the coordinates\n          // based on the movement of the mouse.\n          // Workaround for Firefox bug 764498\n          if (event.type != 'mousemove' &&\n              ('mozMovementX' in event)) {\n            Browser.mouseMovementX = Browser.mouseMovementY = 0;\n          } else {\n            Browser.mouseMovementX = Browser.getMovementX(event);\n            Browser.mouseMovementY = Browser.getMovementY(event);\n          }\n  \n          // check if SDL is available\n          if (typeof SDL != \"undefined\") {\n            Browser.mouseX = SDL.mouseX + Browser.mouseMovementX;\n            Browser.mouseY = SDL.mouseY + Browser.mouseMovementY;\n          } else {\n            // just add the mouse delta to the current absolut mouse position\n            // FIXME: ideally this should be clamped against the canvas size and zero\n            Browser.mouseX += Browser.mouseMovementX;\n            Browser.mouseY += Browser.mouseMovementY;\n          }\n        } else {\n          // Otherwise, calculate the movement based on the changes\n          // in the coordinates.\n          var rect = Module[\"canvas\"].getBoundingClientRect();\n          var cw = Module[\"canvas\"].width;\n          var ch = Module[\"canvas\"].height;\n  \n          // Neither .scrollX or .pageXOffset are defined in a spec, but\n          // we prefer .scrollX because it is currently in a spec draft.\n          // (see: http://www.w3.org/TR/2013/WD-cssom-view-20131217/)\n          var scrollX = ((typeof window.scrollX !== 'undefined') ? window.scrollX : window.pageXOffset);\n          var scrollY = ((typeof window.scrollY !== 'undefined') ? window.scrollY : window.pageYOffset);\n          // If this assert lands, it's likely because the browser doesn't support scrollX or pageXOffset\n          // and we have no viable fallback.\n          assert((typeof scrollX !== 'undefined') && (typeof scrollY !== 'undefined'), 'Unable to retrieve scroll position, mouse positions likely broken.');\n  \n          if (event.type === 'touchstart' || event.type === 'touchend' || event.type === 'touchmove') {\n            var touch = event.touch;\n            if (touch === undefined) {\n              return; // the \"touch\" property is only defined in SDL\n  \n            }\n            var adjustedX = touch.pageX - (scrollX + rect.left);\n            var adjustedY = touch.pageY - (scrollY + rect.top);\n  \n            adjustedX = adjustedX * (cw / rect.width);\n            adjustedY = adjustedY * (ch / rect.height);\n  \n            var coords = { x: adjustedX, y: adjustedY };\n  \n            if (event.type === 'touchstart') {\n              Browser.lastTouches[touch.identifier] = coords;\n              Browser.touches[touch.identifier] = coords;\n            } else if (event.type === 'touchend' || event.type === 'touchmove') {\n              var last = Browser.touches[touch.identifier];\n              if (!last) last = coords;\n              Browser.lastTouches[touch.identifier] = last;\n              Browser.touches[touch.identifier] = coords;\n            }\n            return;\n          }\n  \n          var x = event.pageX - (scrollX + rect.left);\n          var y = event.pageY - (scrollY + rect.top);\n  \n          // the canvas might be CSS-scaled compared to its backbuffer;\n          // SDL-using content will want mouse coordinates in terms\n          // of backbuffer units.\n          x = x * (cw / rect.width);\n          y = y * (ch / rect.height);\n  \n          Browser.mouseMovementX = x - Browser.mouseX;\n          Browser.mouseMovementY = y - Browser.mouseY;\n          Browser.mouseX = x;\n          Browser.mouseY = y;\n        }\n      },asyncLoad:function(url, onload, onerror, noRunDep) {\n        var dep = !noRunDep ? getUniqueRunDependency('al ' + url) : '';\n        readAsync(url, function(arrayBuffer) {\n          assert(arrayBuffer, 'Loading data file \"' + url + '\" failed (no arrayBuffer).');\n          onload(new Uint8Array(arrayBuffer));\n          if (dep) removeRunDependency(dep);\n        }, function(event) {\n          if (onerror) {\n            onerror();\n          } else {\n            throw 'Loading data file \"' + url + '\" failed.';\n          }\n        });\n        if (dep) addRunDependency(dep);\n      },resizeListeners:[],updateResizeListeners:function() {\n        var canvas = Module['canvas'];\n        Browser.resizeListeners.forEach(function(listener) {\n          listener(canvas.width, canvas.height);\n        });\n      },setCanvasSize:function(width, height, noUpdates) {\n        var canvas = Module['canvas'];\n        Browser.updateCanvasDimensions(canvas, width, height);\n        if (!noUpdates) Browser.updateResizeListeners();\n      },windowedWidth:0,windowedHeight:0,setFullscreenCanvasSize:function() {\n        // check if SDL is available\n        if (typeof SDL != \"undefined\") {\n          var flags = ((SAFE_HEAP_LOAD(((SDL.screen)|0), 4, 1))|0);\n          flags = flags | 0x00800000; // set SDL_FULLSCREEN flag\n          SAFE_HEAP_STORE(((SDL.screen)|0), ((flags)|0), 4)\n        }\n        Browser.updateCanvasDimensions(Module['canvas']);\n        Browser.updateResizeListeners();\n      },setWindowedCanvasSize:function() {\n        // check if SDL is available\n        if (typeof SDL != \"undefined\") {\n          var flags = ((SAFE_HEAP_LOAD(((SDL.screen)|0), 4, 1))|0);\n          flags = flags & ~0x00800000; // clear SDL_FULLSCREEN flag\n          SAFE_HEAP_STORE(((SDL.screen)|0), ((flags)|0), 4)\n        }\n        Browser.updateCanvasDimensions(Module['canvas']);\n        Browser.updateResizeListeners();\n      },updateCanvasDimensions:function(canvas, wNative, hNative) {\n        if (wNative && hNative) {\n          canvas.widthNative = wNative;\n          canvas.heightNative = hNative;\n        } else {\n          wNative = canvas.widthNative;\n          hNative = canvas.heightNative;\n        }\n        var w = wNative;\n        var h = hNative;\n        if (Module['forcedAspectRatio'] && Module['forcedAspectRatio'] > 0) {\n          if (w/h < Module['forcedAspectRatio']) {\n            w = Math.round(h * Module['forcedAspectRatio']);\n          } else {\n            h = Math.round(w / Module['forcedAspectRatio']);\n          }\n        }\n        if (((document['fullscreenElement'] || document['mozFullScreenElement'] ||\n             document['msFullscreenElement'] || document['webkitFullscreenElement'] ||\n             document['webkitCurrentFullScreenElement']) === canvas.parentNode) && (typeof screen != 'undefined')) {\n           var factor = Math.min(screen.width / w, screen.height / h);\n           w = Math.round(w * factor);\n           h = Math.round(h * factor);\n        }\n        if (Browser.resizeCanvas) {\n          if (canvas.width  != w) canvas.width  = w;\n          if (canvas.height != h) canvas.height = h;\n          if (typeof canvas.style != 'undefined') {\n            canvas.style.removeProperty( \"width\");\n            canvas.style.removeProperty(\"height\");\n          }\n        } else {\n          if (canvas.width  != wNative) canvas.width  = wNative;\n          if (canvas.height != hNative) canvas.height = hNative;\n          if (typeof canvas.style != 'undefined') {\n            if (w != wNative || h != hNative) {\n              canvas.style.setProperty( \"width\", w + \"px\", \"important\");\n              canvas.style.setProperty(\"height\", h + \"px\", \"important\");\n            } else {\n              canvas.style.removeProperty( \"width\");\n              canvas.style.removeProperty(\"height\");\n            }\n          }\n        }\n      },wgetRequests:{},nextWgetRequestHandle:0,getNextWgetRequestHandle:function() {\n        var handle = Browser.nextWgetRequestHandle;\n        Browser.nextWgetRequestHandle++;\n        return handle;\n      }};function _emscripten_exit_with_live_runtime() {\n      noExitRuntime = true;\n      throw 'unwind';\n    }\n\n  function _emscripten_get_heap_size() {\n      return HEAP8.length;\n    }\n\n  function _emscripten_get_sbrk_ptr() {\n      return 48656;\n    }\n\n  function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);\n    }\n\n  \n  function abortOnCannotGrowMemory(requestedSize) {\n      abort('Cannot enlarge memory arrays to size ' + requestedSize + ' bytes (OOM). Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + HEAP8.length + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');\n    }\n  \n  function emscripten_realloc_buffer(size) {\n      try {\n        // round size grow request up to wasm page size (fixed 64KB per spec)\n        wasmMemory.grow((size - buffer.byteLength + 65535) >> 16); // .grow() takes a delta compared to the previous size\n        updateGlobalBufferAndViews(wasmMemory.buffer);\n        return 1 /*success*/;\n      } catch(e) {\n        console.error('emscripten_realloc_buffer: Attempted to grow heap from ' + buffer.byteLength  + ' bytes to ' + size + ' bytes, but got error: ' + e);\n      }\n    }function _emscripten_resize_heap(requestedSize) {\n      var oldSize = _emscripten_get_heap_size();\n      // With pthreads, races can happen (another thread might increase the size in between), so return a failure, and let the caller retry.\n      assert(requestedSize > oldSize);\n  \n  \n      var PAGE_MULTIPLE = 65536;\n  \n      // Memory resize rules:\n      // 1. When resizing, always produce a resized heap that is at least 16MB (to avoid tiny heap sizes receiving lots of repeated resizes at startup)\n      // 2. Always increase heap size to at least the requested size, rounded up to next page multiple.\n      // 3a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap geometrically: increase the heap size according to \n      //                                         MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%),\n      //                                         At most overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).\n      // 3b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap linearly: increase the heap size by at least MEMORY_GROWTH_LINEAR_STEP bytes.\n      // 4. Max size for the heap is capped at 2048MB-PAGE_MULTIPLE, or by WASM_MEM_MAX, or by ASAN limit, depending on which is smallest\n      // 5. If we were unable to allocate as much memory, it may be due to over-eager decision to excessively reserve due to (3) above.\n      //    Hence if an allocation fails, cut down on the amount of excess growth, in an attempt to succeed to perform a smaller allocation.\n  \n      var maxHeapSize = 2147483648 - PAGE_MULTIPLE;\n      if (requestedSize > maxHeapSize) {\n        err('Cannot enlarge memory, asked to go up to ' + requestedSize + ' bytes, but the limit is ' + maxHeapSize + ' bytes!');\n        return false;\n      }\n  \n      var minHeapSize = 16777216;\n  \n      // Loop through potential heap size increases. If we attempt a too eager reservation that fails, cut down on the\n      // attempted size and reserve a smaller bump instead. (max 3 times, chosen somewhat arbitrarily)\n      for(var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth\n        // but limit overreserving (default to capping at +96MB overgrowth at most)\n        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );\n  \n  \n        var newSize = Math.min(maxHeapSize, alignUp(Math.max(minHeapSize, requestedSize, overGrownHeapSize), PAGE_MULTIPLE));\n  \n        var t0 = _emscripten_get_now();\n        var replacement = emscripten_realloc_buffer(newSize);\n        var t1 = _emscripten_get_now();\n        console.log('Heap resize call from ' + oldSize + ' to ' + newSize + ' took ' + (t1 - t0) + ' msecs. Success: ' + !!replacement);\n        if (replacement) {\n  \n          return true;\n        }\n      }\n      err('Failed to grow the heap from ' + oldSize + ' bytes to ' + newSize + ' bytes, not enough memory!');\n      return false;\n    }\n\n  \n  \n  var ENV={};function _emscripten_get_environ() {\n      if (!_emscripten_get_environ.strings) {\n        // Default values.\n        var env = {\n          'USER': 'web_user',\n          'LOGNAME': 'web_user',\n          'PATH': '/',\n          'PWD': '/',\n          'HOME': '/home/web_user',\n          // Browser language detection #8751\n          'LANG': ((typeof navigator === 'object' && navigator.languages && navigator.languages[0]) || 'C').replace('-', '_') + '.UTF-8',\n          '_': thisProgram\n        };\n        // Apply the user-provided values, if any.\n        for (var x in ENV) {\n          env[x] = ENV[x];\n        }\n        var strings = [];\n        for (var x in env) {\n          strings.push(x + '=' + env[x]);\n        }\n        _emscripten_get_environ.strings = strings;\n      }\n      return _emscripten_get_environ.strings;\n    }function _environ_get(__environ, environ_buf) {\n      var strings = _emscripten_get_environ();\n      var bufSize = 0;\n      strings.forEach(function(string, i) {\n        var ptr = environ_buf + bufSize;\n        SAFE_HEAP_STORE((((__environ)+(i * 4))|0), ((ptr)|0), 4);\n        writeAsciiToMemory(string, ptr);\n        bufSize += string.length + 1;\n      });\n      return 0;\n    }\n\n  function _environ_sizes_get(penviron_count, penviron_buf_size) {\n      var strings = _emscripten_get_environ();\n      SAFE_HEAP_STORE(((penviron_count)|0), ((strings.length)|0), 4);\n      var bufSize = 0;\n      strings.forEach(function(string) {\n        bufSize += string.length + 1;\n      });\n      SAFE_HEAP_STORE(((penviron_buf_size)|0), ((bufSize)|0), 4);\n      return 0;\n    }\n\n  function _fd_close(fd) {try {\n  \n      abort('it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM');\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return e.errno;\n  }\n  }\n\n  function _fd_read(fd, iov, iovcnt, pnum) {try {\n  \n      var stream = SYSCALLS.getStreamFromFD(fd);\n      var num = SYSCALLS.doReadv(stream, iov, iovcnt);\n      SAFE_HEAP_STORE(((pnum)|0), ((num)|0), 4)\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return e.errno;\n  }\n  }\n\n  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {try {\n  \n      abort('it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM');\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return e.errno;\n  }\n  }\n\n  \n  function flush_NO_FILESYSTEM() {\n      // flush anything remaining in the buffers during shutdown\n      var fflush = Module[\"_fflush\"];\n      if (fflush) fflush(0);\n      var buffers = SYSCALLS.buffers;\n      if (buffers[1].length) SYSCALLS.printChar(1, 10);\n      if (buffers[2].length) SYSCALLS.printChar(2, 10);\n    }function _fd_write(fd, iov, iovcnt, pnum) {try {\n  \n      // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0\n      var num = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = ((SAFE_HEAP_LOAD((((iov)+(i*8))|0), 4, 0))|0);\n        var len = ((SAFE_HEAP_LOAD((((iov)+(i*8 + 4))|0), 4, 0))|0);\n        for (var j = 0; j < len; j++) {\n          SYSCALLS.printChar(fd, HEAPU8[ptr+j]);\n        }\n        num += len;\n      }\n      SAFE_HEAP_STORE(((pnum)|0), ((num)|0), 4)\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return e.errno;\n  }\n  }\n\n  function _gettimeofday(ptr) {\n      var now = Date.now();\n      SAFE_HEAP_STORE(((ptr)|0), (((now/1000)|0)|0), 4); // seconds\n      SAFE_HEAP_STORE((((ptr)+(4))|0), ((((now % 1000)*1000)|0)|0), 4); // microseconds\n      return 0;\n    }\n\n  \n  var ___tm_timezone=(stringToUTF8(\"GMT\", 48720, 4), 48720);function _gmtime_r(time, tmPtr) {\n      var date = new Date(((SAFE_HEAP_LOAD(((time)|0), 4, 0))|0)*1000);\n      SAFE_HEAP_STORE(((tmPtr)|0), ((date.getUTCSeconds())|0), 4);\n      SAFE_HEAP_STORE((((tmPtr)+(4))|0), ((date.getUTCMinutes())|0), 4);\n      SAFE_HEAP_STORE((((tmPtr)+(8))|0), ((date.getUTCHours())|0), 4);\n      SAFE_HEAP_STORE((((tmPtr)+(12))|0), ((date.getUTCDate())|0), 4);\n      SAFE_HEAP_STORE((((tmPtr)+(16))|0), ((date.getUTCMonth())|0), 4);\n      SAFE_HEAP_STORE((((tmPtr)+(20))|0), ((date.getUTCFullYear()-1900)|0), 4);\n      SAFE_HEAP_STORE((((tmPtr)+(24))|0), ((date.getUTCDay())|0), 4);\n      SAFE_HEAP_STORE((((tmPtr)+(36))|0), ((0)|0), 4);\n      SAFE_HEAP_STORE((((tmPtr)+(32))|0), ((0)|0), 4);\n      var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);\n      var yday = ((date.getTime() - start) / (1000 * 60 * 60 * 24))|0;\n      SAFE_HEAP_STORE((((tmPtr)+(28))|0), ((yday)|0), 4);\n      SAFE_HEAP_STORE((((tmPtr)+(40))|0), ((___tm_timezone)|0), 4);\n  \n      return tmPtr;\n    }\n\n  function _localtime_r(time, tmPtr) {\n      _tzset();\n      var date = new Date(((SAFE_HEAP_LOAD(((time)|0), 4, 0))|0)*1000);\n      SAFE_HEAP_STORE(((tmPtr)|0), ((date.getSeconds())|0), 4);\n      SAFE_HEAP_STORE((((tmPtr)+(4))|0), ((date.getMinutes())|0), 4);\n      SAFE_HEAP_STORE((((tmPtr)+(8))|0), ((date.getHours())|0), 4);\n      SAFE_HEAP_STORE((((tmPtr)+(12))|0), ((date.getDate())|0), 4);\n      SAFE_HEAP_STORE((((tmPtr)+(16))|0), ((date.getMonth())|0), 4);\n      SAFE_HEAP_STORE((((tmPtr)+(20))|0), ((date.getFullYear()-1900)|0), 4);\n      SAFE_HEAP_STORE((((tmPtr)+(24))|0), ((date.getDay())|0), 4);\n  \n      var start = new Date(date.getFullYear(), 0, 1);\n      var yday = ((date.getTime() - start.getTime()) / (1000 * 60 * 60 * 24))|0;\n      SAFE_HEAP_STORE((((tmPtr)+(28))|0), ((yday)|0), 4);\n      SAFE_HEAP_STORE((((tmPtr)+(36))|0), ((-(date.getTimezoneOffset() * 60))|0), 4);\n  \n      // Attention: DST is in December in South, and some regions don't have DST at all.\n      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();\n      var winterOffset = start.getTimezoneOffset();\n      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset))|0;\n      SAFE_HEAP_STORE((((tmPtr)+(32))|0), ((dst)|0), 4);\n  \n      var zonePtr = ((SAFE_HEAP_LOAD((((__get_tzname())+(dst ? 4 : 0))|0), 4, 0))|0);\n      SAFE_HEAP_STORE((((tmPtr)+(40))|0), ((zonePtr)|0), 4);\n  \n      return tmPtr;\n    }\n\n  function _memcpy(dest, src, num) {\n      dest = dest|0; src = src|0; num = num|0;\n      var ret = 0;\n      var aligned_dest_end = 0;\n      var block_aligned_dest_end = 0;\n      var dest_end = 0;\n      // Test against a benchmarked cutoff limit for when HEAPU8.set() becomes faster to use.\n      if ((num|0) >= 8192) {\n        _emscripten_memcpy_big(dest|0, src|0, num|0)|0;\n        return dest|0;\n      }\n  \n      ret = dest|0;\n      dest_end = (dest + num)|0;\n      if ((dest&3) == (src&3)) {\n        // The initial unaligned < 4-byte front.\n        while (dest & 3) {\n          if ((num|0) == 0) return ret|0;\n          SAFE_HEAP_STORE(((dest)|0), ((((SAFE_HEAP_LOAD(((src)|0), 1, 0))|0))|0), 1);\n          dest = (dest+1)|0;\n          src = (src+1)|0;\n          num = (num-1)|0;\n        }\n        aligned_dest_end = (dest_end & -4)|0;\n        block_aligned_dest_end = (aligned_dest_end - 64)|0;\n        while ((dest|0) <= (block_aligned_dest_end|0) ) {\n          SAFE_HEAP_STORE(((dest)|0), ((((SAFE_HEAP_LOAD(((src)|0), 4, 0))|0))|0), 4);\n          SAFE_HEAP_STORE((((dest)+(4))|0), ((((SAFE_HEAP_LOAD((((src)+(4))|0), 4, 0))|0))|0), 4);\n          SAFE_HEAP_STORE((((dest)+(8))|0), ((((SAFE_HEAP_LOAD((((src)+(8))|0), 4, 0))|0))|0), 4);\n          SAFE_HEAP_STORE((((dest)+(12))|0), ((((SAFE_HEAP_LOAD((((src)+(12))|0), 4, 0))|0))|0), 4);\n          SAFE_HEAP_STORE((((dest)+(16))|0), ((((SAFE_HEAP_LOAD((((src)+(16))|0), 4, 0))|0))|0), 4);\n          SAFE_HEAP_STORE((((dest)+(20))|0), ((((SAFE_HEAP_LOAD((((src)+(20))|0), 4, 0))|0))|0), 4);\n          SAFE_HEAP_STORE((((dest)+(24))|0), ((((SAFE_HEAP_LOAD((((src)+(24))|0), 4, 0))|0))|0), 4);\n          SAFE_HEAP_STORE((((dest)+(28))|0), ((((SAFE_HEAP_LOAD((((src)+(28))|0), 4, 0))|0))|0), 4);\n          SAFE_HEAP_STORE((((dest)+(32))|0), ((((SAFE_HEAP_LOAD((((src)+(32))|0), 4, 0))|0))|0), 4);\n          SAFE_HEAP_STORE((((dest)+(36))|0), ((((SAFE_HEAP_LOAD((((src)+(36))|0), 4, 0))|0))|0), 4);\n          SAFE_HEAP_STORE((((dest)+(40))|0), ((((SAFE_HEAP_LOAD((((src)+(40))|0), 4, 0))|0))|0), 4);\n          SAFE_HEAP_STORE((((dest)+(44))|0), ((((SAFE_HEAP_LOAD((((src)+(44))|0), 4, 0))|0))|0), 4);\n          SAFE_HEAP_STORE((((dest)+(48))|0), ((((SAFE_HEAP_LOAD((((src)+(48))|0), 4, 0))|0))|0), 4);\n          SAFE_HEAP_STORE((((dest)+(52))|0), ((((SAFE_HEAP_LOAD((((src)+(52))|0), 4, 0))|0))|0), 4);\n          SAFE_HEAP_STORE((((dest)+(56))|0), ((((SAFE_HEAP_LOAD((((src)+(56))|0), 4, 0))|0))|0), 4);\n          SAFE_HEAP_STORE((((dest)+(60))|0), ((((SAFE_HEAP_LOAD((((src)+(60))|0), 4, 0))|0))|0), 4);\n          dest = (dest+64)|0;\n          src = (src+64)|0;\n        }\n        while ((dest|0) < (aligned_dest_end|0) ) {\n          SAFE_HEAP_STORE(((dest)|0), ((((SAFE_HEAP_LOAD(((src)|0), 4, 0))|0))|0), 4);\n          dest = (dest+4)|0;\n          src = (src+4)|0;\n        }\n      } else {\n        // In the unaligned copy case, unroll a bit as well.\n        aligned_dest_end = (dest_end - 4)|0;\n        while ((dest|0) < (aligned_dest_end|0) ) {\n          SAFE_HEAP_STORE(((dest)|0), ((((SAFE_HEAP_LOAD(((src)|0), 1, 0))|0))|0), 1);\n          SAFE_HEAP_STORE((((dest)+(1))|0), ((((SAFE_HEAP_LOAD((((src)+(1))|0), 1, 0))|0))|0), 1);\n          SAFE_HEAP_STORE((((dest)+(2))|0), ((((SAFE_HEAP_LOAD((((src)+(2))|0), 1, 0))|0))|0), 1);\n          SAFE_HEAP_STORE((((dest)+(3))|0), ((((SAFE_HEAP_LOAD((((src)+(3))|0), 1, 0))|0))|0), 1);\n          dest = (dest+4)|0;\n          src = (src+4)|0;\n        }\n      }\n      // The remaining unaligned < 4 byte tail.\n      while ((dest|0) < (dest_end|0)) {\n        SAFE_HEAP_STORE(((dest)|0), ((((SAFE_HEAP_LOAD(((src)|0), 1, 0))|0))|0), 1);\n        dest = (dest+1)|0;\n        src = (src+1)|0;\n      }\n      return ret|0;\n    }\n\n\n\n  function _pthread_cond_destroy() { return 0; }\n\n  function _pthread_cond_init() { return 0; }\n\n  function _pthread_mutexattr_destroy() {}\n\n  function _pthread_mutexattr_init() {}\n\n  function _pthread_mutexattr_setpshared(attr, pshared) {\n      // XXX implement if/when getpshared is required\n      return 0;\n    }\n\n  \n  function _round(d) {\n      d = +d;\n      return d >= +0 ? +Math_floor(d + +0.5) : +Math_ceil(d - +0.5);\n    }\n\n  function _setTempRet0($i) {\n      setTempRet0(($i) | 0);\n    }\n\n  \n  function __isLeapYear(year) {\n        return year%4 === 0 && (year%100 !== 0 || year%400 === 0);\n    }\n  \n  function __arraySum(array, index) {\n      var sum = 0;\n      for (var i = 0; i <= index; sum += array[i++]);\n      return sum;\n    }\n  \n  \n  var __MONTH_DAYS_LEAP=[31,29,31,30,31,30,31,31,30,31,30,31];\n  \n  var __MONTH_DAYS_REGULAR=[31,28,31,30,31,30,31,31,30,31,30,31];function __addDays(date, days) {\n      var newDate = new Date(date.getTime());\n      while(days > 0) {\n        var leap = __isLeapYear(newDate.getFullYear());\n        var currentMonth = newDate.getMonth();\n        var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];\n  \n        if (days > daysInCurrentMonth-newDate.getDate()) {\n          // we spill over to next month\n          days -= (daysInCurrentMonth-newDate.getDate()+1);\n          newDate.setDate(1);\n          if (currentMonth < 11) {\n            newDate.setMonth(currentMonth+1)\n          } else {\n            newDate.setMonth(0);\n            newDate.setFullYear(newDate.getFullYear()+1);\n          }\n        } else {\n          // we stay in current month\n          newDate.setDate(newDate.getDate()+days);\n          return newDate;\n        }\n      }\n  \n      return newDate;\n    }function _strptime(buf, format, tm) {\n      // char *strptime(const char *restrict buf, const char *restrict format, struct tm *restrict tm);\n      // http://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html\n      var pattern = UTF8ToString(format);\n  \n      // escape special characters\n      // TODO: not sure we really need to escape all of these in JS regexps\n      var SPECIAL_CHARS = '\\\\!@#$^&*()+=-[]/{}|:<>?,.';\n      for (var i=0, ii=SPECIAL_CHARS.length; i<ii; ++i) {\n        pattern = pattern.replace(new RegExp('\\\\'+SPECIAL_CHARS[i], 'g'), '\\\\'+SPECIAL_CHARS[i]);\n      }\n  \n      // reduce number of matchers\n      var EQUIVALENT_MATCHERS = {\n        '%A':  '%a',\n        '%B':  '%b',\n        '%c':  '%a %b %d %H:%M:%S %Y',\n        '%D':  '%m\\\\/%d\\\\/%y',\n        '%e':  '%d',\n        '%F':  '%Y-%m-%d',\n        '%h':  '%b',\n        '%R':  '%H\\\\:%M',\n        '%r':  '%I\\\\:%M\\\\:%S\\\\s%p',\n        '%T':  '%H\\\\:%M\\\\:%S',\n        '%x':  '%m\\\\/%d\\\\/(?:%y|%Y)',\n        '%X':  '%H\\\\:%M\\\\:%S'\n      };\n      for (var matcher in EQUIVALENT_MATCHERS) {\n        pattern = pattern.replace(matcher, EQUIVALENT_MATCHERS[matcher]);\n      }\n  \n      // TODO: take care of locale\n  \n      var DATE_PATTERNS = {\n        /* weeday name */     '%a': '(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)',\n        /* month name */      '%b': '(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)',\n        /* century */         '%C': '\\\\d\\\\d',\n        /* day of month */    '%d': '0[1-9]|[1-9](?!\\\\d)|1\\\\d|2\\\\d|30|31',\n        /* hour (24hr) */     '%H': '\\\\d(?!\\\\d)|[0,1]\\\\d|20|21|22|23',\n        /* hour (12hr) */     '%I': '\\\\d(?!\\\\d)|0\\\\d|10|11|12',\n        /* day of year */     '%j': '00[1-9]|0?[1-9](?!\\\\d)|0?[1-9]\\\\d(?!\\\\d)|[1,2]\\\\d\\\\d|3[0-6]\\\\d',\n        /* month */           '%m': '0[1-9]|[1-9](?!\\\\d)|10|11|12',\n        /* minutes */         '%M': '0\\\\d|\\\\d(?!\\\\d)|[1-5]\\\\d',\n        /* whitespace */      '%n': '\\\\s',\n        /* AM/PM */           '%p': 'AM|am|PM|pm|A\\\\.M\\\\.|a\\\\.m\\\\.|P\\\\.M\\\\.|p\\\\.m\\\\.',\n        /* seconds */         '%S': '0\\\\d|\\\\d(?!\\\\d)|[1-5]\\\\d|60',\n        /* week number */     '%U': '0\\\\d|\\\\d(?!\\\\d)|[1-4]\\\\d|50|51|52|53',\n        /* week number */     '%W': '0\\\\d|\\\\d(?!\\\\d)|[1-4]\\\\d|50|51|52|53',\n        /* weekday number */  '%w': '[0-6]',\n        /* 2-digit year */    '%y': '\\\\d\\\\d',\n        /* 4-digit year */    '%Y': '\\\\d\\\\d\\\\d\\\\d',\n        /* % */               '%%': '%',\n        /* whitespace */      '%t': '\\\\s',\n      };\n  \n      var MONTH_NUMBERS = {JAN: 0, FEB: 1, MAR: 2, APR: 3, MAY: 4, JUN: 5, JUL: 6, AUG: 7, SEP: 8, OCT: 9, NOV: 10, DEC: 11};\n      var DAY_NUMBERS_SUN_FIRST = {SUN: 0, MON: 1, TUE: 2, WED: 3, THU: 4, FRI: 5, SAT: 6};\n      var DAY_NUMBERS_MON_FIRST = {MON: 0, TUE: 1, WED: 2, THU: 3, FRI: 4, SAT: 5, SUN: 6};\n  \n      for (var datePattern in DATE_PATTERNS) {\n        pattern = pattern.replace(datePattern, '('+datePattern+DATE_PATTERNS[datePattern]+')');\n      }\n  \n      // take care of capturing groups\n      var capture = [];\n      for (var i=pattern.indexOf('%'); i>=0; i=pattern.indexOf('%')) {\n        capture.push(pattern[i+1]);\n        pattern = pattern.replace(new RegExp('\\\\%'+pattern[i+1], 'g'), '');\n      }\n  \n      var matches = new RegExp('^'+pattern, \"i\").exec(UTF8ToString(buf))\n      // out(UTF8ToString(buf)+ ' is matched by '+((new RegExp('^'+pattern)).source)+' into: '+JSON.stringify(matches));\n  \n      function initDate() {\n        function fixup(value, min, max) {\n          return (typeof value !== 'number' || isNaN(value)) ? min : (value>=min ? (value<=max ? value: max): min);\n        };\n        return {\n          year: fixup(HEAP32[(((tm)+(20))>>2)] + 1900 , 1970, 9999),\n          month: fixup(HEAP32[(((tm)+(16))>>2)], 0, 11),\n          day: fixup(HEAP32[(((tm)+(12))>>2)], 1, 31),\n          hour: fixup(HEAP32[(((tm)+(8))>>2)], 0, 23),\n          min: fixup(HEAP32[(((tm)+(4))>>2)], 0, 59),\n          sec: fixup(HEAP32[((tm)>>2)], 0, 59)\n        };\n      };\n  \n      if (matches) {\n        var date = initDate();\n        var value;\n  \n        var getMatch = function(symbol) {\n          var pos = capture.indexOf(symbol);\n          // check if symbol appears in regexp\n          if (pos >= 0) {\n            // return matched value or null (falsy!) for non-matches\n            return matches[pos+1];\n          }\n          return;\n        };\n  \n        // seconds\n        if ((value=getMatch('S'))) {\n          date.sec = parseInt(value);\n        }\n  \n        // minutes\n        if ((value=getMatch('M'))) {\n          date.min = parseInt(value);\n        }\n  \n        // hours\n        if ((value=getMatch('H'))) {\n          // 24h clock\n          date.hour = parseInt(value);\n        } else if ((value = getMatch('I'))) {\n          // AM/PM clock\n          var hour = parseInt(value);\n          if ((value=getMatch('p'))) {\n            hour += value.toUpperCase()[0] === 'P' ? 12 : 0;\n          }\n          date.hour = hour;\n        }\n  \n        // year\n        if ((value=getMatch('Y'))) {\n          // parse from four-digit year\n          date.year = parseInt(value);\n        } else if ((value=getMatch('y'))) {\n          // parse from two-digit year...\n          var year = parseInt(value);\n          if ((value=getMatch('C'))) {\n            // ...and century\n            year += parseInt(value)*100;\n          } else {\n            // ...and rule-of-thumb\n            year += year<69 ? 2000 : 1900;\n          }\n          date.year = year;\n        }\n  \n        // month\n        if ((value=getMatch('m'))) {\n          // parse from month number\n          date.month = parseInt(value)-1;\n        } else if ((value=getMatch('b'))) {\n          // parse from month name\n          date.month = MONTH_NUMBERS[value.substring(0,3).toUpperCase()] || 0;\n          // TODO: derive month from day in year+year, week number+day of week+year\n        }\n  \n        // day\n        if ((value=getMatch('d'))) {\n          // get day of month directly\n          date.day = parseInt(value);\n        } else if ((value=getMatch('j'))) {\n          // get day of month from day of year ...\n          var day = parseInt(value);\n          var leapYear = __isLeapYear(date.year);\n          for (var month=0; month<12; ++month) {\n            var daysUntilMonth = __arraySum(leapYear ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, month-1);\n            if (day<=daysUntilMonth+(leapYear ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[month]) {\n              date.day = day-daysUntilMonth;\n            }\n          }\n        } else if ((value=getMatch('a'))) {\n          // get day of month from weekday ...\n          var weekDay = value.substring(0,3).toUpperCase();\n          if ((value=getMatch('U'))) {\n            // ... and week number (Sunday being first day of week)\n            // Week number of the year (Sunday as the first day of the week) as a decimal number [00,53].\n            // All days in a new year preceding the first Sunday are considered to be in week 0.\n            var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];\n            var weekNumber = parseInt(value);\n  \n            // January 1st\n            var janFirst = new Date(date.year, 0, 1);\n            var endDate;\n            if (janFirst.getDay() === 0) {\n              // Jan 1st is a Sunday, and, hence in the 1st CW\n              endDate = __addDays(janFirst, weekDayNumber+7*(weekNumber-1));\n            } else {\n              // Jan 1st is not a Sunday, and, hence still in the 0th CW\n              endDate = __addDays(janFirst, 7-janFirst.getDay()+weekDayNumber+7*(weekNumber-1));\n            }\n            date.day = endDate.getDate();\n            date.month = endDate.getMonth();\n          } else if ((value=getMatch('W'))) {\n            // ... and week number (Monday being first day of week)\n            // Week number of the year (Monday as the first day of the week) as a decimal number [00,53].\n            // All days in a new year preceding the first Monday are considered to be in week 0.\n            var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];\n            var weekNumber = parseInt(value);\n  \n            // January 1st\n            var janFirst = new Date(date.year, 0, 1);\n            var endDate;\n            if (janFirst.getDay()===1) {\n              // Jan 1st is a Monday, and, hence in the 1st CW\n               endDate = __addDays(janFirst, weekDayNumber+7*(weekNumber-1));\n            } else {\n              // Jan 1st is not a Monday, and, hence still in the 0th CW\n              endDate = __addDays(janFirst, 7-janFirst.getDay()+1+weekDayNumber+7*(weekNumber-1));\n            }\n  \n            date.day = endDate.getDate();\n            date.month = endDate.getMonth();\n          }\n        }\n  \n        /*\n        tm_sec  int seconds after the minute  0-61*\n        tm_min  int minutes after the hour  0-59\n        tm_hour int hours since midnight  0-23\n        tm_mday int day of the month  1-31\n        tm_mon  int months since January  0-11\n        tm_year int years since 1900\n        tm_wday int days since Sunday 0-6\n        tm_yday int days since January 1  0-365\n        tm_isdst  int Daylight Saving Time flag\n        */\n  \n        var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);\n        SAFE_HEAP_STORE(((tm)|0), ((fullDate.getSeconds())|0), 4);\n        SAFE_HEAP_STORE((((tm)+(4))|0), ((fullDate.getMinutes())|0), 4);\n        SAFE_HEAP_STORE((((tm)+(8))|0), ((fullDate.getHours())|0), 4);\n        SAFE_HEAP_STORE((((tm)+(12))|0), ((fullDate.getDate())|0), 4);\n        SAFE_HEAP_STORE((((tm)+(16))|0), ((fullDate.getMonth())|0), 4);\n        SAFE_HEAP_STORE((((tm)+(20))|0), ((fullDate.getFullYear()-1900)|0), 4);\n        SAFE_HEAP_STORE((((tm)+(24))|0), ((fullDate.getDay())|0), 4);\n        SAFE_HEAP_STORE((((tm)+(28))|0), ((__arraySum(__isLeapYear(fullDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, fullDate.getMonth()-1)+fullDate.getDate()-1)|0), 4);\n        SAFE_HEAP_STORE((((tm)+(32))|0), ((0)|0), 4);\n  \n        // we need to convert the matched sequence into an integer array to take care of UTF-8 characters > 0x7F\n        // TODO: not sure that intArrayFromString handles all unicode characters correctly\n        return buf+intArrayFromString(matches[0]).length-1;\n      }\n  \n      return 0;\n    }\n\n  function _sysconf(name) {\n      // long sysconf(int name);\n      // http://pubs.opengroup.org/onlinepubs/009695399/functions/sysconf.html\n      switch(name) {\n        case 30: return PAGE_SIZE;\n        case 85:\n          var maxHeapSize = 2*1024*1024*1024 - 65536;\n          return maxHeapSize / PAGE_SIZE;\n        case 132:\n        case 133:\n        case 12:\n        case 137:\n        case 138:\n        case 15:\n        case 235:\n        case 16:\n        case 17:\n        case 18:\n        case 19:\n        case 20:\n        case 149:\n        case 13:\n        case 10:\n        case 236:\n        case 153:\n        case 9:\n        case 21:\n        case 22:\n        case 159:\n        case 154:\n        case 14:\n        case 77:\n        case 78:\n        case 139:\n        case 80:\n        case 81:\n        case 82:\n        case 68:\n        case 67:\n        case 164:\n        case 11:\n        case 29:\n        case 47:\n        case 48:\n        case 95:\n        case 52:\n        case 51:\n        case 46:\n          return 200809;\n        case 79:\n          return 0;\n        case 27:\n        case 246:\n        case 127:\n        case 128:\n        case 23:\n        case 24:\n        case 160:\n        case 161:\n        case 181:\n        case 182:\n        case 242:\n        case 183:\n        case 184:\n        case 243:\n        case 244:\n        case 245:\n        case 165:\n        case 178:\n        case 179:\n        case 49:\n        case 50:\n        case 168:\n        case 169:\n        case 175:\n        case 170:\n        case 171:\n        case 172:\n        case 97:\n        case 76:\n        case 32:\n        case 173:\n        case 35:\n          return -1;\n        case 176:\n        case 177:\n        case 7:\n        case 155:\n        case 8:\n        case 157:\n        case 125:\n        case 126:\n        case 92:\n        case 93:\n        case 129:\n        case 130:\n        case 131:\n        case 94:\n        case 91:\n          return 1;\n        case 74:\n        case 60:\n        case 69:\n        case 70:\n        case 4:\n          return 1024;\n        case 31:\n        case 42:\n        case 72:\n          return 32;\n        case 87:\n        case 26:\n        case 33:\n          return 2147483647;\n        case 34:\n        case 1:\n          return 47839;\n        case 38:\n        case 36:\n          return 99;\n        case 43:\n        case 37:\n          return 2048;\n        case 0: return 2097152;\n        case 3: return 65536;\n        case 28: return 32768;\n        case 44: return 32767;\n        case 75: return 16384;\n        case 39: return 1000;\n        case 89: return 700;\n        case 71: return 256;\n        case 40: return 255;\n        case 2: return 100;\n        case 180: return 64;\n        case 25: return 20;\n        case 5: return 16;\n        case 6: return 6;\n        case 73: return 4;\n        case 84: {\n          if (typeof navigator === 'object') return navigator['hardwareConcurrency'] || 1;\n          return 1;\n        }\n      }\n      ___setErrNo(28);\n      return -1;\n    }\nModule[\"requestFullscreen\"] = function Module_requestFullscreen(lockPointer, resizeCanvas, vrDevice) { Browser.requestFullscreen(lockPointer, resizeCanvas, vrDevice) };\n  Module[\"requestFullScreen\"] = function Module_requestFullScreen() { Browser.requestFullScreen() };\n  Module[\"requestAnimationFrame\"] = function Module_requestAnimationFrame(func) { Browser.requestAnimationFrame(func) };\n  Module[\"setCanvasSize\"] = function Module_setCanvasSize(width, height, noUpdates) { Browser.setCanvasSize(width, height, noUpdates) };\n  Module[\"pauseMainLoop\"] = function Module_pauseMainLoop() { Browser.mainLoop.pause() };\n  Module[\"resumeMainLoop\"] = function Module_resumeMainLoop() { Browser.mainLoop.resume() };\n  Module[\"getUserMedia\"] = function Module_getUserMedia() { Browser.getUserMedia() }\n  Module[\"createContext\"] = function Module_createContext(canvas, useWebGL, setInModule, webGLContextAttributes) { return Browser.createContext(canvas, useWebGL, setInModule, webGLContextAttributes) };\n_emscripten_get_now = function() { return performance['now'](); };\n  ;\nvar ASSERTIONS = true;\n\n// Copyright 2017 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n\n/** @type {function(string, boolean=, number=)} */\nfunction intArrayFromString(stringy, dontAddNull, length) {\n  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;\n  var u8array = new Array(len);\n  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n  if (dontAddNull) u8array.length = numBytesWritten;\n  return u8array;\n}\n\nfunction intArrayToString(array) {\n  var ret = [];\n  for (var i = 0; i < array.length; i++) {\n    var chr = array[i];\n    if (chr > 0xFF) {\n      if (ASSERTIONS) {\n        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\n      }\n      chr &= 0xFF;\n    }\n    ret.push(String.fromCharCode(chr));\n  }\n  return ret.join('');\n}\n\n\n// ASM_LIBRARY EXTERN PRIMITIVES: Int8Array,Int32Array,Math_floor,Math_ceil\n\nvar asmGlobalArg = {};\nvar asmLibraryArg = { \"__assert_fail\": ___assert_fail, \"__handle_stack_overflow\": ___handle_stack_overflow, \"__lock\": ___lock, \"__map_file\": ___map_file, \"__syscall10\": ___syscall10, \"__syscall144\": ___syscall144, \"__syscall148\": ___syscall148, \"__syscall180\": ___syscall180, \"__syscall181\": ___syscall181, \"__syscall183\": ___syscall183, \"__syscall192\": ___syscall192, \"__syscall194\": ___syscall194, \"__syscall195\": ___syscall195, \"__syscall20\": ___syscall20, \"__syscall219\": ___syscall219, \"__syscall220\": ___syscall220, \"__syscall221\": ___syscall221, \"__syscall40\": ___syscall40, \"__syscall5\": ___syscall5, \"__syscall54\": ___syscall54, \"__syscall91\": ___syscall91, \"__unlock\": ___unlock, \"abort\": _abort, \"abs\": _abs, \"alignfault\": alignfault, \"asctime_r\": _asctime_r, \"emscripten_asm_const_iii\": _emscripten_asm_const_iii, \"emscripten_exit_with_live_runtime\": _emscripten_exit_with_live_runtime, \"emscripten_get_sbrk_ptr\": _emscripten_get_sbrk_ptr, \"emscripten_memcpy_big\": _emscripten_memcpy_big, \"emscripten_resize_heap\": _emscripten_resize_heap, \"environ_get\": _environ_get, \"environ_sizes_get\": _environ_sizes_get, \"fd_close\": _fd_close, \"fd_read\": _fd_read, \"fd_seek\": _fd_seek, \"fd_write\": _fd_write, \"gettimeofday\": _gettimeofday, \"gmtime_r\": _gmtime_r, \"localtime_r\": _localtime_r, \"memory\": wasmMemory, \"mktime\": _mktime, \"pthread_cond_destroy\": _pthread_cond_destroy, \"pthread_cond_init\": _pthread_cond_init, \"pthread_mutexattr_destroy\": _pthread_mutexattr_destroy, \"pthread_mutexattr_init\": _pthread_mutexattr_init, \"pthread_mutexattr_setpshared\": _pthread_mutexattr_setpshared, \"round\": _round, \"segfault\": segfault, \"setTempRet0\": _setTempRet0, \"strptime\": _strptime, \"sysconf\": _sysconf, \"table\": wasmTable };\nvar asm = createWasm();\nvar real____wasm_call_ctors = asm[\"__wasm_call_ctors\"];\nasm[\"__wasm_call_ctors\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real____wasm_call_ctors.apply(null, arguments);\n};\n\nvar real__malloc = asm[\"malloc\"];\nasm[\"malloc\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__malloc.apply(null, arguments);\n};\n\nvar real__ggraph__declare_meta = asm[\"ggraph__declare_meta\"];\nasm[\"ggraph__declare_meta\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__ggraph__declare_meta.apply(null, arguments);\n};\n\nvar real__free = asm[\"free\"];\nasm[\"free\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__free.apply(null, arguments);\n};\n\nvar real__gstring__add_raw_string = asm[\"gstring__add_raw_string\"];\nasm[\"gstring__add_raw_string\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gstring__add_raw_string.apply(null, arguments);\n};\n\nvar real__gstring__close = asm[\"gstring__close\"];\nasm[\"gstring__close\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gstring__close.apply(null, arguments);\n};\n\nvar real__ggraph__meta = asm[\"ggraph__meta\"];\nasm[\"ggraph__meta\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__ggraph__meta.apply(null, arguments);\n};\n\nvar real__ggraph__create_string = asm[\"ggraph__create_string\"];\nasm[\"ggraph__create_string\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__ggraph__create_string.apply(null, arguments);\n};\n\nvar real__gobject__un_mark = asm[\"gobject__un_mark\"];\nasm[\"gobject__un_mark\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gobject__un_mark.apply(null, arguments);\n};\n\nvar real__gctx__ordinal = asm[\"gctx__ordinal\"];\nasm[\"gctx__ordinal\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gctx__ordinal.apply(null, arguments);\n};\n\nvar real__htons = asm[\"htons\"];\nasm[\"htons\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__htons.apply(null, arguments);\n};\n\nvar real__gctx__json = asm[\"gctx__json\"];\nasm[\"gctx__json\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gctx__json.apply(null, arguments);\n};\n\nvar real__gctx__prepare = asm[\"gctx__prepare\"];\nasm[\"gctx__prepare\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gctx__prepare.apply(null, arguments);\n};\n\nvar real__gctx__execute_prepared = asm[\"gctx__execute_prepared\"];\nasm[\"gctx__execute_prepared\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gctx__execute_prepared.apply(null, arguments);\n};\n\nvar real__gctx__set_int = asm[\"gctx__set_int\"];\nasm[\"gctx__set_int\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gctx__set_int.apply(null, arguments);\n};\n\nvar real__gctx__set_null = asm[\"gctx__set_null\"];\nasm[\"gctx__set_null\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gctx__set_null.apply(null, arguments);\n};\n\nvar real__gctx__set_long = asm[\"gctx__set_long\"];\nasm[\"gctx__set_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gctx__set_long.apply(null, arguments);\n};\n\nvar real__gctx__set_double = asm[\"gctx__set_double\"];\nasm[\"gctx__set_double\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gctx__set_double.apply(null, arguments);\n};\n\nvar real__gctx__set_bool = asm[\"gctx__set_bool\"];\nasm[\"gctx__set_bool\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gctx__set_bool.apply(null, arguments);\n};\n\nvar real__gctx__set_object = asm[\"gctx__set_object\"];\nasm[\"gctx__set_object\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gctx__set_object.apply(null, arguments);\n};\n\nvar real__gctx__get_object = asm[\"gctx__get_object\"];\nasm[\"gctx__get_object\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gctx__get_object.apply(null, arguments);\n};\n\nvar real__gctx__get_int = asm[\"gctx__get_int\"];\nasm[\"gctx__get_int\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gctx__get_int.apply(null, arguments);\n};\n\nvar real__gctx__get_uint = asm[\"gctx__get_uint\"];\nasm[\"gctx__get_uint\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gctx__get_uint.apply(null, arguments);\n};\n\nvar real__gctx__get_long = asm[\"gctx__get_long\"];\nasm[\"gctx__get_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gctx__get_long.apply(null, arguments);\n};\n\nvar real__gctx__get_ulong = asm[\"gctx__get_ulong\"];\nasm[\"gctx__get_ulong\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gctx__get_ulong.apply(null, arguments);\n};\n\nvar real__gctx__get_double = asm[\"gctx__get_double\"];\nasm[\"gctx__get_double\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gctx__get_double.apply(null, arguments);\n};\n\nvar real__gctx__get_float = asm[\"gctx__get_float\"];\nasm[\"gctx__get_float\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gctx__get_float.apply(null, arguments);\n};\n\nvar real__gctx__get_bool = asm[\"gctx__get_bool\"];\nasm[\"gctx__get_bool\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gctx__get_bool.apply(null, arguments);\n};\n\nvar real__ggraph__create_type = asm[\"ggraph__create_type\"];\nasm[\"ggraph__create_type\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__ggraph__create_type.apply(null, arguments);\n};\n\nvar real__ggraph__declare_type = asm[\"ggraph__declare_type\"];\nasm[\"ggraph__declare_type\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__ggraph__declare_type.apply(null, arguments);\n};\n\nvar real__garray__get_int = asm[\"garray__get_int\"];\nasm[\"garray__get_int\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__garray__get_int.apply(null, arguments);\n};\n\nvar real__gstring__reset = asm[\"gstring__reset\"];\nasm[\"gstring__reset\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gstring__reset.apply(null, arguments);\n};\n\nvar real__ggraph__type = asm[\"ggraph__type\"];\nasm[\"ggraph__type\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__ggraph__type.apply(null, arguments);\n};\n\nvar real__gobject__get_slot = asm[\"gobject__get_slot\"];\nasm[\"gobject__get_slot\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gobject__get_slot.apply(null, arguments);\n};\n\nvar real__garray__set_object = asm[\"garray__set_object\"];\nasm[\"garray__set_object\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__garray__set_object.apply(null, arguments);\n};\n\nvar real__gobject__set_object = asm[\"gobject__set_object\"];\nasm[\"gobject__set_object\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gobject__set_object.apply(null, arguments);\n};\n\nvar real__ggraph__create_open_object = asm[\"ggraph__create_open_object\"];\nasm[\"ggraph__create_open_object\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__ggraph__create_open_object.apply(null, arguments);\n};\n\nvar real__ggraph__parse = asm[\"ggraph__parse\"];\nasm[\"ggraph__parse\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__ggraph__parse.apply(null, arguments);\n};\n\nvar real__ggraph__enable_debug = asm[\"ggraph__enable_debug\"];\nasm[\"ggraph__enable_debug\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__ggraph__enable_debug.apply(null, arguments);\n};\n\nvar real__ggraph__disable_debug = asm[\"ggraph__disable_debug\"];\nasm[\"ggraph__disable_debug\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__ggraph__disable_debug.apply(null, arguments);\n};\n\nvar real__ggraph__destroy = asm[\"ggraph__destroy\"];\nasm[\"ggraph__destroy\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__ggraph__destroy.apply(null, arguments);\n};\n\nvar real__gobject__set_null = asm[\"gobject__set_null\"];\nasm[\"gobject__set_null\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gobject__set_null.apply(null, arguments);\n};\n\nvar real__ggraph__is_meta = asm[\"ggraph__is_meta\"];\nasm[\"ggraph__is_meta\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__ggraph__is_meta.apply(null, arguments);\n};\n\nvar real__ggraph__create_array = asm[\"ggraph__create_array\"];\nasm[\"ggraph__create_array\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__ggraph__create_array.apply(null, arguments);\n};\n\nvar real__ggraph__create_map = asm[\"ggraph__create_map\"];\nasm[\"ggraph__create_map\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__ggraph__create_map.apply(null, arguments);\n};\n\nvar real__ggraph__create_function = asm[\"ggraph__create_function\"];\nasm[\"ggraph__create_function\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__ggraph__create_function.apply(null, arguments);\n};\n\nvar real__ggraph__create_context = asm[\"ggraph__create_context\"];\nasm[\"ggraph__create_context\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__ggraph__create_context.apply(null, arguments);\n};\n\nvar real__ggraph__add_plugin = asm[\"ggraph__add_plugin\"];\nasm[\"ggraph__add_plugin\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__ggraph__add_plugin.apply(null, arguments);\n};\n\nvar real__ggraph__configure_plugin = asm[\"ggraph__configure_plugin\"];\nasm[\"ggraph__configure_plugin\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__ggraph__configure_plugin.apply(null, arguments);\n};\n\nvar real__ggraph_export_types = asm[\"ggraph_export_types\"];\nasm[\"ggraph_export_types\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__ggraph_export_types.apply(null, arguments);\n};\n\nvar real__garray__add_int = asm[\"garray__add_int\"];\nasm[\"garray__add_int\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__garray__add_int.apply(null, arguments);\n};\n\nvar real__gstring__prepare = asm[\"gstring__prepare\"];\nasm[\"gstring__prepare\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gstring__prepare.apply(null, arguments);\n};\n\nvar real__garray__add_null = asm[\"garray__add_null\"];\nasm[\"garray__add_null\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__garray__add_null.apply(null, arguments);\n};\n\nvar real__garray__add_bool = asm[\"garray__add_bool\"];\nasm[\"garray__add_bool\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__garray__add_bool.apply(null, arguments);\n};\n\nvar real__garray__add_double = asm[\"garray__add_double\"];\nasm[\"garray__add_double\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__garray__add_double.apply(null, arguments);\n};\n\nvar real__garray__add_object = asm[\"garray__add_object\"];\nasm[\"garray__add_object\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__garray__add_object.apply(null, arguments);\n};\n\nvar real__garray__get_ulong = asm[\"garray__get_ulong\"];\nasm[\"garray__get_ulong\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__garray__get_ulong.apply(null, arguments);\n};\n\nvar real__gobject__set_double = asm[\"gobject__set_double\"];\nasm[\"gobject__set_double\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gobject__set_double.apply(null, arguments);\n};\n\nvar real__garray__size = asm[\"garray__size\"];\nasm[\"garray__size\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__garray__size.apply(null, arguments);\n};\n\nvar real__garray__set_null = asm[\"garray__set_null\"];\nasm[\"garray__set_null\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__garray__set_null.apply(null, arguments);\n};\n\nvar real__garray__set_bool = asm[\"garray__set_bool\"];\nasm[\"garray__set_bool\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__garray__set_bool.apply(null, arguments);\n};\n\nvar real__garray__set_int = asm[\"garray__set_int\"];\nasm[\"garray__set_int\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__garray__set_int.apply(null, arguments);\n};\n\nvar real__garray__set_double = asm[\"garray__set_double\"];\nasm[\"garray__set_double\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__garray__set_double.apply(null, arguments);\n};\n\nvar real__garray__get_double = asm[\"garray__get_double\"];\nasm[\"garray__get_double\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__garray__get_double.apply(null, arguments);\n};\n\nvar real__garray__get_bool = asm[\"garray__get_bool\"];\nasm[\"garray__get_bool\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__garray__get_bool.apply(null, arguments);\n};\n\nvar real__garray__get_uint = asm[\"garray__get_uint\"];\nasm[\"garray__get_uint\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__garray__get_uint.apply(null, arguments);\n};\n\nvar real__garray__get_long = asm[\"garray__get_long\"];\nasm[\"garray__get_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__garray__get_long.apply(null, arguments);\n};\n\nvar real__garray__get_float = asm[\"garray__get_float\"];\nasm[\"garray__get_float\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__garray__get_float.apply(null, arguments);\n};\n\nvar real__garray__get_object = asm[\"garray__get_object\"];\nasm[\"garray__get_object\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__garray__get_object.apply(null, arguments);\n};\n\nvar real__garray__resize = asm[\"garray__resize\"];\nasm[\"garray__resize\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__garray__resize.apply(null, arguments);\n};\n\nvar real__gobject__set_long = asm[\"gobject__set_long\"];\nasm[\"gobject__set_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gobject__set_long.apply(null, arguments);\n};\n\nvar real__gobject__get_long = asm[\"gobject__get_long\"];\nasm[\"gobject__get_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gobject__get_long.apply(null, arguments);\n};\n\nvar real__gobject__set_bool = asm[\"gobject__set_bool\"];\nasm[\"gobject__set_bool\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gobject__set_bool.apply(null, arguments);\n};\n\nvar real__gobject__set_int = asm[\"gobject__set_int\"];\nasm[\"gobject__set_int\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gobject__set_int.apply(null, arguments);\n};\n\nvar real__gobject__get_int = asm[\"gobject__get_int\"];\nasm[\"gobject__get_int\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gobject__get_int.apply(null, arguments);\n};\n\nvar real__gobject__get_uint = asm[\"gobject__get_uint\"];\nasm[\"gobject__get_uint\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gobject__get_uint.apply(null, arguments);\n};\n\nvar real__gobject__get_double = asm[\"gobject__get_double\"];\nasm[\"gobject__get_double\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gobject__get_double.apply(null, arguments);\n};\n\nvar real__gobject__get_float = asm[\"gobject__get_float\"];\nasm[\"gobject__get_float\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gobject__get_float.apply(null, arguments);\n};\n\nvar real__gobject__get_ulong = asm[\"gobject__get_ulong\"];\nasm[\"gobject__get_ulong\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gobject__get_ulong.apply(null, arguments);\n};\n\nvar real__gobject__get_object = asm[\"gobject__get_object\"];\nasm[\"gobject__get_object\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gobject__get_object.apply(null, arguments);\n};\n\nvar real__gobject__get_bool = asm[\"gobject__get_bool\"];\nasm[\"gobject__get_bool\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gobject__get_bool.apply(null, arguments);\n};\n\nvar real__gstring__get = asm[\"gstring__get\"];\nasm[\"gstring__get\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gstring__get.apply(null, arguments);\n};\n\nvar real__gstring__size = asm[\"gstring__size\"];\nasm[\"gstring__size\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gstring__size.apply(null, arguments);\n};\n\nvar real__js_read_bool = asm[\"js_read_bool\"];\nasm[\"js_read_bool\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__js_read_bool.apply(null, arguments);\n};\n\nvar real__js_read_long = asm[\"js_read_long\"];\nasm[\"js_read_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__js_read_long.apply(null, arguments);\n};\n\nvar real__js_read_ulong = asm[\"js_read_ulong\"];\nasm[\"js_read_ulong\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__js_read_ulong.apply(null, arguments);\n};\n\nvar real__js_read_double = asm[\"js_read_double\"];\nasm[\"js_read_double\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__js_read_double.apply(null, arguments);\n};\n\nvar real__js_read_int = asm[\"js_read_int\"];\nasm[\"js_read_int\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__js_read_int.apply(null, arguments);\n};\n\nvar real__ptype__to = asm[\"ptype__to\"];\nasm[\"ptype__to\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__ptype__to.apply(null, arguments);\n};\n\nvar real__slotntype__create = asm[\"slotntype__create\"];\nasm[\"slotntype__create\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__slotntype__create.apply(null, arguments);\n};\n\nvar real__slotntype__value = asm[\"slotntype__value\"];\nasm[\"slotntype__value\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__slotntype__value.apply(null, arguments);\n};\n\nvar real__slotntype__type = asm[\"slotntype__type\"];\nasm[\"slotntype__type\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__slotntype__type.apply(null, arguments);\n};\n\nvar real__gslot__from_int = asm[\"gslot__from_int\"];\nasm[\"gslot__from_int\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gslot__from_int.apply(null, arguments);\n};\n\nvar real__gslot__from_uint = asm[\"gslot__from_uint\"];\nasm[\"gslot__from_uint\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gslot__from_uint.apply(null, arguments);\n};\n\nvar real__gslot__from_float = asm[\"gslot__from_float\"];\nasm[\"gslot__from_float\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gslot__from_float.apply(null, arguments);\n};\n\nvar real__gslot__from_long = asm[\"gslot__from_long\"];\nasm[\"gslot__from_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gslot__from_long.apply(null, arguments);\n};\n\nvar real__gslot__from_ulong = asm[\"gslot__from_ulong\"];\nasm[\"gslot__from_ulong\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gslot__from_ulong.apply(null, arguments);\n};\n\nvar real__gslot__from_double = asm[\"gslot__from_double\"];\nasm[\"gslot__from_double\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gslot__from_double.apply(null, arguments);\n};\n\nvar real__gslot__from_bool = asm[\"gslot__from_bool\"];\nasm[\"gslot__from_bool\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gslot__from_bool.apply(null, arguments);\n};\n\nvar real__gslot__from_object = asm[\"gslot__from_object\"];\nasm[\"gslot__from_object\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gslot__from_object.apply(null, arguments);\n};\n\nvar real__gslot__from_reference = asm[\"gslot__from_reference\"];\nasm[\"gslot__from_reference\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gslot__from_reference.apply(null, arguments);\n};\n\nvar real__gslot__get_int = asm[\"gslot__get_int\"];\nasm[\"gslot__get_int\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gslot__get_int.apply(null, arguments);\n};\n\nvar real__gslot__get_uint = asm[\"gslot__get_uint\"];\nasm[\"gslot__get_uint\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gslot__get_uint.apply(null, arguments);\n};\n\nvar real__gslot__get_float = asm[\"gslot__get_float\"];\nasm[\"gslot__get_float\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gslot__get_float.apply(null, arguments);\n};\n\nvar real__gslot__get_long = asm[\"gslot__get_long\"];\nasm[\"gslot__get_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gslot__get_long.apply(null, arguments);\n};\n\nvar real__gslot__get_ulong = asm[\"gslot__get_ulong\"];\nasm[\"gslot__get_ulong\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gslot__get_ulong.apply(null, arguments);\n};\n\nvar real__gslot__get_double = asm[\"gslot__get_double\"];\nasm[\"gslot__get_double\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gslot__get_double.apply(null, arguments);\n};\n\nvar real__gslot__get_bool = asm[\"gslot__get_bool\"];\nasm[\"gslot__get_bool\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gslot__get_bool.apply(null, arguments);\n};\n\nvar real__gslot__get_object = asm[\"gslot__get_object\"];\nasm[\"gslot__get_object\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__gslot__get_object.apply(null, arguments);\n};\n\nvar real__ctx__get_type = asm[\"ctx__get_type\"];\nasm[\"ctx__get_type\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__ctx__get_type.apply(null, arguments);\n};\n\nvar real__ctx__wrap = asm[\"ctx__wrap\"];\nasm[\"ctx__wrap\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__ctx__wrap.apply(null, arguments);\n};\n\nvar real__ctx__set_long = asm[\"ctx__set_long\"];\nasm[\"ctx__set_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__ctx__set_long.apply(null, arguments);\n};\n\nvar real__graph__create = asm[\"graph__create\"];\nasm[\"graph__create\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__graph__create.apply(null, arguments);\n};\n\nvar real__graph__useMeta = asm[\"graph__useMeta\"];\nasm[\"graph__useMeta\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__graph__useMeta.apply(null, arguments);\n};\n\nvar real__graph__size_heap = asm[\"graph__size_heap\"];\nasm[\"graph__size_heap\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__graph__size_heap.apply(null, arguments);\n};\n\nvar real__graph__size_cache = asm[\"graph__size_cache\"];\nasm[\"graph__size_cache\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__graph__size_cache.apply(null, arguments);\n};\n\nvar real__graph__log_error = asm[\"graph__log_error\"];\nasm[\"graph__log_error\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__graph__log_error.apply(null, arguments);\n};\n\nvar real__graph__log_warning = asm[\"graph__log_warning\"];\nasm[\"graph__log_warning\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__graph__log_warning.apply(null, arguments);\n};\n\nvar real__graph__log_info = asm[\"graph__log_info\"];\nasm[\"graph__log_info\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__graph__log_info.apply(null, arguments);\n};\n\nvar real__main = asm[\"main\"];\nasm[\"main\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__main.apply(null, arguments);\n};\n\nvar real__array__graph = asm[\"array__graph\"];\nasm[\"array__graph\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__array__graph.apply(null, arguments);\n};\n\nvar real__array__offset_type = asm[\"array__offset_type\"];\nasm[\"array__offset_type\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__array__offset_type.apply(null, arguments);\n};\n\nvar real__array__set_long = asm[\"array__set_long\"];\nasm[\"array__set_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__array__set_long.apply(null, arguments);\n};\n\nvar real__array__add_long = asm[\"array__add_long\"];\nasm[\"array__add_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__array__add_long.apply(null, arguments);\n};\n\nvar real__map__graph = asm[\"map__graph\"];\nasm[\"map__graph\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__map__graph.apply(null, arguments);\n};\n\nvar real__map__get = asm[\"map__get\"];\nasm[\"map__get\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__map__get.apply(null, arguments);\n};\n\nvar real__map__mget = asm[\"map__mget\"];\nasm[\"map__mget\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__map__mget.apply(null, arguments);\n};\n\nvar real__map__set = asm[\"map__set\"];\nasm[\"map__set\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__map__set.apply(null, arguments);\n};\n\nvar real__map__put = asm[\"map__put\"];\nasm[\"map__put\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__map__put.apply(null, arguments);\n};\n\nvar real__map__remove = asm[\"map__remove\"];\nasm[\"map__remove\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__map__remove.apply(null, arguments);\n};\n\nvar real__map__size = asm[\"map__size\"];\nasm[\"map__size\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__map__size.apply(null, arguments);\n};\n\nvar real__map__foreach = asm[\"map__foreach\"];\nasm[\"map__foreach\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__map__foreach.apply(null, arguments);\n};\n\nvar real__function__set_key = asm[\"function__set_key\"];\nasm[\"function__set_key\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__function__set_key.apply(null, arguments);\n};\n\nvar real__function__name = asm[\"function__name\"];\nasm[\"function__name\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__function__name.apply(null, arguments);\n};\n\nvar real__function__parse = asm[\"function__parse\"];\nasm[\"function__parse\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__function__parse.apply(null, arguments);\n};\n\nvar real__function__pipe = asm[\"function__pipe\"];\nasm[\"function__pipe\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__function__pipe.apply(null, arguments);\n};\n\nvar real__function__pipe_external = asm[\"function__pipe_external\"];\nasm[\"function__pipe_external\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__function__pipe_external.apply(null, arguments);\n};\n\nvar real__function__add_param = asm[\"function__add_param\"];\nasm[\"function__add_param\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__function__add_param.apply(null, arguments);\n};\n\nvar real__function__add_mparam = asm[\"function__add_mparam\"];\nasm[\"function__add_mparam\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__function__add_mparam.apply(null, arguments);\n};\n\nvar real__function__execute = asm[\"function__execute\"];\nasm[\"function__execute\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__function__execute.apply(null, arguments);\n};\n\nvar real__function__create_context = asm[\"function__create_context\"];\nasm[\"function__create_context\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__function__create_context.apply(null, arguments);\n};\n\nvar real__object__graph = asm[\"object__graph\"];\nasm[\"object__graph\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__object__graph.apply(null, arguments);\n};\n\nvar real__object__type_key = asm[\"object__type_key\"];\nasm[\"object__type_key\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__object__type_key.apply(null, arguments);\n};\n\nvar real__object__key_type = asm[\"object__key_type\"];\nasm[\"object__key_type\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__object__key_type.apply(null, arguments);\n};\n\nvar real__object__type = asm[\"object__type\"];\nasm[\"object__type\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__object__type.apply(null, arguments);\n};\n\nvar real__object__json = asm[\"object__json\"];\nasm[\"object__json\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__object__json.apply(null, arguments);\n};\n\nvar real__object__to_json = asm[\"object__to_json\"];\nasm[\"object__to_json\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__object__to_json.apply(null, arguments);\n};\n\nvar real__object__set_long = asm[\"object__set_long\"];\nasm[\"object__set_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__object__set_long.apply(null, arguments);\n};\n\nvar real__params__create = asm[\"params__create\"];\nasm[\"params__create\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__params__create.apply(null, arguments);\n};\n\nvar real__params__add_int = asm[\"params__add_int\"];\nasm[\"params__add_int\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__params__add_int.apply(null, arguments);\n};\n\nvar real__params__add_long = asm[\"params__add_long\"];\nasm[\"params__add_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__params__add_long.apply(null, arguments);\n};\n\nvar real__params__add_double = asm[\"params__add_double\"];\nasm[\"params__add_double\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__params__add_double.apply(null, arguments);\n};\n\nvar real__params__add_bool = asm[\"params__add_bool\"];\nasm[\"params__add_bool\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__params__add_bool.apply(null, arguments);\n};\n\nvar real__params__add_string = asm[\"params__add_string\"];\nasm[\"params__add_string\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__params__add_string.apply(null, arguments);\n};\n\nvar real__params__add_null = asm[\"params__add_null\"];\nasm[\"params__add_null\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__params__add_null.apply(null, arguments);\n};\n\nvar real__params__add_object = asm[\"params__add_object\"];\nasm[\"params__add_object\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__params__add_object.apply(null, arguments);\n};\n\nvar real__params__destroy = asm[\"params__destroy\"];\nasm[\"params__destroy\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__params__destroy.apply(null, arguments);\n};\n\nvar real__string__set_size = asm[\"string__set_size\"];\nasm[\"string__set_size\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__string__set_size.apply(null, arguments);\n};\n\nvar real__string__copy = asm[\"string__copy\"];\nasm[\"string__copy\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__string__copy.apply(null, arguments);\n};\n\nvar real__type__create = asm[\"type__create\"];\nasm[\"type__create\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__type__create.apply(null, arguments);\n};\n\nvar real__type__name = asm[\"type__name\"];\nasm[\"type__name\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__type__name.apply(null, arguments);\n};\n\nvar real__type__key = asm[\"type__key\"];\nasm[\"type__key\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__type__key.apply(null, arguments);\n};\n\nvar real__type__is_open = asm[\"type__is_open\"];\nasm[\"type__is_open\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__type__is_open.apply(null, arguments);\n};\n\nvar real__type__seal = asm[\"type__seal\"];\nasm[\"type__seal\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__type__seal.apply(null, arguments);\n};\n\nvar real__type__graph = asm[\"type__graph\"];\nasm[\"type__graph\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__type__graph.apply(null, arguments);\n};\n\nvar real__type__declare_attribute = asm[\"type__declare_attribute\"];\nasm[\"type__declare_attribute\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__type__declare_attribute.apply(null, arguments);\n};\n\nvar real__type__declare_function = asm[\"type__declare_function\"];\nasm[\"type__declare_function\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__type__declare_function.apply(null, arguments);\n};\n\nvar real__type__declare_static_int = asm[\"type__declare_static_int\"];\nasm[\"type__declare_static_int\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__type__declare_static_int.apply(null, arguments);\n};\n\nvar real__type__declare_static_double = asm[\"type__declare_static_double\"];\nasm[\"type__declare_static_double\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__type__declare_static_double.apply(null, arguments);\n};\n\nvar real__type__declare_static_bool = asm[\"type__declare_static_bool\"];\nasm[\"type__declare_static_bool\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__type__declare_static_bool.apply(null, arguments);\n};\n\nvar real__type__declare_static_long = asm[\"type__declare_static_long\"];\nasm[\"type__declare_static_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__type__declare_static_long.apply(null, arguments);\n};\n\nvar real__type__declare_static_null = asm[\"type__declare_static_null\"];\nasm[\"type__declare_static_null\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__type__declare_static_null.apply(null, arguments);\n};\n\nvar real__type__declare_static_object = asm[\"type__declare_static_object\"];\nasm[\"type__declare_static_object\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__type__declare_static_object.apply(null, arguments);\n};\n\nvar real__ntohs = asm[\"ntohs\"];\nasm[\"ntohs\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__ntohs.apply(null, arguments);\n};\n\nvar real__htonl = asm[\"htonl\"];\nasm[\"htonl\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__htonl.apply(null, arguments);\n};\n\nvar real___get_tzname = asm[\"_get_tzname\"];\nasm[\"_get_tzname\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real___get_tzname.apply(null, arguments);\n};\n\nvar real___get_daylight = asm[\"_get_daylight\"];\nasm[\"_get_daylight\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real___get_daylight.apply(null, arguments);\n};\n\nvar real___get_timezone = asm[\"_get_timezone\"];\nasm[\"_get_timezone\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real___get_timezone.apply(null, arguments);\n};\n\nvar real__setThrew = asm[\"setThrew\"];\nasm[\"setThrew\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__setThrew.apply(null, arguments);\n};\n\nvar real__memalign = asm[\"memalign\"];\nasm[\"memalign\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__memalign.apply(null, arguments);\n};\n\nvar real__emscripten_builtin_free = asm[\"emscripten_builtin_free\"];\nasm[\"emscripten_builtin_free\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__emscripten_builtin_free.apply(null, arguments);\n};\n\nvar real__emscripten_builtin_memalign = asm[\"emscripten_builtin_memalign\"];\nasm[\"emscripten_builtin_memalign\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__emscripten_builtin_memalign.apply(null, arguments);\n};\n\nvar real__emscripten_main_thread_process_queued_calls = asm[\"emscripten_main_thread_process_queued_calls\"];\nasm[\"emscripten_main_thread_process_queued_calls\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real__emscripten_main_thread_process_queued_calls.apply(null, arguments);\n};\n\nvar real____set_stack_limit = asm[\"__set_stack_limit\"];\nasm[\"__set_stack_limit\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real____set_stack_limit.apply(null, arguments);\n};\n\nvar real_stackSave = asm[\"stackSave\"];\nasm[\"stackSave\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_stackSave.apply(null, arguments);\n};\n\nvar real_stackAlloc = asm[\"stackAlloc\"];\nasm[\"stackAlloc\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_stackAlloc.apply(null, arguments);\n};\n\nvar real_stackRestore = asm[\"stackRestore\"];\nasm[\"stackRestore\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_stackRestore.apply(null, arguments);\n};\n\nvar real___growWasmMemory = asm[\"__growWasmMemory\"];\nasm[\"__growWasmMemory\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real___growWasmMemory.apply(null, arguments);\n};\n\nvar real_dynCall_viii = asm[\"dynCall_viii\"];\nasm[\"dynCall_viii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_dynCall_viii.apply(null, arguments);\n};\n\nvar real_dynCall_vii = asm[\"dynCall_vii\"];\nasm[\"dynCall_vii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_dynCall_vii.apply(null, arguments);\n};\n\nvar real_dynCall_vi = asm[\"dynCall_vi\"];\nasm[\"dynCall_vi\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_dynCall_vi.apply(null, arguments);\n};\n\nvar real_dynCall_ii = asm[\"dynCall_ii\"];\nasm[\"dynCall_ii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_dynCall_ii.apply(null, arguments);\n};\n\nvar real_dynCall_viiji = asm[\"dynCall_viiji\"];\nasm[\"dynCall_viiji\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_dynCall_viiji.apply(null, arguments);\n};\n\nvar real_dynCall_viij = asm[\"dynCall_viij\"];\nasm[\"dynCall_viij\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_dynCall_viij.apply(null, arguments);\n};\n\nvar real_dynCall_iiii = asm[\"dynCall_iiii\"];\nasm[\"dynCall_iiii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_dynCall_iiii.apply(null, arguments);\n};\n\nvar real_dynCall_ji = asm[\"dynCall_ji\"];\nasm[\"dynCall_ji\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_dynCall_ji.apply(null, arguments);\n};\n\nvar real_dynCall_iii = asm[\"dynCall_iii\"];\nasm[\"dynCall_iii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_dynCall_iii.apply(null, arguments);\n};\n\nvar real_dynCall_iiiii = asm[\"dynCall_iiiii\"];\nasm[\"dynCall_iiiii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_dynCall_iiiii.apply(null, arguments);\n};\n\nvar real_dynCall_iiiiii = asm[\"dynCall_iiiiii\"];\nasm[\"dynCall_iiiiii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_dynCall_iiiiii.apply(null, arguments);\n};\n\nvar real_dynCall_jiji = asm[\"dynCall_jiji\"];\nasm[\"dynCall_jiji\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_dynCall_jiji.apply(null, arguments);\n};\n\nvar real_dynCall_iidiiii = asm[\"dynCall_iidiiii\"];\nasm[\"dynCall_iidiiii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return real_dynCall_iidiiii.apply(null, arguments);\n};\n\nModule[\"asm\"] = asm;\nvar ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"__wasm_call_ctors\"].apply(null, arguments)\n};\n\nvar _malloc = Module[\"_malloc\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"malloc\"].apply(null, arguments)\n};\n\nvar _ggraph__declare_meta = Module[\"_ggraph__declare_meta\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"ggraph__declare_meta\"].apply(null, arguments)\n};\n\nvar _free = Module[\"_free\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"free\"].apply(null, arguments)\n};\n\nvar _gstring__add_raw_string = Module[\"_gstring__add_raw_string\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gstring__add_raw_string\"].apply(null, arguments)\n};\n\nvar _gstring__close = Module[\"_gstring__close\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gstring__close\"].apply(null, arguments)\n};\n\nvar _ggraph__meta = Module[\"_ggraph__meta\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"ggraph__meta\"].apply(null, arguments)\n};\n\nvar _ggraph__create_string = Module[\"_ggraph__create_string\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"ggraph__create_string\"].apply(null, arguments)\n};\n\nvar _gobject__un_mark = Module[\"_gobject__un_mark\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gobject__un_mark\"].apply(null, arguments)\n};\n\nvar _gctx__ordinal = Module[\"_gctx__ordinal\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gctx__ordinal\"].apply(null, arguments)\n};\n\nvar _htons = Module[\"_htons\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"htons\"].apply(null, arguments)\n};\n\nvar _gctx__json = Module[\"_gctx__json\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gctx__json\"].apply(null, arguments)\n};\n\nvar _gctx__prepare = Module[\"_gctx__prepare\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gctx__prepare\"].apply(null, arguments)\n};\n\nvar _gctx__execute_prepared = Module[\"_gctx__execute_prepared\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gctx__execute_prepared\"].apply(null, arguments)\n};\n\nvar _gctx__set_int = Module[\"_gctx__set_int\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gctx__set_int\"].apply(null, arguments)\n};\n\nvar _gctx__set_null = Module[\"_gctx__set_null\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gctx__set_null\"].apply(null, arguments)\n};\n\nvar _gctx__set_long = Module[\"_gctx__set_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gctx__set_long\"].apply(null, arguments)\n};\n\nvar _gctx__set_double = Module[\"_gctx__set_double\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gctx__set_double\"].apply(null, arguments)\n};\n\nvar _gctx__set_bool = Module[\"_gctx__set_bool\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gctx__set_bool\"].apply(null, arguments)\n};\n\nvar _gctx__set_object = Module[\"_gctx__set_object\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gctx__set_object\"].apply(null, arguments)\n};\n\nvar _gctx__get_object = Module[\"_gctx__get_object\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gctx__get_object\"].apply(null, arguments)\n};\n\nvar _gctx__get_int = Module[\"_gctx__get_int\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gctx__get_int\"].apply(null, arguments)\n};\n\nvar _gctx__get_uint = Module[\"_gctx__get_uint\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gctx__get_uint\"].apply(null, arguments)\n};\n\nvar _gctx__get_long = Module[\"_gctx__get_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gctx__get_long\"].apply(null, arguments)\n};\n\nvar _gctx__get_ulong = Module[\"_gctx__get_ulong\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gctx__get_ulong\"].apply(null, arguments)\n};\n\nvar _gctx__get_double = Module[\"_gctx__get_double\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gctx__get_double\"].apply(null, arguments)\n};\n\nvar _gctx__get_float = Module[\"_gctx__get_float\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gctx__get_float\"].apply(null, arguments)\n};\n\nvar _gctx__get_bool = Module[\"_gctx__get_bool\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gctx__get_bool\"].apply(null, arguments)\n};\n\nvar _ggraph__create_type = Module[\"_ggraph__create_type\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"ggraph__create_type\"].apply(null, arguments)\n};\n\nvar _ggraph__declare_type = Module[\"_ggraph__declare_type\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"ggraph__declare_type\"].apply(null, arguments)\n};\n\nvar _garray__get_int = Module[\"_garray__get_int\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"garray__get_int\"].apply(null, arguments)\n};\n\nvar _gstring__reset = Module[\"_gstring__reset\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gstring__reset\"].apply(null, arguments)\n};\n\nvar _ggraph__type = Module[\"_ggraph__type\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"ggraph__type\"].apply(null, arguments)\n};\n\nvar _gobject__get_slot = Module[\"_gobject__get_slot\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gobject__get_slot\"].apply(null, arguments)\n};\n\nvar _garray__set_object = Module[\"_garray__set_object\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"garray__set_object\"].apply(null, arguments)\n};\n\nvar _gobject__set_object = Module[\"_gobject__set_object\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gobject__set_object\"].apply(null, arguments)\n};\n\nvar _ggraph__create_open_object = Module[\"_ggraph__create_open_object\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"ggraph__create_open_object\"].apply(null, arguments)\n};\n\nvar _ggraph__parse = Module[\"_ggraph__parse\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"ggraph__parse\"].apply(null, arguments)\n};\n\nvar _ggraph__enable_debug = Module[\"_ggraph__enable_debug\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"ggraph__enable_debug\"].apply(null, arguments)\n};\n\nvar _ggraph__disable_debug = Module[\"_ggraph__disable_debug\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"ggraph__disable_debug\"].apply(null, arguments)\n};\n\nvar _ggraph__destroy = Module[\"_ggraph__destroy\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"ggraph__destroy\"].apply(null, arguments)\n};\n\nvar _gobject__set_null = Module[\"_gobject__set_null\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gobject__set_null\"].apply(null, arguments)\n};\n\nvar _ggraph__is_meta = Module[\"_ggraph__is_meta\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"ggraph__is_meta\"].apply(null, arguments)\n};\n\nvar _ggraph__create_array = Module[\"_ggraph__create_array\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"ggraph__create_array\"].apply(null, arguments)\n};\n\nvar _ggraph__create_map = Module[\"_ggraph__create_map\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"ggraph__create_map\"].apply(null, arguments)\n};\n\nvar _ggraph__create_function = Module[\"_ggraph__create_function\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"ggraph__create_function\"].apply(null, arguments)\n};\n\nvar _ggraph__create_context = Module[\"_ggraph__create_context\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"ggraph__create_context\"].apply(null, arguments)\n};\n\nvar _ggraph__add_plugin = Module[\"_ggraph__add_plugin\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"ggraph__add_plugin\"].apply(null, arguments)\n};\n\nvar _ggraph__configure_plugin = Module[\"_ggraph__configure_plugin\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"ggraph__configure_plugin\"].apply(null, arguments)\n};\n\nvar _ggraph_export_types = Module[\"_ggraph_export_types\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"ggraph_export_types\"].apply(null, arguments)\n};\n\nvar _garray__add_int = Module[\"_garray__add_int\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"garray__add_int\"].apply(null, arguments)\n};\n\nvar _gstring__prepare = Module[\"_gstring__prepare\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gstring__prepare\"].apply(null, arguments)\n};\n\nvar _garray__add_null = Module[\"_garray__add_null\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"garray__add_null\"].apply(null, arguments)\n};\n\nvar _garray__add_bool = Module[\"_garray__add_bool\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"garray__add_bool\"].apply(null, arguments)\n};\n\nvar _garray__add_double = Module[\"_garray__add_double\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"garray__add_double\"].apply(null, arguments)\n};\n\nvar _garray__add_object = Module[\"_garray__add_object\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"garray__add_object\"].apply(null, arguments)\n};\n\nvar _garray__get_ulong = Module[\"_garray__get_ulong\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"garray__get_ulong\"].apply(null, arguments)\n};\n\nvar _gobject__set_double = Module[\"_gobject__set_double\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gobject__set_double\"].apply(null, arguments)\n};\n\nvar _garray__size = Module[\"_garray__size\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"garray__size\"].apply(null, arguments)\n};\n\nvar _garray__set_null = Module[\"_garray__set_null\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"garray__set_null\"].apply(null, arguments)\n};\n\nvar _garray__set_bool = Module[\"_garray__set_bool\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"garray__set_bool\"].apply(null, arguments)\n};\n\nvar _garray__set_int = Module[\"_garray__set_int\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"garray__set_int\"].apply(null, arguments)\n};\n\nvar _garray__set_double = Module[\"_garray__set_double\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"garray__set_double\"].apply(null, arguments)\n};\n\nvar _garray__get_double = Module[\"_garray__get_double\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"garray__get_double\"].apply(null, arguments)\n};\n\nvar _garray__get_bool = Module[\"_garray__get_bool\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"garray__get_bool\"].apply(null, arguments)\n};\n\nvar _garray__get_uint = Module[\"_garray__get_uint\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"garray__get_uint\"].apply(null, arguments)\n};\n\nvar _garray__get_long = Module[\"_garray__get_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"garray__get_long\"].apply(null, arguments)\n};\n\nvar _garray__get_float = Module[\"_garray__get_float\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"garray__get_float\"].apply(null, arguments)\n};\n\nvar _garray__get_object = Module[\"_garray__get_object\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"garray__get_object\"].apply(null, arguments)\n};\n\nvar _garray__resize = Module[\"_garray__resize\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"garray__resize\"].apply(null, arguments)\n};\n\nvar _gobject__set_long = Module[\"_gobject__set_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gobject__set_long\"].apply(null, arguments)\n};\n\nvar _gobject__get_long = Module[\"_gobject__get_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gobject__get_long\"].apply(null, arguments)\n};\n\nvar _gobject__set_bool = Module[\"_gobject__set_bool\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gobject__set_bool\"].apply(null, arguments)\n};\n\nvar _gobject__set_int = Module[\"_gobject__set_int\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gobject__set_int\"].apply(null, arguments)\n};\n\nvar _gobject__get_int = Module[\"_gobject__get_int\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gobject__get_int\"].apply(null, arguments)\n};\n\nvar _gobject__get_uint = Module[\"_gobject__get_uint\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gobject__get_uint\"].apply(null, arguments)\n};\n\nvar _gobject__get_double = Module[\"_gobject__get_double\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gobject__get_double\"].apply(null, arguments)\n};\n\nvar _gobject__get_float = Module[\"_gobject__get_float\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gobject__get_float\"].apply(null, arguments)\n};\n\nvar _gobject__get_ulong = Module[\"_gobject__get_ulong\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gobject__get_ulong\"].apply(null, arguments)\n};\n\nvar _gobject__get_object = Module[\"_gobject__get_object\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gobject__get_object\"].apply(null, arguments)\n};\n\nvar _gobject__get_bool = Module[\"_gobject__get_bool\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gobject__get_bool\"].apply(null, arguments)\n};\n\nvar _gstring__get = Module[\"_gstring__get\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gstring__get\"].apply(null, arguments)\n};\n\nvar _gstring__size = Module[\"_gstring__size\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gstring__size\"].apply(null, arguments)\n};\n\nvar _js_read_bool = Module[\"_js_read_bool\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"js_read_bool\"].apply(null, arguments)\n};\n\nvar _js_read_long = Module[\"_js_read_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"js_read_long\"].apply(null, arguments)\n};\n\nvar _js_read_ulong = Module[\"_js_read_ulong\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"js_read_ulong\"].apply(null, arguments)\n};\n\nvar _js_read_double = Module[\"_js_read_double\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"js_read_double\"].apply(null, arguments)\n};\n\nvar _js_read_int = Module[\"_js_read_int\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"js_read_int\"].apply(null, arguments)\n};\n\nvar _ptype__to = Module[\"_ptype__to\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"ptype__to\"].apply(null, arguments)\n};\n\nvar _slotntype__create = Module[\"_slotntype__create\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"slotntype__create\"].apply(null, arguments)\n};\n\nvar _slotntype__value = Module[\"_slotntype__value\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"slotntype__value\"].apply(null, arguments)\n};\n\nvar _slotntype__type = Module[\"_slotntype__type\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"slotntype__type\"].apply(null, arguments)\n};\n\nvar _gslot__from_int = Module[\"_gslot__from_int\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gslot__from_int\"].apply(null, arguments)\n};\n\nvar _gslot__from_uint = Module[\"_gslot__from_uint\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gslot__from_uint\"].apply(null, arguments)\n};\n\nvar _gslot__from_float = Module[\"_gslot__from_float\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gslot__from_float\"].apply(null, arguments)\n};\n\nvar _gslot__from_long = Module[\"_gslot__from_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gslot__from_long\"].apply(null, arguments)\n};\n\nvar _gslot__from_ulong = Module[\"_gslot__from_ulong\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gslot__from_ulong\"].apply(null, arguments)\n};\n\nvar _gslot__from_double = Module[\"_gslot__from_double\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gslot__from_double\"].apply(null, arguments)\n};\n\nvar _gslot__from_bool = Module[\"_gslot__from_bool\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gslot__from_bool\"].apply(null, arguments)\n};\n\nvar _gslot__from_object = Module[\"_gslot__from_object\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gslot__from_object\"].apply(null, arguments)\n};\n\nvar _gslot__from_reference = Module[\"_gslot__from_reference\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gslot__from_reference\"].apply(null, arguments)\n};\n\nvar _gslot__get_int = Module[\"_gslot__get_int\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gslot__get_int\"].apply(null, arguments)\n};\n\nvar _gslot__get_uint = Module[\"_gslot__get_uint\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gslot__get_uint\"].apply(null, arguments)\n};\n\nvar _gslot__get_float = Module[\"_gslot__get_float\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gslot__get_float\"].apply(null, arguments)\n};\n\nvar _gslot__get_long = Module[\"_gslot__get_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gslot__get_long\"].apply(null, arguments)\n};\n\nvar _gslot__get_ulong = Module[\"_gslot__get_ulong\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gslot__get_ulong\"].apply(null, arguments)\n};\n\nvar _gslot__get_double = Module[\"_gslot__get_double\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gslot__get_double\"].apply(null, arguments)\n};\n\nvar _gslot__get_bool = Module[\"_gslot__get_bool\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gslot__get_bool\"].apply(null, arguments)\n};\n\nvar _gslot__get_object = Module[\"_gslot__get_object\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"gslot__get_object\"].apply(null, arguments)\n};\n\nvar _ctx__get_type = Module[\"_ctx__get_type\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"ctx__get_type\"].apply(null, arguments)\n};\n\nvar _ctx__wrap = Module[\"_ctx__wrap\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"ctx__wrap\"].apply(null, arguments)\n};\n\nvar _ctx__set_long = Module[\"_ctx__set_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"ctx__set_long\"].apply(null, arguments)\n};\n\nvar _graph__create = Module[\"_graph__create\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"graph__create\"].apply(null, arguments)\n};\n\nvar _graph__useMeta = Module[\"_graph__useMeta\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"graph__useMeta\"].apply(null, arguments)\n};\n\nvar _graph__size_heap = Module[\"_graph__size_heap\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"graph__size_heap\"].apply(null, arguments)\n};\n\nvar _graph__size_cache = Module[\"_graph__size_cache\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"graph__size_cache\"].apply(null, arguments)\n};\n\nvar _graph__log_error = Module[\"_graph__log_error\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"graph__log_error\"].apply(null, arguments)\n};\n\nvar _graph__log_warning = Module[\"_graph__log_warning\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"graph__log_warning\"].apply(null, arguments)\n};\n\nvar _graph__log_info = Module[\"_graph__log_info\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"graph__log_info\"].apply(null, arguments)\n};\n\nvar _main = Module[\"_main\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"main\"].apply(null, arguments)\n};\n\nvar _array__graph = Module[\"_array__graph\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"array__graph\"].apply(null, arguments)\n};\n\nvar _array__offset_type = Module[\"_array__offset_type\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"array__offset_type\"].apply(null, arguments)\n};\n\nvar _array__set_long = Module[\"_array__set_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"array__set_long\"].apply(null, arguments)\n};\n\nvar _array__add_long = Module[\"_array__add_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"array__add_long\"].apply(null, arguments)\n};\n\nvar _map__graph = Module[\"_map__graph\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"map__graph\"].apply(null, arguments)\n};\n\nvar _map__get = Module[\"_map__get\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"map__get\"].apply(null, arguments)\n};\n\nvar _map__mget = Module[\"_map__mget\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"map__mget\"].apply(null, arguments)\n};\n\nvar _map__set = Module[\"_map__set\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"map__set\"].apply(null, arguments)\n};\n\nvar _map__put = Module[\"_map__put\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"map__put\"].apply(null, arguments)\n};\n\nvar _map__remove = Module[\"_map__remove\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"map__remove\"].apply(null, arguments)\n};\n\nvar _map__size = Module[\"_map__size\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"map__size\"].apply(null, arguments)\n};\n\nvar _map__foreach = Module[\"_map__foreach\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"map__foreach\"].apply(null, arguments)\n};\n\nvar _function__set_key = Module[\"_function__set_key\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"function__set_key\"].apply(null, arguments)\n};\n\nvar _function__name = Module[\"_function__name\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"function__name\"].apply(null, arguments)\n};\n\nvar _function__parse = Module[\"_function__parse\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"function__parse\"].apply(null, arguments)\n};\n\nvar _function__pipe = Module[\"_function__pipe\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"function__pipe\"].apply(null, arguments)\n};\n\nvar _function__pipe_external = Module[\"_function__pipe_external\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"function__pipe_external\"].apply(null, arguments)\n};\n\nvar _function__add_param = Module[\"_function__add_param\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"function__add_param\"].apply(null, arguments)\n};\n\nvar _function__add_mparam = Module[\"_function__add_mparam\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"function__add_mparam\"].apply(null, arguments)\n};\n\nvar _function__execute = Module[\"_function__execute\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"function__execute\"].apply(null, arguments)\n};\n\nvar _function__create_context = Module[\"_function__create_context\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"function__create_context\"].apply(null, arguments)\n};\n\nvar _object__graph = Module[\"_object__graph\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"object__graph\"].apply(null, arguments)\n};\n\nvar _object__type_key = Module[\"_object__type_key\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"object__type_key\"].apply(null, arguments)\n};\n\nvar _object__key_type = Module[\"_object__key_type\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"object__key_type\"].apply(null, arguments)\n};\n\nvar _object__type = Module[\"_object__type\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"object__type\"].apply(null, arguments)\n};\n\nvar _object__json = Module[\"_object__json\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"object__json\"].apply(null, arguments)\n};\n\nvar _object__to_json = Module[\"_object__to_json\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"object__to_json\"].apply(null, arguments)\n};\n\nvar _object__set_long = Module[\"_object__set_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"object__set_long\"].apply(null, arguments)\n};\n\nvar _params__create = Module[\"_params__create\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"params__create\"].apply(null, arguments)\n};\n\nvar _params__add_int = Module[\"_params__add_int\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"params__add_int\"].apply(null, arguments)\n};\n\nvar _params__add_long = Module[\"_params__add_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"params__add_long\"].apply(null, arguments)\n};\n\nvar _params__add_double = Module[\"_params__add_double\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"params__add_double\"].apply(null, arguments)\n};\n\nvar _params__add_bool = Module[\"_params__add_bool\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"params__add_bool\"].apply(null, arguments)\n};\n\nvar _params__add_string = Module[\"_params__add_string\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"params__add_string\"].apply(null, arguments)\n};\n\nvar _params__add_null = Module[\"_params__add_null\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"params__add_null\"].apply(null, arguments)\n};\n\nvar _params__add_object = Module[\"_params__add_object\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"params__add_object\"].apply(null, arguments)\n};\n\nvar _params__destroy = Module[\"_params__destroy\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"params__destroy\"].apply(null, arguments)\n};\n\nvar _string__set_size = Module[\"_string__set_size\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"string__set_size\"].apply(null, arguments)\n};\n\nvar _string__copy = Module[\"_string__copy\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"string__copy\"].apply(null, arguments)\n};\n\nvar _type__create = Module[\"_type__create\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"type__create\"].apply(null, arguments)\n};\n\nvar _type__name = Module[\"_type__name\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"type__name\"].apply(null, arguments)\n};\n\nvar _type__key = Module[\"_type__key\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"type__key\"].apply(null, arguments)\n};\n\nvar _type__is_open = Module[\"_type__is_open\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"type__is_open\"].apply(null, arguments)\n};\n\nvar _type__seal = Module[\"_type__seal\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"type__seal\"].apply(null, arguments)\n};\n\nvar _type__graph = Module[\"_type__graph\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"type__graph\"].apply(null, arguments)\n};\n\nvar _type__declare_attribute = Module[\"_type__declare_attribute\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"type__declare_attribute\"].apply(null, arguments)\n};\n\nvar _type__declare_function = Module[\"_type__declare_function\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"type__declare_function\"].apply(null, arguments)\n};\n\nvar _type__declare_static_int = Module[\"_type__declare_static_int\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"type__declare_static_int\"].apply(null, arguments)\n};\n\nvar _type__declare_static_double = Module[\"_type__declare_static_double\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"type__declare_static_double\"].apply(null, arguments)\n};\n\nvar _type__declare_static_bool = Module[\"_type__declare_static_bool\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"type__declare_static_bool\"].apply(null, arguments)\n};\n\nvar _type__declare_static_long = Module[\"_type__declare_static_long\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"type__declare_static_long\"].apply(null, arguments)\n};\n\nvar _type__declare_static_null = Module[\"_type__declare_static_null\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"type__declare_static_null\"].apply(null, arguments)\n};\n\nvar _type__declare_static_object = Module[\"_type__declare_static_object\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"type__declare_static_object\"].apply(null, arguments)\n};\n\nvar _ntohs = Module[\"_ntohs\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"ntohs\"].apply(null, arguments)\n};\n\nvar _htonl = Module[\"_htonl\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"htonl\"].apply(null, arguments)\n};\n\nvar __get_tzname = Module[\"__get_tzname\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"_get_tzname\"].apply(null, arguments)\n};\n\nvar __get_daylight = Module[\"__get_daylight\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"_get_daylight\"].apply(null, arguments)\n};\n\nvar __get_timezone = Module[\"__get_timezone\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"_get_timezone\"].apply(null, arguments)\n};\n\nvar _setThrew = Module[\"_setThrew\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"setThrew\"].apply(null, arguments)\n};\n\nvar _memalign = Module[\"_memalign\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"memalign\"].apply(null, arguments)\n};\n\nvar _emscripten_builtin_free = Module[\"_emscripten_builtin_free\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"emscripten_builtin_free\"].apply(null, arguments)\n};\n\nvar _emscripten_builtin_memalign = Module[\"_emscripten_builtin_memalign\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"emscripten_builtin_memalign\"].apply(null, arguments)\n};\n\nvar _emscripten_main_thread_process_queued_calls = Module[\"_emscripten_main_thread_process_queued_calls\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"emscripten_main_thread_process_queued_calls\"].apply(null, arguments)\n};\n\nvar ___set_stack_limit = Module[\"___set_stack_limit\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"__set_stack_limit\"].apply(null, arguments)\n};\n\nvar stackSave = Module[\"stackSave\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"stackSave\"].apply(null, arguments)\n};\n\nvar stackAlloc = Module[\"stackAlloc\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"stackAlloc\"].apply(null, arguments)\n};\n\nvar stackRestore = Module[\"stackRestore\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"stackRestore\"].apply(null, arguments)\n};\n\nvar __growWasmMemory = Module[\"__growWasmMemory\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"__growWasmMemory\"].apply(null, arguments)\n};\n\nvar dynCall_viii = Module[\"dynCall_viii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_viii\"].apply(null, arguments)\n};\n\nvar dynCall_vii = Module[\"dynCall_vii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_vii\"].apply(null, arguments)\n};\n\nvar dynCall_vi = Module[\"dynCall_vi\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_vi\"].apply(null, arguments)\n};\n\nvar dynCall_ii = Module[\"dynCall_ii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_ii\"].apply(null, arguments)\n};\n\nvar dynCall_viiji = Module[\"dynCall_viiji\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_viiji\"].apply(null, arguments)\n};\n\nvar dynCall_viij = Module[\"dynCall_viij\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_viij\"].apply(null, arguments)\n};\n\nvar dynCall_iiii = Module[\"dynCall_iiii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_iiii\"].apply(null, arguments)\n};\n\nvar dynCall_ji = Module[\"dynCall_ji\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_ji\"].apply(null, arguments)\n};\n\nvar dynCall_iii = Module[\"dynCall_iii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_iii\"].apply(null, arguments)\n};\n\nvar dynCall_iiiii = Module[\"dynCall_iiiii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_iiiii\"].apply(null, arguments)\n};\n\nvar dynCall_iiiiii = Module[\"dynCall_iiiiii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_iiiiii\"].apply(null, arguments)\n};\n\nvar dynCall_jiji = Module[\"dynCall_jiji\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_jiji\"].apply(null, arguments)\n};\n\nvar dynCall_iidiiii = Module[\"dynCall_iidiiii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_iidiiii\"].apply(null, arguments)\n};\n\n\n\n\n// === Auto-generated postamble setup entry stuff ===\n\nModule['asm'] = asm;\n\nif (!Object.getOwnPropertyDescriptor(Module, \"intArrayFromString\")) Module[\"intArrayFromString\"] = function() { abort(\"'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"intArrayToString\")) Module[\"intArrayToString\"] = function() { abort(\"'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"ccall\")) Module[\"ccall\"] = function() { abort(\"'ccall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"cwrap\")) Module[\"cwrap\"] = function() { abort(\"'cwrap' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"setValue\")) Module[\"setValue\"] = function() { abort(\"'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"getValue\")) Module[\"getValue\"] = function() { abort(\"'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"allocate\")) Module[\"allocate\"] = function() { abort(\"'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"getMemory\")) Module[\"getMemory\"] = function() { abort(\"'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"AsciiToString\")) Module[\"AsciiToString\"] = function() { abort(\"'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToAscii\")) Module[\"stringToAscii\"] = function() { abort(\"'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"UTF8ArrayToString\")) Module[\"UTF8ArrayToString\"] = function() { abort(\"'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nModule[\"UTF8ToString\"] = UTF8ToString;\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF8Array\")) Module[\"stringToUTF8Array\"] = function() { abort(\"'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nModule[\"stringToUTF8\"] = stringToUTF8;\nif (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF8\")) Module[\"lengthBytesUTF8\"] = function() { abort(\"'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"UTF16ToString\")) Module[\"UTF16ToString\"] = function() { abort(\"'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF16\")) Module[\"stringToUTF16\"] = function() { abort(\"'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF16\")) Module[\"lengthBytesUTF16\"] = function() { abort(\"'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"UTF32ToString\")) Module[\"UTF32ToString\"] = function() { abort(\"'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF32\")) Module[\"stringToUTF32\"] = function() { abort(\"'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF32\")) Module[\"lengthBytesUTF32\"] = function() { abort(\"'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nModule[\"allocateUTF8\"] = allocateUTF8;\nif (!Object.getOwnPropertyDescriptor(Module, \"stackTrace\")) Module[\"stackTrace\"] = function() { abort(\"'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnPreRun\")) Module[\"addOnPreRun\"] = function() { abort(\"'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnInit\")) Module[\"addOnInit\"] = function() { abort(\"'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnPreMain\")) Module[\"addOnPreMain\"] = function() { abort(\"'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnExit\")) Module[\"addOnExit\"] = function() { abort(\"'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnPostRun\")) Module[\"addOnPostRun\"] = function() { abort(\"'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"writeStringToMemory\")) Module[\"writeStringToMemory\"] = function() { abort(\"'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"writeArrayToMemory\")) Module[\"writeArrayToMemory\"] = function() { abort(\"'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"writeAsciiToMemory\")) Module[\"writeAsciiToMemory\"] = function() { abort(\"'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"addRunDependency\")) Module[\"addRunDependency\"] = function() { abort(\"'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"removeRunDependency\")) Module[\"removeRunDependency\"] = function() { abort(\"'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"ENV\")) Module[\"ENV\"] = function() { abort(\"'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS\")) Module[\"FS\"] = function() { abort(\"'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createFolder\")) Module[\"FS_createFolder\"] = function() { abort(\"'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createPath\")) Module[\"FS_createPath\"] = function() { abort(\"'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createDataFile\")) Module[\"FS_createDataFile\"] = function() { abort(\"'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createPreloadedFile\")) Module[\"FS_createPreloadedFile\"] = function() { abort(\"'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createLazyFile\")) Module[\"FS_createLazyFile\"] = function() { abort(\"'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createLink\")) Module[\"FS_createLink\"] = function() { abort(\"'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createDevice\")) Module[\"FS_createDevice\"] = function() { abort(\"'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_unlink\")) Module[\"FS_unlink\"] = function() { abort(\"'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"GL\")) Module[\"GL\"] = function() { abort(\"'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"dynamicAlloc\")) Module[\"dynamicAlloc\"] = function() { abort(\"'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"loadDynamicLibrary\")) Module[\"loadDynamicLibrary\"] = function() { abort(\"'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"loadWebAssemblyModule\")) Module[\"loadWebAssemblyModule\"] = function() { abort(\"'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"getLEB\")) Module[\"getLEB\"] = function() { abort(\"'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"getFunctionTables\")) Module[\"getFunctionTables\"] = function() { abort(\"'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"alignFunctionTables\")) Module[\"alignFunctionTables\"] = function() { abort(\"'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"registerFunctions\")) Module[\"registerFunctions\"] = function() { abort(\"'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"addFunction\")) Module[\"addFunction\"] = function() { abort(\"'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"removeFunction\")) Module[\"removeFunction\"] = function() { abort(\"'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"getFuncWrapper\")) Module[\"getFuncWrapper\"] = function() { abort(\"'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"prettyPrint\")) Module[\"prettyPrint\"] = function() { abort(\"'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"makeBigInt\")) Module[\"makeBigInt\"] = function() { abort(\"'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"dynCall\")) Module[\"dynCall\"] = function() { abort(\"'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"getCompilerSetting\")) Module[\"getCompilerSetting\"] = function() { abort(\"'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"print\")) Module[\"print\"] = function() { abort(\"'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"printErr\")) Module[\"printErr\"] = function() { abort(\"'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nModule[\"getTempRet0\"] = getTempRet0;\nif (!Object.getOwnPropertyDescriptor(Module, \"setTempRet0\")) Module[\"setTempRet0\"] = function() { abort(\"'setTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"callMain\")) Module[\"callMain\"] = function() { abort(\"'callMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"abort\")) Module[\"abort\"] = function() { abort(\"'abort' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"warnOnce\")) Module[\"warnOnce\"] = function() { abort(\"'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stackSave\")) Module[\"stackSave\"] = function() { abort(\"'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stackRestore\")) Module[\"stackRestore\"] = function() { abort(\"'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stackAlloc\")) Module[\"stackAlloc\"] = function() { abort(\"'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nModule[\"writeStackCookie\"] = writeStackCookie;\nModule[\"checkStackCookie\"] = checkStackCookie;\nModule[\"abortStackOverflow\"] = abortStackOverflow;if (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_NORMAL\")) Object.defineProperty(Module, \"ALLOC_NORMAL\", { configurable: true, get: function() { abort(\"'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\nif (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_STACK\")) Object.defineProperty(Module, \"ALLOC_STACK\", { configurable: true, get: function() { abort(\"'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\nif (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_DYNAMIC\")) Object.defineProperty(Module, \"ALLOC_DYNAMIC\", { configurable: true, get: function() { abort(\"'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\nif (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_NONE\")) Object.defineProperty(Module, \"ALLOC_NONE\", { configurable: true, get: function() { abort(\"'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\nif (!Object.getOwnPropertyDescriptor(Module, \"calledRun\")) Object.defineProperty(Module, \"calledRun\", { configurable: true, get: function() { abort(\"'calledRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") } });\n\n\n\nvar calledRun;\n\n// Modularize mode returns a function, which can be called to\n// create instances. The instances provide a then() method,\n// must like a Promise, that receives a callback. The callback\n// is called when the module is ready to run, with the module\n// as a parameter. (Like a Promise, it also returns the module\n// so you can use the output of .then(..)).\nModule['then'] = function(func) {\n  // We may already be ready to run code at this time. if\n  // so, just queue a call to the callback.\n  if (calledRun) {\n    func(Module);\n  } else {\n    // we are not ready to call then() yet. we must call it\n    // at the same time we would call onRuntimeInitialized.\n    var old = Module['onRuntimeInitialized'];\n    Module['onRuntimeInitialized'] = function() {\n      if (old) old();\n      func(Module);\n    };\n  }\n  return Module;\n};\n\n/**\n * @constructor\n * @this {ExitStatus}\n */\nfunction ExitStatus(status) {\n  this.name = \"ExitStatus\";\n  this.message = \"Program terminated with exit(\" + status + \")\";\n  this.status = status;\n}\n\nvar calledMain = false;\n\n\ndependenciesFulfilled = function runCaller() {\n  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n  if (!calledRun) run();\n  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n};\n\nfunction callMain(args) {\n  assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on Module[\"onRuntimeInitialized\"])');\n  assert(__ATPRERUN__.length == 0, 'cannot call main when preRun functions remain to be called');\n\n  var entryFunction = Module['_main'];\n\n\n  args = args || [];\n\n  var argc = args.length+1;\n  var argv = stackAlloc((argc + 1) * 4);\n  HEAP32[argv >> 2] = allocateUTF8OnStack(thisProgram);\n  for (var i = 1; i < argc; i++) {\n    HEAP32[(argv >> 2) + i] = allocateUTF8OnStack(args[i - 1]);\n  }\n  HEAP32[(argv >> 2) + argc] = 0;\n\n\n  try {\n\n    Module['___set_stack_limit'](STACK_MAX);\n\n    var ret = entryFunction(argc, argv);\n\n\n    // In PROXY_TO_PTHREAD builds, we should never exit the runtime below, as execution is asynchronously handed\n    // off to a pthread.\n    // if we're not running an evented main loop, it's time to exit\n      exit(ret, /* implicit = */ true);\n  }\n  catch(e) {\n    if (e instanceof ExitStatus) {\n      // exit() throws this once it's done to make sure execution\n      // has been stopped completely\n      return;\n    } else if (e == 'unwind') {\n      // running an evented main loop, don't immediately exit\n      noExitRuntime = true;\n      return;\n    } else {\n      var toLog = e;\n      if (e && typeof e === 'object' && e.stack) {\n        toLog = [e, e.stack];\n      }\n      err('exception thrown: ' + toLog);\n      quit_(1, e);\n    }\n  } finally {\n    calledMain = true;\n  }\n}\n\n\n\n\n/** @type {function(Array=)} */\nfunction run(args) {\n  args = args || arguments_;\n\n  if (runDependencies > 0) {\n    return;\n  }\n\n  writeStackCookie();\n\n  preRun();\n\n  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later\n\n  function doRun() {\n    // run may have just been called through dependencies being fulfilled just in this very frame,\n    // or while the async setStatus time below was happening\n    if (calledRun) return;\n    calledRun = true;\n\n    if (ABORT) return;\n\n    initRuntime();\n\n    preMain();\n\n    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\n\n    if (shouldRunNow) callMain(args);\n\n    postRun();\n  }\n\n  if (Module['setStatus']) {\n    Module['setStatus']('Running...');\n    setTimeout(function() {\n      setTimeout(function() {\n        Module['setStatus']('');\n      }, 1);\n      doRun();\n    }, 1);\n  } else\n  {\n    doRun();\n  }\n  checkStackCookie();\n}\nModule['run'] = run;\n\nfunction checkUnflushedContent() {\n  // Compiler settings do not allow exiting the runtime, so flushing\n  // the streams is not possible. but in ASSERTIONS mode we check\n  // if there was something to flush, and if so tell the user they\n  // should request that the runtime be exitable.\n  // Normally we would not even include flush() at all, but in ASSERTIONS\n  // builds we do so just for this check, and here we see if there is any\n  // content to flush, that is, we check if there would have been\n  // something a non-ASSERTIONS build would have not seen.\n  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0\n  // mode (which has its own special function for this; otherwise, all\n  // the code is inside libc)\n  var print = out;\n  var printErr = err;\n  var has = false;\n  out = err = function(x) {\n    has = true;\n  }\n  try { // it doesn't matter if it fails\n    var flush = flush_NO_FILESYSTEM;\n    if (flush) flush(0);\n  } catch(e) {}\n  out = print;\n  err = printErr;\n  if (has) {\n    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.');\n    warnOnce('(this may also be due to not including full filesystem support - try building with -s FORCE_FILESYSTEM=1)');\n  }\n}\n\nfunction exit(status, implicit) {\n  checkUnflushedContent();\n\n  // if this is just main exit-ing implicitly, and the status is 0, then we\n  // don't need to do anything here and can just leave. if the status is\n  // non-zero, though, then we need to report it.\n  // (we may have warned about this earlier, if a situation justifies doing so)\n  if (implicit && noExitRuntime && status === 0) {\n    return;\n  }\n\n  if (noExitRuntime) {\n    // if exit() was called, we may warn the user if the runtime isn't actually being shut down\n    if (!implicit) {\n      err('program exited (with status: ' + status + '), but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)');\n    }\n  } else {\n\n    ABORT = true;\n    EXITSTATUS = status;\n\n    exitRuntime();\n\n    if (Module['onExit']) Module['onExit'](status);\n  }\n\n  quit_(status, new ExitStatus(status));\n}\n\nif (Module['preInit']) {\n  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n  while (Module['preInit'].length > 0) {\n    Module['preInit'].pop()();\n  }\n}\n\n// shouldRunNow refers to calling main(), not run().\nvar shouldRunNow = true;\n\nif (Module['noInitialRun']) shouldRunNow = false;\n\n\n  noExitRuntime = true;\n\nrun();\n\n\n\n\n\n// {{MODULE_ADDITIONS}}\n\n\n\n\n\n  return Module\n}\n);\n})();\n/* harmony default export */ __webpack_exports__[\"default\"] = (Module);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/timers-browserify/main.js */ \"../node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack:///../wasm/lib/greycat.js?");

/***/ }),

/***/ "../wasm/lib/greycat.wasm":
/*!********************************!*\
  !*** ../wasm/lib/greycat.wasm ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"/bef60982921313d196db8a66c274b513.wasm\";\n\n//# sourceURL=webpack:///../wasm/lib/greycat.wasm?");

/***/ }),

/***/ "../wasm/lib/index.js":
/*!****************************!*\
  !*** ../wasm/lib/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addon\", function() { return addon; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony import */ var _greycat_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./greycat.js */ \"../wasm/lib/greycat.js\");\n/* harmony import */ var _greycat_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./greycat.wasm */ \"../wasm/lib/greycat.wasm\");\n/* harmony import */ var _greycat_wasm__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_greycat_wasm__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common */ \"../wasm/lib/common.js\");\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _common__WEBPACK_IMPORTED_MODULE_2__) if([\"addon\",\"init\",\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _common__WEBPACK_IMPORTED_MODULE_2__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Graph */ \"../wasm/lib/Graph.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Graph\", function() { return _Graph__WEBPACK_IMPORTED_MODULE_3__[\"Graph\"]; });\n\n/* harmony import */ var _GObject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GObject */ \"../wasm/lib/GObject.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"GObject\", function() { return _GObject__WEBPACK_IMPORTED_MODULE_4__[\"GObject\"]; });\n\n/* harmony import */ var _GArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GArray */ \"../wasm/lib/GArray.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"GArray\", function() { return _GArray__WEBPACK_IMPORTED_MODULE_5__[\"GArray\"]; });\n\n/* harmony import */ var _GFunction__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./GFunction */ \"../wasm/lib/GFunction.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"GFunction\", function() { return _GFunction__WEBPACK_IMPORTED_MODULE_6__[\"GFunction\"]; });\n\n/* harmony import */ var _GRef__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./GRef */ \"../wasm/lib/GRef.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"GRef\", function() { return _GRef__WEBPACK_IMPORTED_MODULE_7__[\"GRef\"]; });\n\n/* harmony import */ var _GString__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./GString */ \"../wasm/lib/GString.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"GString\", function() { return _GString__WEBPACK_IMPORTED_MODULE_8__[\"GString\"]; });\n\n\n\n\n\n\n\n\n\n\n\nconst addon = Object(_greycat_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    locateFile(path) {\n        if (path.substr(path.length - '.wasm'.length, path.length) === '.wasm') {\n            return _greycat_wasm__WEBPACK_IMPORTED_MODULE_1___default.a;\n        }\n        return path;\n    },\n    Logger: console,\n    GreyCatError: _common__WEBPACK_IMPORTED_MODULE_2__[\"GreyCatError\"],\n    print: console.log.bind(console),\n    printErr: console.error.bind(console),\n});\nconst addon_ready = new Promise((resolve) => addon.then(() => resolve()));\nfunction init(options = {}) {\n    if (options.logger) {\n        addon.Logger = options.logger;\n    }\n    return addon_ready;\n}\n\n\n//# sourceURL=webpack:///../wasm/lib/index.js?");

/***/ }),

/***/ "../wasm/lib/types.js":
/*!****************************!*\
  !*** ../wasm/lib/types.js ***!
  \****************************/
/*! exports provided: js_to_greycat, greycat_to_js, js_to_slot, slot_to_js, createGString, createGArray, createGObject, createGMap, createGFunction, getLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"js_to_greycat\", function() { return js_to_greycat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"greycat_to_js\", function() { return greycat_to_js; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"js_to_slot\", function() { return js_to_slot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"slot_to_js\", function() { return slot_to_js; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createGString\", function() { return createGString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createGArray\", function() { return createGArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createGObject\", function() { return createGObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createGMap\", function() { return createGMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createGFunction\", function() { return createGFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getLong\", function() { return getLong; });\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! . */ \"../wasm/lib/index.js\");\n/* harmony import */ var _GArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GArray */ \"../wasm/lib/GArray.js\");\n/* harmony import */ var _GObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GObject */ \"../wasm/lib/GObject.js\");\n/* harmony import */ var _GMap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GMap */ \"../wasm/lib/GMap.js\");\n/* harmony import */ var _GFunction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GFunction */ \"../wasm/lib/GFunction.js\");\n/* harmony import */ var _GRef__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GRef */ \"../wasm/lib/GRef.js\");\n/* harmony import */ var _GString__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./GString */ \"../wasm/lib/GString.js\");\n\n\n\n\n\n\n\nconst C_INT_MAX = 2147483647;\nconst view = new DataView(new ArrayBuffer(64));\nfunction isGType(value) {\n    return (value instanceof _GObject__WEBPACK_IMPORTED_MODULE_2__[\"GObject\"] ||\n        value instanceof _GMap__WEBPACK_IMPORTED_MODULE_3__[\"GMap\"] ||\n        value instanceof _GArray__WEBPACK_IMPORTED_MODULE_1__[\"GArray\"] ||\n        value instanceof _GFunction__WEBPACK_IMPORTED_MODULE_4__[\"GFunction\"] ||\n        value instanceof _GRef__WEBPACK_IMPORTED_MODULE_5__[\"GRef\"]);\n}\nfunction js_to_greycat(value, graph_ptr, handler) {\n    switch (typeof value) {\n        case 'number': {\n            if (value.toString().indexOf('.') !== -1) {\n                handler.isDouble(value);\n                return;\n            }\n            if (value >= -C_INT_MAX && value <= C_INT_MAX) {\n                handler.isInt32(value);\n                return;\n            }\n            view.setBigInt64(0, BigInt(value));\n            handler.isLong(view.getInt32(0), view.getInt32(4));\n            return;\n        }\n        case 'bigint': {\n            view.setBigInt64(0, BigInt(value));\n            handler.isLong(view.getInt32(0), view.getInt32(4));\n            return;\n        }\n        case 'boolean': {\n            handler.isBoolean(value);\n            return;\n        }\n        case 'string': {\n            handler.isObject(createGString(graph_ptr, value).ptr);\n            return;\n        }\n        case 'undefined': {\n            handler.isUndefined();\n            return;\n        }\n        case 'function': {\n            handler.isObject(createGFunction(graph_ptr, value).ptr);\n            return;\n        }\n        case 'object': {\n            if (value === null) {\n                handler.isNull();\n                return;\n            }\n            if (isGType(value)) {\n                if (value instanceof _GObject__WEBPACK_IMPORTED_MODULE_2__[\"GObject\"] || value instanceof _GArray__WEBPACK_IMPORTED_MODULE_1__[\"GArray\"]) {\n                    handler.isObject(value.$$_ptr);\n                }\n                else {\n                    handler.isObject(value.ptr);\n                }\n                return;\n            }\n            if (value instanceof Array) {\n                handler.isObject(createGArray(graph_ptr, value).$$_ptr);\n                return;\n            }\n            if (value instanceof Map) {\n                handler.isObject(createGMap(graph_ptr, value).ptr);\n                return;\n            }\n            if (value instanceof String) {\n                handler.isObject(createGString(graph_ptr, value.toString()).ptr);\n                return;\n            }\n            handler.isObject(createGObject(graph_ptr, value).$$_ptr);\n            return;\n        }\n        default:\n            break;\n    }\n    handler.isNotHandled(value);\n}\nfunction greycat_to_js(handler) {\n    const type = handler.getValueType();\n    switch (type) {\n        case ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_null: return null;\n        case ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_bool: return handler.getBool() === 1;\n        case ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_i32: return handler.getInt32();\n        case ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].u32: return handler.getUint();\n        case ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_i64: return getLong(handler.getLong());\n        case ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_u64: return getLong(handler.getULong());\n        case ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_f64: return handler.getDouble();\n        case ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_Map: return new _GMap__WEBPACK_IMPORTED_MODULE_3__[\"GMap\"](handler.getObject());\n        case ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_Array: return new _GArray__WEBPACK_IMPORTED_MODULE_1__[\"GArray\"](handler.getObject());\n        case ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_Function: return new _GFunction__WEBPACK_IMPORTED_MODULE_4__[\"GFunction\"](handler.getObject());\n        case ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_String: return new _GString__WEBPACK_IMPORTED_MODULE_6__[\"GString\"](handler.getObject()).value;\n        case ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_Ref: return new _GRef__WEBPACK_IMPORTED_MODULE_5__[\"GRef\"](handler.getObject());\n        default:\n        case ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_Object: return new _GObject__WEBPACK_IMPORTED_MODULE_2__[\"GObject\"](handler.getObject());\n    }\n}\nfunction js_to_slot(value, graph_ptr) {\n    let slot = 0;\n    let type = 0;\n    js_to_greycat(value, graph_ptr, {\n        isInt32: (v) => {\n            slot = ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gslot__from_int(v);\n            type = ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_i32;\n        },\n        isDouble: (v) => {\n            slot = ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gslot__from_double(v);\n            type = ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_f64;\n        },\n        isBoolean: (v) => {\n            slot = ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gslot__from_bool(v ? 1 : 0);\n            type = ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_bool;\n        },\n        isLong: (high, low) => {\n            slot = ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gslot__from_long(high, low);\n            type = ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_i64;\n        },\n        isNull: () => {\n            slot = ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gslot__from_null();\n            type = ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_null;\n        },\n        isObject: (obj_ptr) => {\n            const obj_type = ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._object__type_key(obj_ptr);\n            if (obj_type === ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_Map) {\n                slot = ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gslot__from_object(obj_ptr);\n                type = ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_Map;\n            }\n            else if (obj_type === ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_Array) {\n                slot = ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gslot__from_object(obj_ptr);\n                type = ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_Array;\n            }\n            else if (obj_type === ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_Function) {\n                slot = ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gslot__from_object(obj_ptr);\n                type = ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_Function;\n            }\n            else if (obj_type === ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_Object) {\n                slot = ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gslot__from_object(obj_ptr);\n                type = ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_Object;\n            }\n            else if (obj_type === ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_String) {\n                slot = ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gslot__from_object(obj_ptr);\n                type = ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_String;\n            }\n            else if (obj_type === ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_Ref) {\n                slot = ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gslot__from_reference(obj_ptr);\n                type = ___WEBPACK_IMPORTED_MODULE_0__[\"Keys\"].g_Ref;\n            }\n        },\n        isUndefined: () => {\n        },\n        isNotHandled: (v) => {\n            console.error(`js_to_slot can't set value '${v}' of type '${typeof v}': not handled yet`);\n        },\n    });\n    if (slot !== 0) {\n        return { ptr: slot, type };\n    }\n    return;\n}\nfunction slot_to_js(slot_ptr, key) {\n    return greycat_to_js({\n        getValueType() {\n            return key;\n        },\n        getBool() {\n            return ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gslot__get_bool(slot_ptr);\n        },\n        getDouble() {\n            return ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gslot__get_double(slot_ptr);\n        },\n        getFloat() {\n            return ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gslot__get_float(slot_ptr);\n        },\n        getInt32() {\n            return ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gslot__get_int(slot_ptr);\n        },\n        getLong() {\n            return ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gslot__get_long(slot_ptr);\n        },\n        getObject() {\n            return ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gslot__get_object(slot_ptr);\n        },\n        getULong() {\n            return ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gslot__get_ulong(slot_ptr);\n        },\n        getUint() {\n            return ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._gslot__get_uint(slot_ptr);\n        },\n    });\n}\nfunction createGString(graph_ptr, value) {\n    const g_str = ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._ggraph__create_string(graph_ptr);\n    const str = new _GString__WEBPACK_IMPORTED_MODULE_6__[\"GString\"](g_str);\n    str.value = value;\n    return str;\n}\nfunction createGArray(graph_ptr, value) {\n    const g_arr = ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._ggraph__create_array(graph_ptr);\n    const arr = new _GArray__WEBPACK_IMPORTED_MODULE_1__[\"GArray\"](g_arr);\n    arr.resize(value.length);\n    value.forEach((elem, i) => {\n        arr[i] = elem;\n    });\n    return arr;\n}\nfunction createGObject(graph_ptr, value) {\n    const g_obj = ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._ggraph__create_open_object(graph_ptr);\n    const obj = new _GObject__WEBPACK_IMPORTED_MODULE_2__[\"GObject\"](g_obj);\n    Object.keys(value).forEach((propName) => {\n        obj[propName] = value[propName];\n    });\n    return obj;\n}\nfunction createGMap(graph_ptr, value) {\n    const g_map = ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._ggraph__create_map(graph_ptr);\n    const map = new _GMap__WEBPACK_IMPORTED_MODULE_3__[\"GMap\"](g_map);\n    value.forEach((mvalue, mkey) => map.set(mkey, mvalue));\n    return map;\n}\nfunction createGFunction(graph_ptr, value) {\n    const g_func = ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"]._ggraph__create_function(graph_ptr);\n    const func = new _GFunction__WEBPACK_IMPORTED_MODULE_4__[\"GFunction\"](g_func);\n    func.then(value);\n    return func;\n}\nfunction getLong(low) {\n    view.setInt32(0, ___WEBPACK_IMPORTED_MODULE_0__[\"addon\"].getTempRet0());\n    view.setInt32(4, low);\n    const bigInt = view.getBigInt64(0);\n    if (bigInt >= -Number.MAX_SAFE_INTEGER && bigInt <= Number.MAX_SAFE_INTEGER) {\n        return parseInt(bigInt.toString(), 10);\n    }\n    else {\n        return bigInt;\n    }\n}\n\n\n//# sourceURL=webpack:///../wasm/lib/types.js?");

/***/ }),

/***/ "./lib/browser.js":
/*!************************!*\
  !*** ./lib/browser.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst g = __importStar(__webpack_require__(/*! ./greycat */ \"./lib/greycat.js\"));\nmocha.setup('bdd');\n__webpack_require__(/*! ./index.test */ \"./lib/index.test.js\");\n__webpack_require__(/*! ./graph.test */ \"./lib/graph.test.js\");\n__webpack_require__(/*! ./context.test */ \"./lib/context.test.js\");\n__webpack_require__(/*! ./gfunction.test */ \"./lib/gfunction.test.js\");\n__webpack_require__(/*! ./gobject.test */ \"./lib/gobject.test.js\");\n__webpack_require__(/*! ./garray.test */ \"./lib/garray.test.js\");\n__webpack_require__(/*! ./gtype.test */ \"./lib/gtype.test.js\");\n__webpack_require__(/*! ./logger.test */ \"./lib/logger.test.js\");\nmocha.run(() => {\n    console.log('All tests done.', g.addon.__pointers);\n});\n\n\n//# sourceURL=webpack:///./lib/browser.js?");

/***/ }),

/***/ "./lib/context.test.js":
/*!*****************************!*\
  !*** ./lib/context.test.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst chai_1 = __webpack_require__(/*! chai */ \"../node_modules/chai/index.js\");\nconst greycat_1 = __webpack_require__(/*! ./greycat */ \"./lib/greycat.js\");\nbefore(() => greycat_1.init());\ndescribe('Context', () => {\n    it('create', () => {\n        const g = new greycat_1.Graph();\n        const c = g.newContext();\n        chai_1.expect(c).to.be.ok;\n        c.unmark();\n        g.destroy();\n    });\n    it('graph', () => {\n        const g = new greycat_1.Graph();\n        const c = g.newContext();\n        chai_1.expect(c).to.be.ok;\n        chai_1.expect(c.graph()).to.equal(g);\n        c.unmark();\n        g.destroy();\n    });\n    describe('execute', () => {\n        it('string', () => {\n            const g = new greycat_1.Graph();\n            g.newFunction()\n                .then(\"var res = 'Hello World';\")\n                .execute((_, c) => {\n                chai_1.expect(c.get('res')).to.equal('Hello World');\n                c.unmark();\n            })\n                .unmark();\n            g.destroy();\n        });\n        it('number (i32)', () => {\n            const g = new greycat_1.Graph();\n            g.newFunction()\n                .then('var res = 42;')\n                .execute((_, c) => {\n                chai_1.expect(c.get('res')).to.equal(42);\n                c.unmark();\n            })\n                .unmark();\n            g.destroy();\n        });\n        it('number (more than i32 but less than i53)', () => {\n            const g = new greycat_1.Graph();\n            g.newFunction()\n                .then('var res = 2147483647 + 42;')\n                .execute((_, c) => {\n                chai_1.expect(c.get('res')).to.equal(-2147483607);\n                c.unmark();\n            })\n                .unmark();\n            g.destroy();\n        });\n        it('number (i53)', () => {\n            const g = new greycat_1.Graph();\n            g.newFunction()\n                .then('var res = 9007199254740991;')\n                .execute((_, c) => {\n                chai_1.expect(c.get('res')).to.equal(Number.MAX_SAFE_INTEGER);\n                c.unmark();\n            })\n                .unmark();\n            g.destroy();\n        });\n        it('number (more than i53)', () => {\n            const g = new greycat_1.Graph();\n            g.newFunction()\n                .then('var res = 9007199254740991 + 1l;')\n                .execute((_, c) => {\n                chai_1.expect(c.get('res')).to.equal(BigInt(9007199254740992));\n                c.unmark();\n            })\n                .unmark();\n            g.destroy();\n        });\n        it('double', () => {\n            const g = new greycat_1.Graph();\n            g.newFunction()\n                .then('var res = 3.14;')\n                .execute((_, c) => {\n                chai_1.expect(c.get('res')).to.equal(3.14);\n                c.unmark();\n            })\n                .unmark();\n            g.destroy();\n        });\n        it('bool', () => {\n            const g = new greycat_1.Graph();\n            g.newFunction()\n                .then('var res = false;')\n                .execute((_, c) => {\n                chai_1.expect(c.get('res')).to.equal(false);\n                c.unmark();\n            })\n                .unmark();\n            g.destroy();\n        });\n        it('empty object', () => {\n            const g = new greycat_1.Graph();\n            g.newFunction()\n                .then('var res = {};')\n                .execute((_, c) => {\n                chai_1.expect(Object.keys(c.get('res'))).to.eql([]);\n                c.unmark();\n            })\n                .unmark();\n            g.destroy();\n        });\n        it('non-empty object', () => {\n            const g = new greycat_1.Graph();\n            g.newFunction()\n                .then(\"var res = { hello: 'world' };\")\n                .execute((_, c) => {\n                chai_1.expect(c.get('res').toJSON()).to.eql({ hello: 'world' });\n                c.unmark();\n            })\n                .unmark();\n            g.destroy();\n        });\n        it('array', () => {\n            const g = new greycat_1.Graph();\n            g.newFunction()\n                .then(\"var res = ['foo', 42, { name: 'John'}, false, 3.14];\")\n                .execute((_, c) => {\n                const result = c.get('res');\n                chai_1.expect(result.size()).to.equal(5);\n                chai_1.expect(result[0]).to.equal('foo');\n                chai_1.expect(result[1]).to.equal(42);\n                chai_1.expect(result[2].toJSON()).to.eql({ name: 'John' });\n                chai_1.expect(result[3]).to.equal(false);\n                chai_1.expect(result[4]).to.equal(3.14);\n                chai_1.expect(result.none).to.be.undefined;\n                chai_1.expect(result.toJSON()).to.eql(['foo', 42, { name: 'John' }, false, 3.14]);\n                c.unmark();\n            })\n                .unmark();\n            g.destroy();\n        });\n        it('function set value', () => {\n            const g = new greycat_1.Graph();\n            g.newFunction()\n                .then((ctx) => {\n                ctx.set('foo', 42);\n            })\n                .execute((_, c) => {\n                chai_1.expect(c.get('foo')).to.equal(42);\n                c.unmark();\n            })\n                .unmark();\n            g.destroy();\n        });\n        it('get/set GObject', () => {\n            const g = new greycat_1.Graph();\n            g.newFunction()\n                .then('var o = { foo: \"bar\" };')\n                .then((c) => c.get('o').baz = 'beep')\n                .execute((_, c) => {\n                chai_1.expect(c.get('o').toJSON()).to.eql({ foo: 'bar', baz: 'beep' });\n                c.unmark();\n            })\n                .unmark();\n            g.destroy();\n        });\n    });\n    describe('failed execute', () => {\n        it('bad function return', () => {\n            const g = new greycat_1.Graph();\n            const c = g.newContext();\n            g.newFunction()\n                .then('function sayHello() : String | null { return 42; }; sayHello();', 'my_custom_script.gcl')\n                .execute(c.onError(null), (err) => {\n                chai_1.expect(err).to.be.ok;\n                if (err) {\n                    chai_1.expect(err.reason).to.equal('function \\'sayHello\\': bad result type after execution \\'Int\\' found, \\'String |null\\' expected');\n                }\n                c.unmark();\n            })\n                .unmark();\n            g.destroy();\n        });\n        it('bad function return with implicit ctx creation', () => {\n            const g = new greycat_1.Graph();\n            g.newFunction()\n                .then('function sayHello() : String | null { return 42; }; sayHello();', 'my_custom_script.gcl')\n                .execute((err, c) => {\n                chai_1.expect(err).to.be.ok;\n                if (err) {\n                    chai_1.expect(err.reason).to.equal('function \\'sayHello\\': bad result type after execution \\'Int\\' found, \\'String |null\\' expected');\n                }\n                c.unmark();\n            })\n                .unmark();\n            g.destroy();\n        });\n    });\n    it('multiple exec of cached func', () => {\n        const g = new greycat_1.Graph();\n        g.newFunction()\n            .then('var root = Graph::root(); root.users = Graph::newNode(Map {});')\n            .execute()\n            .unmark();\n        const fn = g.newFunction().then('Graph::root().users->set(id, value);');\n        fn.execute(g.newContext().set('id', 'one').set('value', 40), (err, c) => {\n            chai_1.expect(err).to.be.undefined;\n            c.unmark();\n        });\n        fn.execute(g.newContext().set('id', 'two').set('value', 2), (err, c) => {\n            chai_1.expect(err).to.be.undefined;\n            c.unmark();\n        });\n        g.newFunction()\n            .then([\n            'var users = [];',\n            'Graph::root().users->foreach((k: Any, v: Any) {',\n            '  users.add(v);',\n            '});',\n        ].join('\\n'))\n            .execute((_, c) => {\n            const users = c.get('users');\n            chai_1.expect(users).to.be.ok;\n            chai_1.expect(users.size()).to.equal(2);\n            chai_1.expect(users[0] + users[1]).to.equal(42);\n            c.unmark();\n        })\n            .unmark();\n        g.destroy();\n    });\n    describe('set', () => {\n        it('string', () => {\n            const g = new greycat_1.Graph();\n            const c = g.newContext();\n            c.set('input', 'Hello World');\n            chai_1.expect(c.get('input')).to.equal('Hello World');\n            c.unmark();\n            g.destroy();\n        });\n        it('number (i32)', () => {\n            const g = new greycat_1.Graph();\n            const c = g.newContext();\n            c.set('input', 42);\n            chai_1.expect(c.get('input')).to.equal(42);\n            c.unmark();\n            g.destroy();\n        });\n        it('number (more than i32 but less than i53)', () => {\n            const g = new greycat_1.Graph();\n            const c = g.newContext();\n            c.set('input', 2147483647 + 42);\n            chai_1.expect(c.get('input')).to.equal(2147483647 + 42);\n            c.unmark();\n            g.destroy();\n        });\n        it('number (i53)', () => {\n            const g = new greycat_1.Graph();\n            const c = g.newContext();\n            c.set('input', Number.MAX_SAFE_INTEGER);\n            chai_1.expect(c.get('input')).to.equal(Number.MAX_SAFE_INTEGER);\n            c.unmark();\n            g.destroy();\n        });\n        it('number (more than i53)', () => {\n            const g = new greycat_1.Graph();\n            const c = g.newContext();\n            c.set('input', Number.MAX_SAFE_INTEGER + Number.MAX_SAFE_INTEGER);\n            chai_1.expect(c.get('input')).to.eql(BigInt(Number.MAX_SAFE_INTEGER + Number.MAX_SAFE_INTEGER));\n            c.unmark();\n            g.destroy();\n        });\n        it('double', () => {\n            const g = new greycat_1.Graph();\n            const c = g.newContext();\n            c.set('input', 3.14);\n            chai_1.expect(c.get('input')).to.equal(3.14);\n            c.unmark();\n            g.destroy();\n        });\n        it('bool', () => {\n            const g = new greycat_1.Graph();\n            const c = g.newContext();\n            c.set('input', false);\n            chai_1.expect(c.get('input')).to.equal(false);\n            c.unmark();\n            g.destroy();\n        });\n        it('empty js object', () => {\n            const g = new greycat_1.Graph();\n            const c = g.newContext();\n            const obj = {};\n            c.set('input', obj);\n            chai_1.expect(c.get('input').toJSON()).to.eql(obj);\n            c.unmark();\n            g.destroy();\n        });\n        it('non-empty js object', () => {\n            const g = new greycat_1.Graph();\n            const c = g.newContext();\n            const obj = {\n                string: 'hello world',\n                int: 42,\n                double: 3.14,\n                boolean: true,\n                long: Number.MAX_SAFE_INTEGER,\n                bigint: Number.MAX_SAFE_INTEGER + Number.MAX_SAFE_INTEGER,\n                child: { name: 'John' },\n            };\n            c.set('input', obj);\n            const g_obj = c.get('input');\n            chai_1.expect(g_obj.toJSON()).to.eql(obj);\n            c.unmark();\n            g.destroy();\n        });\n        it('js object in script', () => {\n            const g = new greycat_1.Graph();\n            const c = g.newContext();\n            const obj = { child: { name: 'John' } };\n            c.set('input', obj);\n            g.newFunction()\n                .then('var res = input.child.name;')\n                .execute(c, () => {\n                chai_1.expect(c.get('res')).to.equal('John');\n                c.unmark();\n            })\n                .unmark();\n            g.destroy();\n        });\n        it('array', () => {\n            const g = new greycat_1.Graph();\n            const c = g.newContext();\n            const arr = ['foo', 42, { name: 'John' }, false, 3.14];\n            c.set('input', arr);\n            const g_arr = c.get('input');\n            chai_1.expect(g_arr.toJSON()).to.eql(arr);\n            c.unmark();\n            g.destroy();\n        });\n    });\n});\n\n\n//# sourceURL=webpack:///./lib/context.test.js?");

/***/ }),

/***/ "./lib/garray.test.js":
/*!****************************!*\
  !*** ./lib/garray.test.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst chai_1 = __webpack_require__(/*! chai */ \"../node_modules/chai/index.js\");\nconst greycat_1 = __webpack_require__(/*! ./greycat */ \"./lib/greycat.js\");\nbefore(() => greycat_1.init());\ndescribe('GArray', () => {\n    describe('from GCL', () => {\n        let g;\n        let c;\n        beforeEach(() => {\n            g = new greycat_1.Graph();\n            c = g.newContext();\n        });\n        afterEach(() => {\n            c.unmark();\n            g.destroy();\n        });\n        it('size', (done) => {\n            g.newFunction()\n                .then(\"var a = ['hello', 'world'];\")\n                .execute(c, () => {\n                chai_1.expect(c.get('a').size()).to.equal(2);\n                done();\n            })\n                .unmark();\n        });\n        it('access by offset', (done) => {\n            g.newFunction()\n                .then(\"var a = ['hello', 'world'];\")\n                .execute(c, () => {\n                const a = c.get('a');\n                chai_1.expect(a).instanceOf(greycat_1.GArray);\n                chai_1.expect(a[0]).to.equal('hello');\n                chai_1.expect(a[1]).to.equal('world');\n                done();\n            })\n                .unmark();\n        });\n        it('add', (done) => {\n            g.newFunction()\n                .then('var a = [];')\n                .execute(c, () => {\n                const a = c.get('a');\n                chai_1.expect(a.size()).to.equal(0);\n                a.add(42);\n                chai_1.expect(a.size()).to.equal(1);\n                chai_1.expect(a[0]).to.equal(42);\n                done();\n            })\n                .unmark();\n        });\n        it('resize', (done) => {\n            g.newFunction()\n                .then('var a = [];')\n                .execute(c, () => {\n                const a = c.get('a');\n                chai_1.expect(a.size()).to.equal(0);\n                a.resize(42);\n                chai_1.expect(a.size()).to.equal(42);\n                a[41] = 1337;\n                chai_1.expect(a[41]).to.equal(1337);\n                done();\n            })\n                .unmark();\n        });\n    });\n});\n\n\n//# sourceURL=webpack:///./lib/garray.test.js?");

/***/ }),

/***/ "./lib/gfunction.test.js":
/*!*******************************!*\
  !*** ./lib/gfunction.test.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst chai_1 = __webpack_require__(/*! chai */ \"../node_modules/chai/index.js\");\nconst greycat_1 = __webpack_require__(/*! ./greycat */ \"./lib/greycat.js\");\nbefore(() => greycat_1.init());\ndescribe('GFunction', () => {\n    it('create', () => {\n        const g = new greycat_1.Graph();\n        const f = g.newFunction();\n        chai_1.expect(f).to.be.ok;\n        f.unmark();\n        g.destroy();\n    });\n    it('parse', () => {\n        const g = new greycat_1.Graph();\n        const f = g.newFunction();\n        chai_1.expect(() => f.then('// empty')).not.to.throw;\n        f.unmark();\n        g.destroy();\n    });\n    it('execute', () => {\n        const g = new greycat_1.Graph();\n        const f = g.newFunction().then('var p = 42;').execute((err, ctx) => {\n            if (err) {\n                throw err;\n            }\n            chai_1.expect(ctx.get('p')).to.eql(42);\n        });\n        f.unmark();\n        g.destroy();\n    });\n    it('invalid parse', () => {\n        const g = new greycat_1.Graph();\n        const f = g.newFunction();\n        chai_1.expect(() => f.then('%')).to.throw('Unable to parse script');\n        f.unmark();\n        g.destroy();\n    });\n    it('pipe GFunction', () => {\n        const g = new greycat_1.Graph();\n        const c = g.newContext();\n        const next = g.newFunction().then('a = 100;');\n        g.newFunction()\n            .then('var a = 40;')\n            .then(next)\n            .execute(c, () => {\n            next.unmark();\n            chai_1.expect(c.get('a')).to.equal(100);\n            c.unmark();\n        })\n            .unmark();\n        g.destroy();\n    });\n    it('pipe native function', () => {\n        const g = new greycat_1.Graph();\n        const c = g.newContext();\n        const next = g.newFunction().then((ctx) => ctx.set('a', 42));\n        g.newFunction()\n            .then('var a = 40;')\n            .then(next)\n            .execute(c, () => {\n            next.unmark();\n            chai_1.expect(c.get('a')).to.equal(42);\n            c.unmark();\n        })\n            .unmark();\n        g.destroy();\n    });\n    if (typeof document === 'undefined') {\n        it('with params', () => {\n            const g = new greycat_1.Graph();\n            const c = g.newContext();\n            const identity = g\n                .newFunction()\n                .defineParam({ name: 'value' })\n                .then((ctx) => {\n                ctx.setResult(ctx.get('value'));\n            });\n            c.set('identity', identity);\n            g.newFunction()\n                .then('var res = identity({ foo: \"bar\" });')\n                .execute(c, (_) => {\n                chai_1.expect(c.get('res').toJSON()).to.eql({ foo: 'bar' });\n                c.unmark();\n            })\n                .unmark();\n            g.destroy();\n        });\n    }\n});\n\n\n//# sourceURL=webpack:///./lib/gfunction.test.js?");

/***/ }),

/***/ "./lib/gobject.test.js":
/*!*****************************!*\
  !*** ./lib/gobject.test.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst chai_1 = __webpack_require__(/*! chai */ \"../node_modules/chai/index.js\");\nconst greycat_1 = __webpack_require__(/*! ./greycat */ \"./lib/greycat.js\");\nbefore(() => greycat_1.init());\ndescribe('GObject', () => {\n    describe('from GCL', () => {\n        let g;\n        let c;\n        beforeEach(() => {\n            g = new greycat_1.Graph();\n            c = g.newContext();\n        });\n        afterEach(() => {\n            c.unmark();\n            g.destroy();\n        });\n        it('string', (done) => {\n            g.newFunction()\n                .then(\"var o = { hello: 'world' };\")\n                .execute(c, () => {\n                chai_1.expect(c.get('o').hello).to.equal('world');\n                done();\n            })\n                .unmark();\n        });\n        it('nested object', (done) => {\n            g.newFunction()\n                .then(\"var o = { child: { name: 'John' } };\")\n                .execute(c, () => {\n                chai_1.expect(c.get('o').child.name).to.equal('John');\n                done();\n            })\n                .unmark();\n        });\n        it('complex object', (done) => {\n            g.newFunction()\n                .then(\"var o = { foo: 42, child: { name: 'John' } };\")\n                .execute(c, () => {\n                const o = c.get('o');\n                chai_1.expect(o).to.be.instanceOf(greycat_1.GObject);\n                chai_1.expect(o.foo).to.equal(42);\n                chai_1.expect(o.child.name).to.equal('John');\n                chai_1.expect(o.child.toJSON()).to.eql({ name: 'John' });\n                done();\n            })\n                .unmark();\n        });\n        it.skip('function', (done) => {\n            g.newFunction()\n                .then(\"var o = { name: 'John', getName: () { return this.name } };\")\n                .execute(c, () => {\n                const o = c.get('o');\n                chai_1.expect(o.name).to.equal('John');\n                chai_1.expect(o.getName()).to.equal('John');\n                done();\n            })\n                .unmark();\n        });\n        it.skip('function with params', (done) => {\n            g.newFunction()\n                .then('var o = { add: (a: int, b: int) { return a + b; } };')\n                .execute(c, () => {\n                chai_1.expect(c.get('o').add(40, 2)).to.equal(42);\n                done();\n            })\n                .unmark();\n        });\n    });\n});\n\n\n//# sourceURL=webpack:///./lib/gobject.test.js?");

/***/ }),

/***/ "./lib/graph.test.js":
/*!***************************!*\
  !*** ./lib/graph.test.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst chai_1 = __webpack_require__(/*! chai */ \"../node_modules/chai/index.js\");\nconst greycat_1 = __webpack_require__(/*! ./greycat */ \"./lib/greycat.js\");\nbefore(() => greycat_1.init());\ndescribe('Graph', () => {\n    let g;\n    beforeEach(() => {\n        g = new greycat_1.Graph();\n    });\n    afterEach(() => {\n        g.destroy();\n    });\n    it('create', () => {\n        chai_1.expect(g).to.be.ok;\n    });\n    it('newFunction', () => {\n        const f = g.newFunction();\n        chai_1.expect(f).to.be.ok;\n        f.unmark();\n    });\n    it('exportTypes', () => {\n        chai_1.expect(g.exportTypes()).to.be.ok;\n    });\n    it('meta', () => {\n        chai_1.expect(g.isMeta('Ref')).to.be.true;\n        chai_1.expect(g.isMeta('Sensor')).to.be.false;\n        const sensorKey = g.declareMeta('Sensor');\n        chai_1.expect(sensorKey).to.equals(greycat_1.hash('Sensor'));\n        chai_1.expect(g.isMeta('Sensor')).to.be.true;\n    });\n});\n\n\n//# sourceURL=webpack:///./lib/graph.test.js?");

/***/ }),

/***/ "./lib/greycat.js":
/*!************************!*\
  !*** ./lib/greycat.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! @greycat/core-napi */ \"../wasm/lib/index.js\"));\n\n\n//# sourceURL=webpack:///./lib/greycat.js?");

/***/ }),

/***/ "./lib/gtype.test.js":
/*!***************************!*\
  !*** ./lib/gtype.test.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst greycat_1 = __webpack_require__(/*! ./greycat */ \"./lib/greycat.js\");\nconst chai_1 = __webpack_require__(/*! chai */ \"../node_modules/chai/index.js\");\nbefore(() => greycat_1.init());\ndescribe('GType', () => {\n    it('attribute', () => {\n        const g = new greycat_1.Graph();\n        g.declareType('T')\n            .declareAttribute('a', greycat_1.Keys.g_String)\n            .seal()\n            .unmark();\n        g.newFunction()\n            .then('var t = T { a: \"foo\" };')\n            .execute((err, c) => {\n            chai_1.expect(err).to.be.undefined;\n            const t = c.get('t');\n            chai_1.expect(t.a).to.equal('foo');\n            c.unmark();\n        })\n            .unmark();\n        g.destroy();\n    });\n    it('static attribute (string)', () => {\n        const g = new greycat_1.Graph();\n        g.declareType('T')\n            .declareStaticAttribute('A', 'Hello World')\n            .seal()\n            .unmark();\n        g.newFunction()\n            .then('Assert::equals(T::A, \"Hello World\");')\n            .execute((err, c) => {\n            chai_1.expect(err).to.be.undefined;\n            c.unmark();\n        })\n            .unmark();\n        g.destroy();\n    });\n    it('static attribute (int)', () => {\n        const g = new greycat_1.Graph();\n        g.declareType('T')\n            .declareStaticAttribute('A', 42)\n            .seal()\n            .unmark();\n        g.newFunction()\n            .then('Assert::equals(T::A, 42);')\n            .execute((err, c) => {\n            chai_1.expect(err).to.be.undefined;\n            c.unmark();\n        })\n            .unmark();\n        g.destroy();\n    });\n    it('static attribute (bool)', () => {\n        const g = new greycat_1.Graph();\n        g.declareType('T')\n            .declareStaticAttribute('A', true)\n            .seal()\n            .unmark();\n        g.newFunction()\n            .then('Assert::equals(T::A, true);')\n            .execute((err, c) => {\n            chai_1.expect(err).to.be.undefined;\n            c.unmark();\n        })\n            .unmark();\n        g.destroy();\n    });\n    it('static attribute (double)', () => {\n        const g = new greycat_1.Graph();\n        g.declareType('T')\n            .declareStaticAttribute('A', 3.14)\n            .seal()\n            .unmark();\n        g.newFunction()\n            .then('Assert::equals(T::A, 3.14);')\n            .execute((err, c) => {\n            chai_1.expect(err).to.be.undefined;\n            c.unmark();\n        })\n            .unmark();\n        g.destroy();\n    });\n    if (typeof document === 'undefined') {\n        it('function', () => {\n            const g = new greycat_1.Graph();\n            g.declareType('T')\n                .declareAttribute('name', 'String')\n                .declareFunction('getName', (c) => {\n                c.setResult(c.get('this').name);\n            })\n                .seal()\n                .unmark();\n            g.newFunction()\n                .then('var t = T { name: \"John\" }; Assert::equals(t.getName(), \"John\");')\n                .execute((err, c) => {\n                chai_1.expect(err).to.be.undefined;\n                c.unmark();\n            })\n                .unmark();\n            g.destroy();\n        });\n        it('static function', () => {\n            const g = new greycat_1.Graph();\n            g.declareType('T')\n                .declareStaticFunction('hello', (c) => {\n                c.setResult('Hello World');\n            })\n                .seal()\n                .unmark();\n            g.newFunction()\n                .then('Assert::equals(T::hello(), \"Hello World\");')\n                .execute((err, c) => {\n                chai_1.expect(err).to.be.undefined;\n                c.unmark();\n            })\n                .unmark();\n            g.destroy();\n        });\n    }\n});\n\n\n//# sourceURL=webpack:///./lib/gtype.test.js?");

/***/ }),

/***/ "./lib/index.test.js":
/*!***************************!*\
  !*** ./lib/index.test.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst chai_1 = __webpack_require__(/*! chai */ \"../node_modules/chai/index.js\");\nconst greycat_1 = __webpack_require__(/*! ./greycat */ \"./lib/greycat.js\");\ndescribe('index', () => {\n    it('export init', () => {\n        chai_1.expect(greycat_1.init).to.be.instanceOf(Function);\n    });\n    it('export Graph', () => {\n        chai_1.expect(greycat_1.Graph).to.be.ok;\n    });\n});\n\n\n//# sourceURL=webpack:///./lib/index.test.js?");

/***/ }),

/***/ "./lib/logger.test.js":
/*!****************************!*\
  !*** ./lib/logger.test.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst chai_1 = __webpack_require__(/*! chai */ \"../node_modules/chai/index.js\");\nconst greycat_1 = __webpack_require__(/*! ./greycat */ \"./lib/greycat.js\");\nconst logs = [];\nconst infos = [];\nconst debugs = [];\nconst warns = [];\nconst errors = [];\nclass Logger {\n    constructor() {\n        this._logs = logs;\n        this._infos = infos;\n        this._debugs = debugs;\n        this._warns = warns;\n        this._errors = errors;\n    }\n    log(...args) {\n        this._logs.push(args[0]);\n    }\n    info(...args) {\n        this._infos.push(args[0]);\n    }\n    debug(...args) {\n        this._debugs.push(args[0]);\n    }\n    warn(...args) {\n        this._warns.push(args[0]);\n    }\n    error(...args) {\n        this._errors.push(args[0]);\n    }\n}\nbefore(() => greycat_1.init({ logger: new Logger() }));\ndescribe.skip('Logger', () => {\n    beforeEach(() => {\n        logs.length = 0;\n        infos.length = 0;\n        debugs.length = 0;\n        warns.length = 0;\n        errors.length = 0;\n    });\n    it('info', (done) => {\n        const g = new greycat_1.Graph();\n        g.newFunction()\n            .then(\"Log::info('graph_test', 'Hello World');\")\n            .execute((_, ctx) => {\n            chai_1.expect(infos[0]).to.equal('graph_test: \"Hello World\"');\n            ctx.unmark();\n            g.destroy();\n            done();\n        })\n            .unmark();\n    });\n});\n\n\n//# sourceURL=webpack:///./lib/logger.test.js?");

/***/ }),

/***/ 0:
/*!******************************!*\
  !*** multi ./lib/browser.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! /home/duke/Documents/projects/greycat/core/bindings/ts/tests/lib/browser.js */\"./lib/browser.js\");\n\n\n//# sourceURL=webpack:///multi_./lib/browser.js?");

/***/ })

/******/ });
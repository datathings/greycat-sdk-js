include 'types.gcl';

// =========== MAIN ============
var minTime = -1L;
var maxTime = -1L;

// init providers
var rnProvider = Graph::newNode(Provider { id: 'rennes-metro', containers: Map {} });
providers->set(rnProvider->id, rnProvider);

// init dataformats
// var whFormat = DataFormat { id: 'Wh' };
// var tempFormat = DataFormat { id: 'temperature' };

// =========== UTILS ===========
function loadData(provider: Reference /*Provider*/, name: String, filepath: String) {
  var container: Reference /*DataContainer*/ | null = provider->containers.get(name);
  if (container == null) {
    // aucun container pour ce lieu => create
    container = Graph::newNode(DataContainer { id: name, provider: provider, content: Map {} });
    // register container on provider
    provider->containers.set(container->id, container);
  }

  Console::println("loadData('${provider->id}', '${name}', '${filepath}')");

  // import data from CSV
  var fp = File::open(filepath, sep: ',');
  fp.foreach((row: Array, index: u64) {
    var city = row[0];
    var insee = row[1];
    var sensorId = row[2];
    var sensorName = row[3];
    var timestamp = row[5];
    var category = row[6];
    var dataType = row[7];
    var subType = row[8];
    var value = row[9];
    var unit = row[10];

    if (index == 0) {
      minTime = timestamp;
    }
    if (timestamp > maxTime) {
      maxTime = timestamp;
    }

    // create datatype with unit if needed
    var datatype: Reference /*DataType*/ | null = datatypes->get(unit);
    if (datatype == null) {
      datatype = Graph::newNode(DataType { id: unit });
      datatypes->set(datatype->id, datatype);
    }

    // create label if needed
    var mainLabel: Reference /*Label*/ | null = labels->get(category);
    if (mainLabel == null) {
      mainLabel = Graph::newNode(Label { id: category, subs: Map {}, data: Map {} });
      labels->set(mainLabel->id, mainLabel);
    }

    // init sub-label
    var subLabel: Reference /*Label*/ | null = null;
    // init sub-sub-label
    var subSubLabel: Reference /*Label*/ | null = null;

    if (dataType != null) {
      subLabel = mainLabel->subs.get(dataType);
      if (subLabel == null) {
        subLabel = Graph::newNode(Label { id: dataType, parent: mainLabel, subs: Map {}, data: Map {} });
        mainLabel->subs.set(subLabel->id, subLabel);
      }

      // init sub-sub-label
      if (subType != null) {
        subSubLabel = subLabel->subs.get(subType);
        if (subSubLabel == null) {
          subSubLabel = Graph::newNode(Label { id: subType, parent: subLabel, subs: Map {}, data: Map {} });
          subLabel->subs.set(subSubLabel->id, subSubLabel);
        }
      }
    }

    var sensor: Reference /*Data*/ | null = container->content.get(sensorId);
    if (sensor == null) {
      // create a data for this sensor
      sensor = Graph::newNode(Data { id: sensorId, container: container, datatype: datatype, labels: Map {}, meta: Map {} });
      sensor->meta.set('name', sensorName);
      // add data to container
      container->content.set(sensor->id, sensor);
      // add data to labels
      mainLabel->data.set(sensor->id, sensor);
      sensor->labels.set(mainLabel->id, mainLabel);
      if (subLabel != null) {
        subLabel->data.set(sensor->id, sensor);
        sensor->labels.set(subLabel->id, subLabel);
      }
      if (subSubLabel != null) {
        subSubLabel->data.set(sensor->id, sensor);
        sensor->labels.set(subSubLabel->id, subSubLabel);
      }
    }

    // on crée une valeur au temps indiqué
    var t = Date::new(timestamp);
    time (t) {
      //Console::println("Sensor ${sensor} at time ${t} is ${*sensor}");
      /*if (Node::resolvedTime(sensor) != null) {
        var t_sensor = Node::tref(*sensor);
        Console::println("Timed Sensor ref ${t_sensor}");
        if (t_sensor == null) {
          Node::newTime(sensor, { timed_value: value });
        } else {
          t_sensor->timed_value = value;
        }
      } else {
        Node::newTime(sensor, { timed_value: value });
      }
      /*var t_sensor: Data | null = *sensor;
      // attaching to an already created time result in an "attach error"
      if (t_sensor == null) {
        Node::newTime(sensor, { value: value }); 
      } else {
        t_sensor.value = { value: value };
      }*/
      //Console::println("${index} ${row}");
    }

    if (timestamp < minTime) {
      minTime = timestamp;
    }
    if (timestamp > maxTime) {
      maxTime = timestamp;
    }
  });
}
// ============================

Console::println('Hang tight, loading data...');
loadData(rnProvider, 'autre-lieu', './data/OED-AutreLieu-2018.csv');
// loadData(rnProvider, 'cosec', './data/OED-Cosec-2018.csv');
// loadData(rnProvider, 'gantelles', './data/OED-Gantelles-2018.csv');
// loadData(rnProvider, 'piscine', './data/OED-Piscine-2018.csv');

Console::println('Data loaded successfully');
Console::println("Min time = ${Date::new(minTime).toLocale()}");
Console::println("Max time = ${Date::new(maxTime).toLocale()}");
// =============================
